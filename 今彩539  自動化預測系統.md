# ==============================================
# 今彩539 自動化預測系統（多模型 + 特徵工程 + Walk-forward 回測）
# 模型：XGB / LGBM / CatBoost / Logistic / RF / CRF
# 重點：
# - Walk-forward：每 K 期重訓一次（貼近真實策略）
# - 特徵一次建滿：熱度/遺漏/miss/pair 共現/群組映射等
# - 對獎以「期數」為準（避免日期推算誤差）
# - 錯題本只讀「真實預測對獎」結果（避免回測污染）
# - 版路拖牌：以最新開獎為起點，預測 lag 期後可能拖出的號碼
# By Party87 + ChatGPT | 2025/12/30
# ==============================================

import warnings
import os
import sys
import re
import csv
import time
import pickle
import random
import tempfile
import contextlib
import multiprocessing
from io import StringIO
from math import comb
from datetime import timedelta, datetime
from collections import Counter, defaultdict

import requests
import numpy as np
import pandas as pd
from tqdm import tqdm
from colorama import Fore, Style

from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from catboost import CatBoostClassifier

import sklearn_crfsuite
from sklearn.multioutput import MultiOutputClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.exceptions import ConvergenceWarning
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.base import BaseEstimator, ClassifierMixin

# ===== GUI =====
import tkinter as tk
from tkinter import ttk, messagebox
import threading
import queue

# ===== ANSI 色碼剝除（Colorama / Console 顏色碼）=====
ANSI_ESCAPE_RE = re.compile(r"\x1b\[[0-9;]*m|\[[0-9]{1,3}m|\[0m")

# ==============================================
# CatBoost sklearn 相容 wrapper
# ==============================================
class CatBoostSklearnCompat(CatBoostClassifier, BaseEstimator, ClassifierMixin):
    """
    修正：舊版 CatBoost 在新版 scikit-learn 會缺 __sklearn_tags__ 而爆炸
    這個 wrapper 補上 tags 讓 MultiOutputClassifier 可以正常工作
    """
    def __sklearn_tags__(self):
        return BaseEstimator.__sklearn_tags__(self)


# ==============================================
# 輸出/雜訊控制（避免 warnings / stderr 洗版）
# ==============================================
os.environ.setdefault("PYTHONWARNINGS", "ignore")

warnings.simplefilter("ignore")
warnings.filterwarnings("ignore", category=ConvergenceWarning)
warnings.filterwarnings("ignore", message=".*lbfgs failed to converge.*", module=r"sklearn\.linear_model\._logistic")
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=FutureWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)


@contextlib.contextmanager
def suppress_all_output(enable=True):
    """enable=True：stdout/stderr/warnings 全部消音（訓練/預測用）"""
    if not enable:
        yield
        return
    old_showwarning = warnings.showwarning
    warnings.showwarning = lambda *args, **kwargs: None
    with open(os.devnull, "w") as devnull:
        with contextlib.redirect_stdout(devnull), contextlib.redirect_stderr(devnull):
            try:
                yield
            finally:
                warnings.showwarning = old_showwarning


# ==============================================
# 多執行緒/CPU 設定（B方案建議：統一用 CPU_LOGICAL-1，避免超額開執行緒）
# ==============================================
CPU_LOGICAL = multiprocessing.cpu_count()
AUTO_THREADS = max(1, CPU_LOGICAL - 1)

os.environ["OMP_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["MKL_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["OPENBLAS_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["NUMEXPR_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["VECLIB_MAXIMUM_THREADS"] = str(AUTO_THREADS)
os.environ["JOBLIB_MULTIPROCESSING"] = "1"

N_JOBS = AUTO_THREADS


# ==============================================
# 可調參數
# ==============================================
FAST_MODE = True
TRAIN_WINDOW = 1500 if FAST_MODE else None
DOWNLOAD_RETRY = 3

# 錯題本懲罰強度（自動隨真實對獎紀錄量變強）
MISTAKE_ALPHA = None  # 交給自動函數決定
SAVE_PROBA_CSV = True

USE_DETERMINISTIC = True
GLOBAL_SEED = 42

# Walk-forward：每 K 期才重訓一次
WALK_FORWARD_RETRAIN_INTERVAL = 20  # K

# 版路拖牌
DRAG_ENABLE = True
MAX_LAG = 10
MIN_CHAIN_RUN = 2
DRAG_MAX_ROWS = 365
DRAG_PREDICT_LAGS = list(range(1, 11))


def get_auto_mistake_alpha(result_file="latest_predict_result.csv"):
    """
    依真實對獎紀錄筆數自動調整錯題本懲罰強度
    - 紀錄少：懲罰小（避免被短期衰運帶偏）
    - 紀錄多：懲罰變強（讓錯題本更有糾錯力）
    """
    try:
        if not os.path.exists(result_file):
            return 0.05
        df = pd.read_csv(result_file, dtype=str, encoding="utf-8-sig")
        n = len(df)
    except Exception:
        return 0.05

    if n < 30:
        return 0.05
    elif n < 80:
        return 0.08
    elif n < 150:
        return 0.10
    else:
        return 0.12


# ==============================================
# CatBoost 訓練目錄
# ==============================================
def ensure_catboost_train_dir():
    base = os.path.join(tempfile.gettempdir(), "catboost_tmp")
    os.makedirs(base, exist_ok=True)

    os.environ["TMPDIR"] = base
    os.environ["TMP"] = base
    os.environ["TEMP"] = base
    os.environ["CATBOOST_TRAIN_DIR"] = base
    return base


catboost_train_dir = ensure_catboost_train_dir()


# ==============================================
# 固定 seed（讓回測/預測可重現）
# ==============================================
def set_global_seed(seed=42):
    random.seed(seed)
    np.random.seed(seed)
    os.environ["PYTHONHASHSEED"] = str(seed)


if USE_DETERMINISTIC:
    set_global_seed(GLOBAL_SEED)


# ==============================================
# GUI 控制：暫停/停止 + 狀態 + 進度(0~100)
# ==============================================
class RunControl:
    def __init__(self):
        # 事件
        self.pause_event = threading.Event()
        self.stop_event = threading.Event()
        self.pause_event.set()  # set = running

        # locks + 狀態
        self.status_lock = threading.Lock()
        self.status_text = "待命"

        # 進度
        self.progress_lock = threading.Lock()
        self.progress_value = 0.0

    # ✅ 防呆：若某些屬性因重複定義/覆蓋而不存在，自動補齊
    def _ensure_attrs(self):
        if not hasattr(self, "pause_event") or not isinstance(getattr(self, "pause_event", None), threading.Event):
            self.pause_event = threading.Event()
            self.pause_event.set()

        if not hasattr(self, "stop_event") or not isinstance(getattr(self, "stop_event", None), threading.Event):
            self.stop_event = threading.Event()

        if not hasattr(self, "status_lock"):
            self.status_lock = threading.Lock()
        if not hasattr(self, "status_text"):
            self.status_text = "待命"

        if not hasattr(self, "progress_lock"):
            self.progress_lock = threading.Lock()
        if not hasattr(self, "progress_value"):
            self.progress_value = 0.0

    def set_status(self, s: str):
        self._ensure_attrs()
        with self.status_lock:
            self.status_text = str(s)

    def get_status(self) -> str:
        self._ensure_attrs()
        with self.status_lock:
            return self.status_text

    def set_progress(self, v: float):
        self._ensure_attrs()
        v = 0.0 if v is None else float(v)
        if v < 0:
            v = 0.0
        if v > 100:
            v = 100.0
        with self.progress_lock:
            self.progress_value = v

    def get_progress(self) -> float:
        self._ensure_attrs()
        with self.progress_lock:
            return float(self.progress_value)

    def request_pause(self):
        self._ensure_attrs()
        self.pause_event.clear()

    def request_resume(self):
        self._ensure_attrs()
        self.pause_event.set()

    def request_stop(self):
        self._ensure_attrs()
        self.stop_event.set()
        self.pause_event.set()  # 解除卡住，讓程式能跳出

    def check_pause_stop(self):
        """在安全點呼叫：會阻塞暫停，停止則丟例外中斷"""
        self._ensure_attrs()
        if self.stop_event.is_set():
            raise KeyboardInterrupt("使用者停止")
        while not self.pause_event.is_set():
            if self.stop_event.is_set():
                raise KeyboardInterrupt("使用者停止")
            time.sleep(0.15)


# ==============================================
# GUI log：把 print 輸出導到 Text
# ==============================================
class QueueWriter:
    def __init__(self, q: queue.Queue):
        self.q = q

    def write(self, s: str):
        if s:
            self.q.put(s)

    def flush(self):
        pass


@contextlib.contextmanager
def redirect_output_to_queue(q: queue.Queue):
    old_out, old_err = sys.stdout, sys.stderr
    sys.stdout = QueueWriter(q)
    sys.stderr = QueueWriter(q)
    try:
        yield
    finally:
        sys.stdout = old_out
        sys.stderr = old_err


# ==============================================
# 下載/快取官方今彩539資料 + 清洗
# ==============================================
def load_tw539(force_download=False):
    DATA_CACHE = "tw539_latest.csv"
    DATA_URL = "https://biga.com.tw/HISTORYDATA/tw539.csv"

    if (not force_download) and os.path.exists(DATA_CACHE):
        df = None
        for enc in ("utf-8-sig", "utf-8", "cp950", "big5"):
            try:
                df = pd.read_csv(DATA_CACHE, encoding=enc)
                break
            except Exception:
                df = None
        if df is None:
            raise RuntimeError(f"快取檔 {DATA_CACHE} 讀取失敗：可能檔案已損毀或非文字編碼")

        if "日期" in df.columns:
            df["日期"] = pd.to_datetime(df["日期"], errors="coerce")
        return df

    last_err = None
    for _ in range(DOWNLOAD_RETRY):
        try:
            r = requests.get(DATA_URL, timeout=15)
            r.raise_for_status()
            csv_str = r.content.decode("utf-8-sig")
            df = pd.read_csv(StringIO(csv_str), header=None)
            df.columns = [
                "日期", "期數",
                "落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5",
                "",
                "正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"
            ]
            df["日期"] = pd.to_datetime(df["日期"], errors="coerce")

            num_cols = [
                "落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5",
                "正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"
            ]
            for c in num_cols:
                df[c] = pd.to_numeric(df[c], errors="coerce")

            df["期數"] = pd.to_numeric(df["期數"], errors="coerce")
            df = df.dropna(subset=["日期", "期數"] + num_cols).reset_index(drop=True)

            df["期數"] = df["期數"].astype(int)
            df[num_cols] = df[num_cols].astype(int)

            if df["日期"].iloc[0] > df["日期"].iloc[-1]:
                df = df.iloc[::-1].reset_index(drop=True)

            df = df.drop(columns=[""])
            df.to_csv(DATA_CACHE, index=False, encoding="utf-8-sig")
            return df
        except Exception as e:
            last_err = e
            time.sleep(1.0)

    raise RuntimeError(f"下載官方資料失敗：{last_err}")


# ==============================================
# 對獎：以「期數」優先（避免日期推算誤差）
# ==============================================
def try_save_latest_prediction_result(df, nums):
    pred_file = "latest_predict.csv"
    result_file = "latest_predict_result.csv"
    if not os.path.exists(pred_file):
        return

    pred_df = pd.read_csv(pred_file, dtype=str)
    df2 = df.copy()
    df2["日期"] = pd.to_datetime(df2["日期"], errors="coerce")

    if os.path.exists(result_file):
        result_df = pd.read_csv(result_file, dtype=str)
        recorded_keys = set(result_df.apply(lambda r: f"{r.get('預測期數','')}_{r.get('模型','')}", axis=1))
    else:
        result_df = pd.DataFrame()
        recorded_keys = set()

    new_records = []
    for _, row in pred_df.iterrows():
        model = str(row.get("模型", "")).strip()
        pred_issue = str(row.get("預測期數", "")).strip()
        pred_date = str(row.get("預測日期", "")).strip()
        pred_nums_str = str(row.get("預測號碼", "")).strip()

        key = f"{pred_issue}_{model}"
        if key in recorded_keys:
            continue
        if not pred_nums_str:
            continue

        pred_numbers = [int(n) for n in pred_nums_str.split(",") if str(n).strip().isdigit()]

        real_row = None
        if pred_issue.isdigit():
            real_row = df2[df2["期數"] == int(pred_issue)]
        if (real_row is None) or real_row.empty:
            if pred_date:
                real_row = df2[df2["日期"].dt.strftime("%Y-%m-%d") == pred_date]

        if real_row is None or real_row.empty:
            continue

        real_numbers = [int(n) for n in real_row.iloc[0][nums].values]
        real_date = real_row.iloc[0]["日期"].strftime("%Y-%m-%d")
        real_issue = int(real_row.iloc[0]["期數"])

        hit_set = sorted(set(pred_numbers) & set(real_numbers))
        new_records.append({
            "預測日期": pred_date if pred_date else "",
            "預測期數": str(pred_issue) if pred_issue else "",
            "實際開獎日期": real_date,
            "實際開獎期數": str(real_issue),
            "模型": model,
            "預測號碼": ",".join(f"{n:02d}" for n in sorted(pred_numbers)),
            "開獎號碼": ",".join(f"{n:02d}" for n in sorted(real_numbers)),
            "命中數": str(len(hit_set)),
            "命中號碼": ",".join(f"{n:02d}" for n in hit_set)
        })

    if new_records:
        df_new = pd.DataFrame(new_records)
        if os.path.exists(result_file):
            old = pd.read_csv(result_file, dtype=str)
            result_df = pd.concat([old, df_new], ignore_index=True)
        else:
            result_df = df_new

        result_df.to_csv(result_file, index=False, encoding="utf-8-sig")
        print(f"\n自動完成對獎結果存檔：{result_file}（本次新增 {len(df_new)} 筆）")


# ==============================================
# 特徵工程（一次建滿；後續切片）
# ==============================================
FEATURE_CACHE = {}


def feature_engineering(df, nums, features):
    cache_key = (df.index[0] if len(df) else -1, df.index[-1] if len(df) else -1)
    if cache_key in FEATURE_CACHE:
        return FEATURE_CACHE[cache_key].copy()

    X = df[features].copy()

    # --- 日期特徵 ---
    if "日期" in df.columns:
        X["weekday"] = df["日期"].dt.weekday.astype(np.int8)
        X["month"] = df["日期"].dt.month.astype(np.int8)
        X["is_weekend"] = (X["weekday"] >= 5).astype(np.int8)

    # --- 基本統計 ---
    X["max_num"] = df[nums].max(axis=1)
    X["min_num"] = df[nums].min(axis=1)
    X["sum_num"] = df[nums].sum(axis=1)
    X["mean_num"] = df[nums].mean(axis=1)
    X["std_num"] = df[nums].std(axis=1)
    X["range_num"] = X["max_num"] - X["min_num"]

    # --- 奇偶 ---
    X["odd_count"] = df[nums].apply(lambda r: sum(int(n) % 2 for n in r), axis=1).astype(np.int8)
    X["even_count"] = (5 - X["odd_count"]).astype(np.int8)
    X["odd_even_ratio"] = X["odd_count"] / (X["even_count"] + 1e-6)

    # --- 間距 ---
    X["num_gap"] = df[nums].apply(lambda r: np.mean(np.diff(sorted(r))), axis=1)

    # --- 連號 ---
    def count_serials(arr):
        s = sorted(arr)
        return sum((s[i + 1] - s[i]) == 1 for i in range(4))

    X["serial_count"] = df[nums].apply(count_serials, axis=1).astype(np.int8)

    # --- 與前一期重複數 ---
    def repeat_count(cur, prev):
        return len(set(cur) & set(prev))

    X["repeat_prev"] = [0] + [repeat_count(df.loc[i, nums], df.loc[i - 1, nums]) for i in range(1, len(df))]
    X["repeat_prev"] = pd.Series(X["repeat_prev"], dtype=np.int8)

    # --- 大小（539：小=01~19 / 大=20~38 / 和局=39）---
    X["small_count"] = df[nums].apply(lambda r: sum(1 <= int(n) <= 19 for n in r), axis=1).astype(np.int8)
    X["big_count"] = df[nums].apply(lambda r: sum(20 <= int(n) <= 38 for n in r), axis=1).astype(np.int8)
    X["draw39_count"] = df[nums].apply(lambda r: sum(int(n) == 39 for n in r), axis=1).astype(np.int8)
    X["big_small_score"] = (X["big_count"] - X["small_count"]).astype(np.int8)

    # --- 尾數/合數（每球）---
    for i in range(1, 6):
        X[f"num{i}_尾數"] = (df[f"正序號碼{i}"] % 10).astype(np.int8)
        X[f"num{i}_合數"] = ((df[f"正序號碼{i}"] // 10 + df[f"正序號碼{i}"] % 10) % 10).astype(np.int8)

    # --- 熱度（每個號碼 01~39）---
    hot_frames = []
    for n in range(1, 40):
        num_mask = (df[nums] == n).sum(axis=1).astype(np.int16)
        col_all = pd.DataFrame({f"hot_{n:02d}_all": num_mask.cumsum().astype(np.int32)})
        col_windows = pd.DataFrame({
            f"hot_{n:02d}_{w}": num_mask.rolling(w, min_periods=1).sum().astype(np.float32)
            for w in [5, 10, 20, 30]
        })
        hot_frames.append(pd.concat([col_all, col_windows], axis=1))
    X = pd.concat([X.reset_index(drop=True), pd.concat(hot_frames, axis=1).reset_index(drop=True)], axis=1)

    # --- 遺漏（miss）---
    miss_features = pd.DataFrame(index=df.index)
    last_pos = {n: -1 for n in range(1, 40)}
    miss_counts = {n: [] for n in range(1, 40)}
    for i in range(len(df)):
        cur_set = set(df.loc[i, nums])
        for n in range(1, 40):
            if n in cur_set:
                miss_counts[n].append(0)
                last_pos[n] = i
            else:
                miss_counts[n].append(i - last_pos[n] if last_pos[n] != -1 else i + 1)
    for n in range(1, 40):
        miss_features[f"miss_{n:02d}"] = pd.Series(miss_counts[n], dtype=np.int16)
    X = pd.concat([X.reset_index(drop=True), miss_features.reset_index(drop=True)], axis=1)

    # --- pair 共現頻率（均值/最大）---
    pair_mean_list = []
    pair_max_list = []
    pair_counts = defaultdict(int)

    for i in range(len(df)):
        row_nums = sorted(int(df.loc[i, col]) for col in nums)
        pair_scores = []
        for a in range(4):
            for b in range(a + 1, 5):
                p = (row_nums[a], row_nums[b])
                pair_scores.append(pair_counts[p])

        if pair_scores:
            pair_mean_list.append(float(np.mean(pair_scores)))
            pair_max_list.append(float(np.max(pair_scores)))
        else:
            pair_mean_list.append(0.0)
            pair_max_list.append(0.0)

        for a in range(4):
            for b in range(a + 1, 5):
                p = (row_nums[a], row_nums[b])
                pair_counts[p] += 1

    X["pair_cofreq_mean"] = pd.Series(pair_mean_list, index=df.index).astype(np.float32)
    X["pair_cofreq_max"] = pd.Series(pair_max_list, index=df.index).astype(np.float32)

    # --- 群組映射（八卦/生肖/均分群/五行/六沖/七政）---
    def apply_group_feats(df, nums, name, mapping, X):
        dummy_frames = []
        for i in range(1, 6):
            cat_col = df[f"正序號碼{i}"].map(mapping).astype("category")
            dummies = pd.get_dummies(cat_col, prefix=f"{name}_num{i}")
            dummy_frames.append(dummies)
        if dummy_frames:
            X = pd.concat([X.reset_index(drop=True), pd.concat(dummy_frames, axis=1).reset_index(drop=True)], axis=1)

        all_groups = sorted(set(mapping.values()))
        for k in all_groups:
            X[f"{name}_{k}_count"] = df[nums].apply(lambda row: sum(mapping.get(n, "") == k for n in row), axis=1)
        return X

    mean_group_map = {**{i: 'A' for i in range(1, 5)}, **{i: 'B' for i in range(5, 9)}, **{i: 'C' for i in range(9, 13)},
                      **{i: 'D' for i in range(13, 17)}, **{i: 'E' for i in range(17, 21)}, **{i: 'F' for i in range(21, 25)},
                      **{i: 'G' for i in range(25, 29)}, **{i: 'H' for i in range(29, 33)}, **{i: 'I' for i in range(33, 37)},
                      **{i: 'J' for i in range(37, 40)}}
    bagua_map = {1: '乾', 16: '乾', 17: '乾', 32: '乾', 8: '坤', 9: '坤', 24: '坤', 25: '坤', 6: '坎', 11: '坎', 22: '坎', 27: '坎',
                 3: '離', 14: '離', 19: '離', 30: '離', 38: '離', 5: '震', 12: '震', 21: '震', 28: '震', 36: '震', 4: '巽', 13: '巽', 20: '巽',
                 29: '巽', 37: '巽', 2: '艮', 15: '艮', 18: '艮', 31: '艮', 39: '艮', 7: '兌', 10: '兌', 23: '兌', 26: '兌', 34: '兌'}
    shengxiao_map = {11: '羊', 23: '羊', 35: '羊', 10: '猴', 22: '猴', 34: '猴', 9: '雞', 21: '雞', 33: '雞', 8: '狗', 20: '狗', 32: '狗',
                     7: '豬', 19: '豬', 31: '豬', 6: '鼠', 18: '鼠', 30: '鼠', 5: '牛', 17: '牛', 29: '牛', 4: '虎', 16: '虎', 28: '虎',
                     3: '兔', 15: '兔', 27: '兔', 39: '兔', 2: '龍', 14: '龍', 26: '龍', 38: '龍', 1: '蛇', 13: '蛇', 25: '蛇', 37: '蛇',
                     12: '馬', 24: '馬', 36: '馬'}
    wuxing_map = {13: '金', 14: '金', 21: '金', 22: '金', 29: '金', 30: '金', 1: '木', 2: '木', 9: '木', 10: '木', 17: '木', 18: '木', 31: '木',
                  32: '木', 39: '木', 3: '水', 4: '水', 11: '水', 12: '水', 25: '水', 26: '水', 33: '水', 34: '水', 7: '火', 8: '火', 15: '火',
                  16: '火', 23: '火', 24: '火', 37: '火', 38: '火', 5: '土', 6: '土', 19: '土', 20: '土', 27: '土', 28: '土', 35: '土', 36: '土'}
    liuchong_map = {1: '子午', 7: '子午', 13: '子午', 19: '子午', 25: '子午', 31: '子午', 37: '子午', 2: '丑未', 8: '丑未', 14: '丑未',
                    20: '丑未', 26: '丑未', 32: '丑未', 38: '丑未', 3: '寅申', 9: '寅申', 15: '寅申', 21: '寅申', 27: '寅申', 33: '寅申',
                    39: '寅申', 4: '卯酉', 10: '卯酉', 16: '卯酉', 22: '卯酉', 28: '卯酉', 34: '卯酉', 5: '辰戌', 11: '辰戌', 17: '辰戌',
                    23: '辰戌', 29: '辰戌', 35: '辰戌', 6: '巳亥', 12: '巳亥', 18: '巳亥', 24: '巳亥', 30: '巳亥', 36: '巳亥'}
    qizheng_map = {1: '日', 8: '日', 15: '日', 22: '日', 29: '日', 36: '日', 2: '月', 9: '月', 16: '月', 23: '月', 30: '月', 37: '月',
                   3: '火', 10: '火', 17: '火', 24: '火', 31: '火', 38: '火', 4: '水', 11: '水', 18: '水', 25: '水', 32: '水', 39: '水',
                   5: '木', 12: '木', 19: '木', 26: '木', 33: '木', 6: '金', 13: '金', 20: '金', 27: '金', 34: '金', 7: '土', 14: '土',
                   21: '土', 28: '土', 35: '土'}

    X = apply_group_feats(df, nums, "bagua", bagua_map, X)
    X = apply_group_feats(df, nums, "shengxiao", shengxiao_map, X)
    X = apply_group_feats(df, nums, "mean_group", mean_group_map, X)
    X = apply_group_feats(df, nums, "wuxing", wuxing_map, X)
    X = apply_group_feats(df, nums, "liuchong", liuchong_map, X)
    X = apply_group_feats(df, nums, "qizheng", qizheng_map, X)

    # --- dtype 收斂 ---
    for col in X.select_dtypes(include=["float64"]).columns:
        X[col] = X[col].astype(np.float32)
    for col in X.select_dtypes(include=["int64"]).columns:
        X[col] = X[col].astype(np.int32)

    FEATURE_CACHE[cache_key] = X.copy()
    return X


def build_full_features_once(df):
    nums = ["正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"]
    features = nums + ["落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5"]
    X_full = feature_engineering(df, nums, features)
    base_columns = list(X_full.columns)
    return X_full, base_columns, nums, features


def fix_columns(df, columns):
    return df.reindex(columns=columns, fill_value=0)


# ==============================================
# 彩金盈虧計算
# ==============================================
def calc_prize(hits_list, top_n):
    JACKPOTS = {
        "2星": {"cost": 10, "prize": 72},
        "3星": {"cost": 1, "prize": 883},
        "4星": {"cost": 1, "prize": 15300},
    }
    total = {k: {'win': 0, 'bets': 0, 'cost': 0, 'prize': 0} for k in JACKPOTS}
    for hit in hits_list:
        comb2 = comb(hit, 2) if hit >= 2 else 0
        total['2星']['win'] += comb2
        total['2星']['bets'] += comb(top_n, 2)

        comb3 = comb(hit, 3) if hit >= 3 else 0
        total['3星']['win'] += comb3
        total['3星']['bets'] += comb(top_n, 3)

        comb4 = comb(hit, 4) if hit >= 4 else 0
        total['4星']['win'] += comb4
        total['4星']['bets'] += comb(top_n, 4)

    for k in JACKPOTS:
        total[k]['cost'] = total[k]['bets'] * JACKPOTS[k]['cost']
        total[k]['prize'] = total[k]['win'] * JACKPOTS[k]['cost'] * JACKPOTS[k]['prize']
        total[k]['profit'] = total[k]['prize'] - total[k]['cost']
    return total


# ==============================================
# 錯題本：只讀「真實預測對獎」結果（避免回測污染）
# ==============================================
def load_penalty_from_real_results(result_file="latest_predict_result.csv"):
    penalty = np.zeros(39, dtype=np.float32)
    if not os.path.exists(result_file):
        return penalty

    try:
        df = pd.read_csv(result_file, dtype=str)
    except Exception:
        return penalty

    for _, r in df.iterrows():
        pred = str(r.get("預測號碼", "")).strip()
        ans = str(r.get("開獎號碼", "")).strip()
        hit_s = str(r.get("命中數", "")).strip()

        if not pred or not ans:
            continue

        try:
            pred_nums = [int(x) for x in pred.split(",") if x.strip().isdigit()]
            ans_nums = [int(x) for x in ans.split(",") if x.strip().isdigit()]
            hit = int(hit_s) if hit_s.isdigit() else len(set(pred_nums) & set(ans_nums))
        except Exception:
            continue

        if hit >= 2:
            continue

        w = 3.0 if hit == 0 else 2.0
        miss_nums = sorted(set(pred_nums) - set(ans_nums))
        for m in miss_nums:
            if 1 <= m <= 39:
                penalty[m - 1] += w

    return penalty


# ==============================================
# 多模型：XGB / LGBM / CatBoost / Logistic / RF（MultiOutput） + CRF
# ==============================================
def _seed(seed_offset=0):
    if USE_DETERMINISTIC:
        return int((GLOBAL_SEED + seed_offset) % (2**32 - 1))
    raw = int(time.time_ns()) + random.randint(0, 1_000_000)
    return int(raw % (2**32 - 1))


def make_base_estimator(model_name, seed_offset=0):
    n_cpu = max(1, multiprocessing.cpu_count() - 1)

    if model_name == "XGBoost":
        params_fast = dict(n_estimators=60, max_depth=3, learning_rate=0.12, subsample=0.8, colsample_bytree=0.8)
        params_full = dict(n_estimators=160, max_depth=4, learning_rate=0.10, subsample=0.9, colsample_bytree=0.9)
        params = params_fast if FAST_MODE else params_full
        return XGBClassifier(
            tree_method="hist",
            use_label_encoder=False,
            eval_metric="logloss",
            n_jobs=n_cpu,
            verbosity=0,
            random_state=_seed(seed_offset),
            **params
        )

    if model_name == "LightGBM":
        params_fast = dict(n_estimators=120, num_leaves=31, learning_rate=0.08, subsample=0.9, colsample_bytree=0.9)
        params_full = dict(n_estimators=300, num_leaves=63, learning_rate=0.06, subsample=0.9, colsample_bytree=0.9)
        params = params_fast if FAST_MODE else params_full
        return LGBMClassifier(
            **params,
            n_jobs=n_cpu,
            random_state=_seed(seed_offset),
            verbose=-1
        )

    if model_name == "CatBoost":
        params_fast = dict(iterations=120, depth=4, learning_rate=0.12)
        params_full = dict(iterations=500, depth=5, learning_rate=0.10)
        params = params_fast if FAST_MODE else params_full

        run_dir = os.path.join(catboost_train_dir, f"run_{os.getpid()}_{int(time.time() * 1000)}")
        os.makedirs(run_dir, exist_ok=True)

        return CatBoostSklearnCompat(
            task_type="CPU",
            thread_count=n_cpu,
            verbose=0,
            train_dir=run_dir,
            allow_writing_files=True,
            random_seed=_seed(seed_offset),
            **params
        )

    if model_name == "Logistic":
        max_iter = 3000 if FAST_MODE else 8000
        tol = 1e-3 if FAST_MODE else 5e-4
        base_lr = LogisticRegression(
            C=1.0,
            max_iter=max_iter,
            tol=tol,
            solver="saga",
            penalty="l2",
            n_jobs=1
        )
        return Pipeline([
            ("scaler", StandardScaler()),
            ("clf", base_lr)
        ])

    if model_name == "RandomForest":
        params_fast = dict(n_estimators=80, max_depth=7)
        params_full = dict(n_estimators=200, max_depth=None)
        params = params_fast if FAST_MODE else params_full
        return RandomForestClassifier(
            **params,
            n_jobs=n_cpu,
            random_state=_seed(seed_offset)
        )

    raise ValueError("Unknown model")


def make_multi_model(model_name, seed_offset=0):
    base = make_base_estimator(model_name, seed_offset=seed_offset)
    return MultiOutputClassifier(base, n_jobs=1)


def proba_from_multioutput(mo_clf, X_pred_row):
    probas = []
    for est in mo_clf.estimators_:
        p = est.predict_proba(X_pred_row)
        if p.shape[1] == 2:
            probas.append(float(p[0, 1]))
        else:
            probas.append(float(p[0, 0]))
    return np.array(probas, dtype=np.float32)


# ==============================================
# CRF：每期一條序列（1~39）做序列預測
# ==============================================
def crf_token_features_from_row(row, n):
    fmt = f"{n:02d}"
    feat = {
        "n": n,
        "n_mod10": n % 10,
        "n_bin": n // 10,
        "hot_all": float(row.get(f"hot_{fmt}_all", 0.0)),
        "hot_5": float(row.get(f"hot_{fmt}_5", 0.0)),
        "hot_10": float(row.get(f"hot_{fmt}_10", 0.0)),
        "hot_20": float(row.get(f"hot_{fmt}_20", 0.0)),
        "hot_30": float(row.get(f"hot_{fmt}_30", 0.0)),
        "miss": float(row.get(f"miss_{fmt}", 0.0)),
        "odd_cnt": int(row.get("odd_count", 0)),
        "even_cnt": int(row.get("even_count", 0)),
        "serial_cnt": int(row.get("serial_count", 0)),
        "repeat_prev": int(row.get("repeat_prev", 0)),
        "big_small": float(row.get("big_small_score", 0.0)),
    }
    return feat


def build_crf_seq_features(X_bt, idx):
    row = X_bt.iloc[idx]
    return [crf_token_features_from_row(row, n) for n in range(1, 40)]


def build_crf_labels(y_all, idx):
    row = y_all.iloc[idx]
    return ['1' if int(row[f"y_{n:02d}"]) == 1 else '0' for n in range(1, 40)]


def fit_crf(X_bt, y_all, start_idx, end_idx, seed_offset=0):
    X_seqs = [build_crf_seq_features(X_bt, t) for t in range(start_idx, end_idx)]
    y_seqs = [build_crf_labels(y_all, t) for t in range(start_idx, end_idx)]
    max_iter = 60 if FAST_MODE else 150
    crf = sklearn_crfsuite.CRF(
        algorithm='lbfgs',
        c1=0.1, c2=0.1,
        max_iterations=max_iter,
        all_possible_transitions=True
    )
    with suppress_all_output(True):
        crf.fit(X_seqs, y_seqs)
    return crf


def crf_predict_proba(crf, X_bt, idx):
    feats = build_crf_seq_features(X_bt, idx)
    marginals = crf.predict_marginals_single(feats)
    probs = [float(m.get('1', 0.0)) for m in marginals]
    return np.array(probs, dtype=np.float32)


# ==============================================
# 版路拖牌：保留你原本功能（完整）
# ==============================================
def _build_rows_for_mode(df_bt_use, nums, mode):
    if mode == "size":
        seqs = []
        for _, row in df_bt_use.iterrows():
            arr = sorted(int(row[c]) for c in nums)
            seqs.append(arr)
        return seqs
    elif mode == "order":
        cols = [f"落序號碼{i}" for i in range(1, 6)]
        seqs = df_bt_use[cols].astype(int).values.tolist()
        return seqs
    else:
        raise ValueError("mode must be 'size' or 'order'")


def _analyze_pattern_unpos_next(seqs, dates, A, B, lag, last_base_idx):
    N = len(seqs)
    if N <= lag or last_base_idx < 0 or last_base_idx >= N:
        return None
    if A not in set(seqs[last_base_idx]):
        return None

    events = []
    for base_idx in range(0, N - lag):
        if A not in set(seqs[base_idx]):
            continue
        drag_idx = base_idx + lag
        is_success = (B in set(seqs[drag_idx]))
        events.append((base_idx, drag_idx, is_success))

    if not events:
        return None

    success_count = sum(1 for e in events if e[2])
    fail_count = len(events) - success_count
    if success_count < MIN_CHAIN_RUN:
        return None

    valid_events = [e for e in events if e[0] < last_base_idx]
    if not valid_events:
        return None

    valid_events.sort(key=lambda x: x[0], reverse=True)

    chain_run = 0
    tail_events = []
    for base_idx, drag_idx, is_success in valid_events:
        tail_events.append((base_idx, drag_idx, is_success))
        if is_success:
            chain_run += 1
        else:
            break

    if chain_run < MIN_CHAIN_RUN:
        return None

    total_events = success_count + fail_count
    success_rate = success_count / total_events if total_events > 0 else 0.0

    last_success_drag_date = None
    for base_idx, drag_idx, is_success in valid_events:
        if is_success:
            last_success_drag_date = dates[drag_idx]
            break

    return {
        "A": A,
        "B": B,
        "lag": lag,
        "chain_run": chain_run,
        "last_base_date": dates[last_base_idx],
        "last_success_drag_date": last_success_drag_date,
        "success_count": success_count,
        "fail_count": fail_count,
        "success_rate": success_rate,
        "tail_events": tail_events[:50],
        "predict_target": "NEXT"
    }


def _analyze_pattern_pos_next(seqs, dates, A, B, lag, pos_a, pos_b, last_base_idx):
    N = len(seqs)
    if N <= lag or last_base_idx < 0 or last_base_idx >= N:
        return None
    if seqs[last_base_idx][pos_a] != A:
        return None

    events = []
    for base_idx in range(0, N - lag):
        if seqs[base_idx][pos_a] != A:
            continue
        drag_idx = base_idx + lag
        is_success = (seqs[drag_idx][pos_b] == B)
        events.append((base_idx, drag_idx, is_success))

    if not events:
        return None

    success_count = sum(1 for e in events if e[2])
    fail_count = len(events) - success_count
    if success_count < MIN_CHAIN_RUN:
        return None

    valid_events = [e for e in events if e[0] < last_base_idx]
    if not valid_events:
        return None

    valid_events.sort(key=lambda x: x[0], reverse=True)

    chain_run = 0
    tail_events = []
    for base_idx, drag_idx, is_success in valid_events:
        tail_events.append((base_idx, drag_idx, is_success))
        if is_success:
            chain_run += 1
        else:
            break

    if chain_run < MIN_CHAIN_RUN:
        return None

    total_events = success_count + fail_count
    success_rate = success_count / total_events if total_events > 0 else 0.0

    last_success_drag_date = None
    for base_idx, drag_idx, is_success in valid_events:
        if is_success:
            last_success_drag_date = dates[drag_idx]
            break

    return {
        "A": A,
        "B": B,
        "lag": lag,
        "pos_a": pos_a,
        "pos_b": pos_b,
        "chain_run": chain_run,
        "last_base_date": dates[last_base_idx],
        "last_success_drag_date": last_success_drag_date,
        "success_count": success_count,
        "fail_count": fail_count,
        "success_rate": success_rate,
        "tail_events": tail_events[:50],
        "predict_target": "NEXT"
    }


def _format_unpos_block_next(label, res, dates):
    A = res["A"]; B = res["B"]; lag = res["lag"]
    chain_run = res["chain_run"]
    base_date = res["last_base_date"]
    last_success_drag_date = res["last_success_drag_date"]
    sc = res["success_count"]; fc = res["fail_count"]
    total = sc + fc
    rate = sc / total if total > 0 else 0.0

    lines = []
    lines.append(label)
    lines.append(f"【預測目標】以最新開獎日 {base_date} 為起點 → 預測隔 {lag} 期可能拖出")
    lines.append(f"起始牌(A)：{A:02d}")
    lines.append(f"拖牌(B)：{B:02d}")
    lines.append("")
    lines.append("--- 近期連版（由近到遠，最後一次為可驗證歷史）---")

    tail = res["tail_events"]
    for base_idx, drag_idx, is_success in tail:
        base_d = dates[base_idx]
        drag_d = dates[drag_idx]
        mark = "✔" if is_success else "✖"
        extra = "   ← 斷點" if (not is_success) else ""
        lines.append(
            f"{base_d} 出現A {A:02d} → {drag_d} "
            f"{'出現' if is_success else '未出現'}B {B:02d} {mark}{extra}"
        )

    lines.append("")
    lines.append(f"近期連版：{chain_run} 次（最近連續 {chain_run} 次 A 出現後，隔 {lag} 期都有出 B）")
    if last_success_drag_date is not None:
        lines.append(f"最近一次成功拖出日期：{last_success_drag_date}")
    lines.append(f"成功紀錄共：{sc} 次")
    lines.append(f"失敗紀錄共：{fc} 次")
    lines.append(f"成功率：{sc} / {total} = {rate * 100:.1f}%")
    lines.append("--------------------------------")
    return "\n".join(lines)


def _format_pos_block_next(label, res, dates):
    A = res["A"]; B = res["B"]; lag = res["lag"]
    chain_run = res["chain_run"]
    base_date = res["last_base_date"]
    last_success_drag_date = res["last_success_drag_date"]
    sc = res["success_count"]; fc = res["fail_count"]
    total = sc + fc
    rate = sc / total if total > 0 else 0.0
    pos_a = res["pos_a"] + 1
    pos_b = res["pos_b"] + 1

    lines = []
    lines.append(label)
    lines.append(f"【預測目標】以最新開獎日 {base_date} 為起點 → 預測隔 {lag} 期可能拖出")
    lines.append(f"起始牌(A)：{A:02d}")
    lines.append(f"拖牌(B)：{B:02d}")
    lines.append(f"定位：起牌第 {pos_a} 球 → 拖牌第 {pos_b} 球")
    lines.append("")
    lines.append("--- 近期連版（由近到遠）---")

    tail = res["tail_events"]
    for base_idx, drag_idx, is_success in tail:
        base_d = dates[base_idx]
        drag_d = dates[drag_idx]
        mark = "✔" if is_success else "✖"
        extra = "   ← 斷點" if (not is_success) else ""
        lines.append(
            f"{base_d} (第{pos_a}球)=A {A:02d} → {drag_d} "
            f"{'出現' if is_success else '未出現'}(第{pos_b}球)=B {B:02d} {mark}{extra}"
        )

    lines.append("")
    lines.append(f"近期連版：{chain_run} 次")
    if last_success_drag_date is not None:
        lines.append(f"最近一次成功拖出日期：{last_success_drag_date}")
    lines.append(f"成功紀錄共：{sc} 次")
    lines.append(f"失敗紀錄共：{fc} 次")
    lines.append(f"成功率：{sc} / {total} = {rate * 100:.1f}%")
    lines.append("--------------------------------")
    return "\n".join(lines)


# ✅ 保留單一版本（避免重複定義覆蓋）
def analyze_drag_layers(drag_results):
    """
    drag_results: list[dict]，每個 dict 至少包含:
      - "B": 拖牌號碼
      - "chain_run": 近期連版次數（>=2 才有被收錄）
      - "success_count": 成功次數
      - "fail_count": 失敗次數

    回傳:
      - layer2_txt: 連2版號碼字串
      - layer3_txt: 連>=3版號碼字串
      - prob_rank:  [(num, hit, prob), ...] 依機率排序（機率 = 成功 / (成功+失敗)）
      - mark_level: dict[num] = 2 or 3  (用於符號標示)
    """
    if not drag_results:
        return "", "", [], {}

    best_chain = {}   # num -> max(chain_run)
    prob_stats = {}   # num -> (success, total)

    for r in drag_results:
        try:
            b = int(r.get("B", 0))
            chain = int(r.get("chain_run", 0))
            sc = int(r.get("success_count", 0))
            fc = int(r.get("fail_count", 0))
            total = sc + fc
            if b <= 0:
                continue
        except Exception:
            continue

        best_chain[b] = max(best_chain.get(b, 0), chain)

        old_sc, old_total = prob_stats.get(b, (0, 0))
        prob_stats[b] = (old_sc + sc, old_total + total)

    layer2 = sorted([n for n, c in best_chain.items() if c == 2])
    layer3 = sorted([n for n, c in best_chain.items() if c >= 3])

    layer2_txt = "[" + ", ".join(f"{n:02d}" for n in layer2) + "]" if layer2 else ""
    layer3_txt = "[" + ", ".join(f"{n:02d}" for n in layer3) + "]" if layer3 else ""

    prob_rank = []
    for n, (sc, total) in prob_stats.items():
        if total <= 0:
            continue
        prob = sc / total
        prob_rank.append((n, sc, prob))
    prob_rank.sort(key=lambda x: (x[2], x[1], x[0]), reverse=True)

    mark_level = {}
    for n, c in best_chain.items():
        if c >= 3:
            mark_level[n] = 3
        elif c == 2:
            mark_level[n] = 2

    return layer2_txt, layer3_txt, prob_rank, mark_level


# ✅ 修改：compute_drag_notebooks() 回傳拖牌結果清單（提供 analyze_drag_layers 用）
def compute_drag_notebooks(df_bt, nums, predict_lags=1):
    if not DRAG_ENABLE:
        msg = "（未啟用版路拖牌功能 DRAG_ENABLE=False）\n"
        return msg, msg, msg, msg, set(), []

    def _ensure_not_empty(txt, title, lag_list):
        if txt is None or str(txt).strip() == "":
            return (
                f"{title}\n"
                f"搜尋不到拖牌資訊（條件過嚴或樣本不足）。\n"
                f"（目前設定：預測隔 {lag_list} 期、MIN_CHAIN_RUN={MIN_CHAIN_RUN}）\n"
            )
        return txt

    try:
        if DRAG_MAX_ROWS is not None and len(df_bt) > DRAG_MAX_ROWS:
            df_bt_use = df_bt.tail(DRAG_MAX_ROWS).reset_index(drop=True)
        else:
            df_bt_use = df_bt.copy().reset_index(drop=True)

        if len(df_bt_use) < 2:
            msg = "資料不足，無法計算拖牌（至少需要 2 期以上）。\n"
            return msg, msg, msg, msg, set(), []

        dates = df_bt_use["日期"].dt.date.tolist()
        last_base_idx = len(dates) - 1
        last_base_date = dates[last_base_idx]

        if isinstance(predict_lags, (list, tuple, set, np.ndarray)):
            lag_list = sorted({int(x) for x in predict_lags if str(x).strip().isdigit() and int(x) >= 1})
        else:
            lag_list = [int(predict_lags)]
        if not lag_list:
            lag_list = [1]

        print(f"\n==== 開始計算版路拖牌（以最新開獎日為起點：{last_base_date}，預測隔 {lag_list} 期）====")
        t0 = time.time()

        size_seqs = _build_rows_for_mode(df_bt_use, nums, mode="size")
        order_seqs = _build_rows_for_mode(df_bt_use, nums, mode="order")

        drag_nums_size_unpos = set()
        drag_nums_size_pos = set()
        drag_nums_order_unpos = set()
        drag_nums_order_pos = set()

        drag_result_all = []  # ✅ 保留（不刪）
        drag_result = []      # ✅ 最終回傳（給 analyze_drag_layers）

        # ✅ 必須先定義，後面才能呼叫（修正 NameError）
        def _append_drag_results(results_list, src_name):
            for r in results_list:
                try:
                    drag_result.append({
                        "B": int(r.get("B")),
                        "chain_run": int(r.get("chain_run", 0)),
                        "lag": int(r.get("lag", 0)),
                        "src": str(src_name),
                        "success_count": int(r.get("success_count", 0)),
                        "fail_count": int(r.get("fail_count", 0)),
                    })
                except Exception:
                    continue

        def build_unpos_notebook_next(seqs, label_header, collect_set):
            results = []
            base_row = seqs[last_base_idx]
            base_set = set(base_row)

            for lag in lag_list:
                for A in sorted(base_set):
                    for B in range(1, 40):
                        res = _analyze_pattern_unpos_next(seqs, dates, A, B, lag, last_base_idx)
                        if res is not None:
                            results.append(res)
                            collect_set.add(B)

            results.sort(key=lambda r: (r["lag"], -r["chain_run"], -r["success_rate"], r["A"], r["B"]))
            blocks = []
            for r in results:
                blocks.append(_format_unpos_block_next(label_header, r, dates))
            return "\n\n".join(blocks), results

        def build_pos_notebook_next(seqs, label_header, collect_set):
            results = []
            base_row = seqs[last_base_idx]

            for lag in lag_list:
                for pos_a, A in enumerate(base_row):
                    for pos_b in range(5):
                        for B in range(1, 40):
                            res = _analyze_pattern_pos_next(seqs, dates, A, B, lag, pos_a, pos_b, last_base_idx)
                            if res is not None:
                                results.append(res)
                                collect_set.add(B)

            results.sort(key=lambda r: (r["lag"], -r["chain_run"], -r["success_rate"], r["A"], r["B"]))
            blocks = []
            for r in results:
                blocks.append(_format_pos_block_next(label_header, r, dates))
            return "\n\n".join(blocks), results

        # ✅ 修正：build_* 只回 (txt, results) 兩個值
        txt_size_unpos, res_size_unpos = build_unpos_notebook_next(size_seqs, "【大小序 / 不定位】", drag_nums_size_unpos)
        txt_size_pos,   res_size_pos   = build_pos_notebook_next(size_seqs, "【大小序 / 定位】",   drag_nums_size_pos)
        txt_order_unpos, res_order_unpos = build_unpos_notebook_next(order_seqs, "【落球序 / 不定位】", drag_nums_order_unpos)
        txt_order_pos,  res_order_pos  = build_pos_notebook_next(order_seqs, "【落球序 / 定位】",   drag_nums_order_pos)

        # ✅ 收集拖牌結果（提供 analyze_drag_layers）
        _append_drag_results(res_size_unpos,  "size_unpos")
        _append_drag_results(res_size_pos,    "size_pos")
        _append_drag_results(res_order_unpos, "order_unpos")
        _append_drag_results(res_order_pos,   "order_pos")

        # ✅ 保留 drag_result_all（不刪功能）
        drag_result_all.extend(res_size_unpos)
        drag_result_all.extend(res_size_pos)
        drag_result_all.extend(res_order_unpos)
        drag_result_all.extend(res_order_pos)

        txt_size_unpos = _ensure_not_empty(txt_size_unpos, "【大小序 / 不定位】", lag_list)
        txt_size_pos   = _ensure_not_empty(txt_size_pos,   "【大小序 / 定位】",   lag_list)
        txt_order_unpos = _ensure_not_empty(txt_order_unpos, "【落球序 / 不定位】", lag_list)
        txt_order_pos  = _ensure_not_empty(txt_order_pos,  "【落球序 / 定位】",   lag_list)

        drag_hint_nums_all = (drag_nums_size_unpos | drag_nums_size_pos | drag_nums_order_unpos | drag_nums_order_pos)

        t1 = time.time()
        print(f"版路拖牌計算完成，耗時約 {t1 - t0:.2f} 秒。")
        return txt_size_unpos, txt_size_pos, txt_order_unpos, txt_order_pos, drag_hint_nums_all, drag_result

    except Exception as e:
        err = f"版路拖牌計算發生例外：{type(e).__name__}: {e}\n"
        msg = "搜尋不到拖牌資訊（執行時發生例外）。\n" + err
        return msg, msg, msg, msg, set(), []


# ==============================================
# 推估下一次開獎日（539：固定週一~週六）+ 官方公告校正
# ==============================================
def _parse_dates_from_text(text):
    if not text:
        return set()

    found = set()

    for m in re.findall(r"(20\d{2})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})", text):
        y, mo, d = int(m[0]), int(m[1]), int(m[2])
        try:
            found.add(datetime(y, mo, d).date())
        except Exception:
            pass

    for m in re.findall(r"(\d{2,3})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})", text):
        yy, mo, d = int(m[0]), int(m[1]), int(m[2])
        if 1 <= yy <= 199:
            y = yy + 1911
            try:
                found.add(datetime(y, mo, d).date())
            except Exception:
                pass

    return found


def _fetch_text(url, timeout=15):
    try:
        r = requests.get(url, timeout=timeout, headers={"User-Agent": "Mozilla/5.0"})
        r.raise_for_status()
        r.encoding = r.apparent_encoding or "utf-8"
        return r.text
    except Exception:
        return ""


def fetch_twlottery_announcement_dates_539(lookahead_days=45):
    candidate_urls = [
        "https://www.taiwanlottery.com.tw/",
        "https://www.taiwanlottery.com.tw/Upload/",
        "https://www.taiwanlottery.com.tw/lotto/Lotto539/history.aspx",
        "https://www.taiwanlottery.com.tw/News/News.aspx",
        "https://www.taiwanlottery.com.tw/News/NewsList.aspx",
    ]

    all_dates = set()
    for url in candidate_urls:
        html = _fetch_text(url)
        if not html:
            continue
        all_dates |= _parse_dates_from_text(html)

    today = datetime.now().date()
    upper = today + timedelta(days=int(lookahead_days))
    all_dates = {d for d in all_dates if today <= d <= upper}
    all_dates = {d for d in all_dates if d.weekday() != 6}  # 排除週日
    return all_dates


def infer_next_draw_date_tw539_with_announcement(past_dates):
    now_dt = datetime.now()
    now_date = now_dt.date()

    base = now_date if (not past_dates) else past_dates[-1]
    s = set(past_dates) if past_dates else set()

    cand = base + timedelta(days=1)
    for _ in range(60):
        if cand.weekday() != 6 and cand not in s:
            break
        cand += timedelta(days=1)

    announced = set()
    try:
        announced = fetch_twlottery_announcement_dates_539(lookahead_days=60)
    except Exception:
        announced = set()

    candidates = set([cand]) | set(announced)
    future_candidates = sorted([d for d in candidates if d > now_date])

    if future_candidates:
        return future_candidates[0]

    return cand


# ==============================================
# Walk-forward：統一訓練/預測封裝
# ==============================================
def fit_model_for_i(model_name, X_bt, y_all, base_columns, start_idx, i, seed_offset=0):
    if model_name == "CRF":
        return fit_crf(X_bt, y_all, start_idx, i, seed_offset=seed_offset)

    y_cols = [f"y_{k:02d}" for k in range(1, 40)]
    X_train = fix_columns(X_bt.iloc[start_idx:i], base_columns)
    y_train = y_all[y_cols].iloc[start_idx:i]

    mo = make_multi_model(model_name, seed_offset=seed_offset)
    with suppress_all_output(True):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            mo.fit(X_train, y_train)
    return mo


def predict_scores_for_i(model_name, model_obj, X_bt, base_columns, i):
    if model_name == "CRF":
        with suppress_all_output(True):
            return crf_predict_proba(model_obj, X_bt, i)

    X_pred = fix_columns(X_bt.iloc[[i]], base_columns)
    with suppress_all_output(True):
        return proba_from_multioutput(model_obj, X_pred)


# ==============================================
# 核心流程：可被 GUI 呼叫（含 暫停/停止 檢查點）
# ✅ 進度條：只做「大段節點」更新，避免拖慢速度
# ==============================================
def run_pipeline(backtest_N: int, BACKTEST_TOP_N: int, PRED_TOP_N: int, control: RunControl):
    warnings.simplefilter(action='ignore', category=FutureWarning)
    warnings.simplefilter(action='ignore', category=pd.errors.SettingWithCopyWarning)

    n_cpu_all = multiprocessing.cpu_count()
    print(f"本機核心數：{n_cpu_all} 核心")

    if BACKTEST_TOP_N <= 0 or BACKTEST_TOP_N > 39 or PRED_TOP_N <= 0 or PRED_TOP_N > 39:
        raise ValueError("TOP_N 數量需介於 1 ~ 39 之間。")

    # 0~12：下載/對獎
    control.set_status("下載/載入官方資料")
    control.set_progress(2)
    control.check_pause_stop()
    print("下載/載入官方資料...")
    df = load_tw539(force_download=True)
    control.set_progress(10)

    nums = ["正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"]

    def pretty_print_row(row, title=""):
        print(f"{Fore.LIGHTYELLOW_EX}==== {title} ===={Style.RESET_ALL}")
        print(f"{Fore.LIGHTCYAN_EX}日期        {row['日期'].strftime('%Y-%m-%d')}{Style.RESET_ALL}")
        print(f"{Fore.LIGHTCYAN_EX}期數        {int(row['期數'])}{Style.RESET_ALL}")
        print(f"{Fore.LIGHTWHITE_EX}落序號碼1~5  ", end="")
        for i in range(1, 6):
            print(f"{int(row[f'落序號碼{i}']):02d} ", end="")
        print(Style.RESET_ALL)
        print(f"{Fore.LIGHTWHITE_EX}正序號碼1~5  ", end="")
        for i in range(1, 6):
            print(f"{int(row[f'正序號碼{i}']):02d} ", end="")
        print(Style.RESET_ALL)
        print()

    pretty_print_row(df.iloc[0], "第一筆資料")
    pretty_print_row(df.iloc[-1], "最後一筆資料")
    print(f"{Fore.LIGHTGREEN_EX}==== 全部期數：{len(df)} 筆 ===={Style.RESET_ALL}\n")

    control.set_status("自動對獎（若有 latest_predict.csv）")
    control.set_progress(12)
    control.check_pause_stop()
    try_save_latest_prediction_result(df, nums)

    # 12~30：建特徵
    control.set_status("建特徵（一次建滿）")
    control.set_progress(15)
    control.check_pause_stop()
    X_full, base_columns, _, _ = build_full_features_once(df)
    control.set_progress(30)

    X_bt = X_full.reset_index(drop=True)
    df_bt = df.reset_index(drop=True)

    future_open = df[nums].shift(-1)
    y_all = pd.DataFrame({
        f"y_{i:02d}": future_open.apply(lambda x, i=i: int(i in x.values), axis=1).astype(np.int8)
        for i in range(1, 40)
    }).reset_index(drop=True)

    num_rows = X_bt.shape[0]
    feature_row_count = num_rows - 1

    if feature_row_count < backtest_N or backtest_N <= 0:
        raise ValueError(f"【錯誤】可回測期數 ({feature_row_count}) 必須大於回測期數 ({backtest_N})！")

    backtest_indexes = list(range(feature_row_count - backtest_N, feature_row_count))

    backtest_eval_start_date = df_bt.iloc[backtest_indexes[0] + 1]["日期"].date()
    backtest_eval_end_date = df_bt.iloc[backtest_indexes[-1] + 1]["日期"].date()
    print(f"==== 回測評估日期（實際被預測的開獎日）: {backtest_eval_start_date} ~ {backtest_eval_end_date} ====")

    latest_issue = int(df_bt.iloc[-1]["期數"])
    predict_next_issue = latest_issue + 1
    predict_next_date = infer_next_draw_date_tw539_with_announcement(df_bt["日期"].dt.date.tolist())

    print(f"==== 預測下一期（期數優先）：期數 {predict_next_issue} / 日期（估計）{predict_next_date} ====")
    print(f"==== Walk-forward 回測：每 {WALK_FORWARD_RETRAIN_INTERVAL} 期重訓一次（K={WALK_FORWARD_RETRAIN_INTERVAL}） ====")

    # 30~40：拖牌
    control.set_status("計算版路拖牌")
    control.set_progress(33)
    control.check_pause_stop()

    drag_result = []  # ✅ 確保一定存在（避免 NameError）
    drag_hint_nums_all = set()
    mark_level = {}   # ✅ 確保一定存在（避免 NameError）

    if DRAG_ENABLE:
        txt_size_unpos, txt_size_pos, txt_order_unpos, txt_order_pos, drag_hint_nums_all, drag_result = compute_drag_notebooks(
            df_bt, nums, predict_lags=DRAG_PREDICT_LAGS
        )
        files_and_txt = [
            ("版路拖牌_順球_未定位.txt", txt_size_unpos),
            ("版路拖牌_順球_定位.txt", txt_size_pos),
            ("版路拖牌_落球_未定位.txt", txt_order_unpos),
            ("版路拖牌_落球_定位.txt", txt_order_pos),
        ]
        for fname, content in files_and_txt:
            with open(fname, "w", encoding="utf-8-sig") as f:
                f.write(content)

        print(
            "版路拖牌筆記本已輸出為："
            "版路拖牌_順球_未定位.txt / "
            "版路拖牌_順球_定位.txt / "
            "版路拖牌_落球_未定位.txt / "
            "版路拖牌_落球_定位.txt"
        )

        if drag_hint_nums_all:
            print(
                "\n📌 版路拖牌總覽（所有有出現拖牌的號碼，僅供參考）： "
                "[" + ", ".join(f"{n:02d}" for n in sorted(drag_hint_nums_all)) + "]"
            )

            layer2, layer3, prob_rank, mark_level = analyze_drag_layers(drag_result)

            print("\n🎯 連 2 版拖牌號碼：")
            print(layer2 if layer2 else "（無）")

            print("\n🔥 連 ≥3 版拖牌號碼（強勢）：")
            print(layer3 if layer3 else "（無）")

            print("\n📊 拖牌版路機率（高 → 低）：")
            if prob_rank:
                for n, c, p in prob_rank[:50]:
                    print(f"號碼 {n:02d}｜命中 {c}｜機率 {p:.0%}")
            else:
                print("（無）")

    control.set_progress(40)

    model_names = ["XGBoost", "LightGBM", "CatBoost", "Logistic", "RandomForest", "CRF"]

    def format_nums(nums_list):
        return "[" + ", ".join(f"{n:02d}" for n in sorted(nums_list)) + "]"

    def pick_topn_stable(scores, top_n, desc=True):
        """
        穩定挑 TopN：
        - 先比 score（大→小 或 小→大）
        - score 同分時，號碼小者優先
        回傳：號碼(1-based) 已排序（由小到大）
        """
        s = np.asarray(scores, dtype=np.float64)
        n = s.shape[0]

        if desc:
            # 主要鍵：-score（大→小），次要鍵：號碼（小→大）
            order = np.lexsort((np.arange(n, dtype=np.int32), -s))
        else:
            order = np.lexsort((np.arange(n, dtype=np.int32), s))

        pick_idx = order[:top_n]
        return sorted([int(i + 1) for i in pick_idx])

    # ✅ 符號改成：連2版=◆，連>=3版=🔥
    def format_nums_with_marks(nums_list, mark_level: dict):
        parts = []
        for n in nums_list:
            lvl = int(mark_level.get(int(n), 0))
            if lvl >= 3:
                mark = "🔥"
            elif lvl >= 2:
                mark = "◆"
            else:
                mark = ""
            parts.append(f"{int(n):02d}{mark}")
        return "[" + ", ".join(parts) + "]"

    error_logs = []
    model_hits = {}
    model_logs = {}
    model_prizes = {}

    # ========= Walk-forward 回測 =========
    def run_backtest_walkforward(model_name):
        hits, logs = [], []
        print(f"\n--- 開始模型 [{model_name}] Walk-forward 回測 ---")

        K = max(1, int(WALK_FORWARD_RETRAIN_INTERVAL))
        model_obj = None
        last_fit_i = None
        fit_count = 0

        total_steps = len(backtest_indexes)

        # ✅ tqdm 小進度條（WF 專用）
        wf_bar = tqdm(
            enumerate(backtest_indexes, 1),
            total=total_steps,
            desc=f"回測WF [{model_name}]",
            leave=True,
            ncols=90
        )

        for step_idx, i in wf_bar:
            control.check_pause_stop()

            start_idx = 0 if (TRAIN_WINDOW is None) else max(0, i - TRAIN_WINDOW)

            need_refit = (
                model_obj is None
                or last_fit_i is None
                or ((i - last_fit_i) >= K)
            )

            if need_refit:
                try:
                    seed_offset = (fit_count * 1000) + (model_names.index(model_name) * 100)
                    model_obj = fit_model_for_i(
                        model_name, X_bt, y_all, base_columns,
                        start_idx, i, seed_offset=seed_offset
                    )
                    last_fit_i = i
                    fit_count += 1
                except Exception as e:
                    error_logs.append(f"{model_name} | fit_i={i} | {e}")
                    model_obj = None

            try:
                if model_obj is None:
                    pred_scores = np.zeros(39, dtype=np.float32)
                else:
                    pred_scores = predict_scores_for_i(
                        model_name, model_obj, X_bt, base_columns, i
                    )
            except Exception as e:
                error_logs.append(f"{model_name} | pred_i={i} | {e}")
                pred_scores = np.zeros(39, dtype=np.float32)

            pred_top_n = pick_topn_stable(pred_scores, BACKTEST_TOP_N, desc=True)


            real_idx = i + 1
            real_date = df_bt.iloc[real_idx]["日期"].date()
            real_numbers = df_bt.iloc[real_idx][nums].tolist()

            hit = len(set(pred_top_n) & set(real_numbers))
            hits.append(hit)

            logs.append(
                f"{model_name:<12} | {real_date} | 命中:{hit:<2d} | "
                f"預測號碼:{format_nums(pred_top_n)} | 開獎號碼:{format_nums(real_numbers)}"
            )

        wf_bar.close()

        prize_stat = calc_prize(hits, BACKTEST_TOP_N)
        print(f"--- 完成模型 [{model_name}] Walk-forward 回測 ---")
        return model_name, hits, logs, prize_stat

    # 40~80：回測（只在「每模型」更新一次）
    total_start = time.time()
    bt_total = len(model_names)
    for idx_m, mn in enumerate(model_names, 1):
        control.set_status(f"回測中：{mn} ({idx_m}/{bt_total})")
        control.check_pause_stop()
        control.set_progress(40 + (idx_m - 1) * (40 / bt_total))

        k, hits, logs, prize_stat = run_backtest_walkforward(mn)
        model_hits[k] = hits
        model_logs[k] = logs
        model_prizes[k] = prize_stat

        control.set_progress(40 + idx_m * (40 / bt_total))

    total_end = time.time()
    print(f"\n回測全部模型總耗時：{total_end - total_start:.2f} 秒")
    if error_logs:
        with open("error_log.txt", "a", encoding="utf-8") as ef:
            for line in error_logs:
                ef.write(line + "\n")
        print(f"【已記錄異常於 error_log.txt】")

    nowtag = datetime.now().strftime('%Y%m%d_%H%M%S')

    backtest_log_file = f"backtest_all_models_WF_{backtest_N}N_K{WALK_FORWARD_RETRAIN_INTERVAL}_{nowtag}.txt"
    with open(backtest_log_file, "w", encoding="utf-8-sig") as f:
        f.write(f"Walk-forward 回測總表\n")
        f.write(f"日期範圍(被預測開獎日)：{backtest_eval_start_date} ~ {backtest_eval_end_date}\n")
        f.write(f"回測期數：{backtest_N}\n")
        f.write(f"K(每幾期重訓)：{WALK_FORWARD_RETRAIN_INTERVAL}\n")
        f.write(f"回測支數：{BACKTEST_TOP_N}\n")
        f.write("=" * 80 + "\n\n")
        for mn in model_names:
            f.write(f"[{mn}] 回測命中紀錄（完整）\n")
            for line in model_logs.get(mn, []):
                f.write(line + "\n")
            f.write("\n")

    # ✅ GUI 顯示回測紀錄：每個模型只顯示最後 N 期（避免 GUI 爆長）
    GUI_BACKTEST_SHOW_LAST_N = 30
    print(f"\n✅ 已輸出「全部模型完整回測紀錄」到檔案：{backtest_log_file}")

    # ✅ GUI 只顯示每個模型最後 N 期回測紀錄（檔案仍是完整）
    try:
        show_n = int(GUI_BACKTEST_SHOW_LAST_N) if 'GUI_BACKTEST_SHOW_LAST_N' in globals() else 30
        show_n = max(1, show_n)

        print("\n" + "=" * 80)
        print(f"✅ GUI 顯示：各模型回測紀錄（各自最後 {show_n} 期）")
        print("=" * 80)

        for mn in model_names:
            logs = model_logs.get(mn, [])
            tail = logs[-show_n:] if len(logs) > show_n else logs

            print(f"\n[{mn}]（顯示 {len(tail)}/{len(logs)} 期）")
            print("-" * 80)
            for line in tail:
                print(line)

        print("\n" + "=" * 80 + "\n")
    except Exception as e:
        print(f"（GUI 顯示最後 {GUI_BACKTEST_SHOW_LAST_N} 期回測紀錄失敗：{e}）")

    history_fname = os.path.join(
        os.getcwd(),
        f"history_WF_{backtest_N}N_K{WALK_FORWARD_RETRAIN_INTERVAL}_bt{BACKTEST_TOP_N}_pred{PRED_TOP_N}_{nowtag}.pkl"
    )
    history_data = {
        "datetime": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "mode": "walk_forward",
        "K": int(WALK_FORWARD_RETRAIN_INTERVAL),
        "backtest_eval_start_date": str(backtest_eval_start_date),
        "backtest_eval_end_date": str(backtest_eval_end_date),
        "backtest_N": int(backtest_N),
        "BACKTEST_TOP_N": int(BACKTEST_TOP_N),
        "PRED_TOP_N": int(PRED_TOP_N),
        "TRAIN_WINDOW": int(TRAIN_WINDOW) if TRAIN_WINDOW is not None else None,
        "FAST_MODE": bool(FAST_MODE),
        "USE_DETERMINISTIC": bool(USE_DETERMINISTIC),
        "GLOBAL_SEED": int(GLOBAL_SEED),
        "model_hits": model_hits,
        "model_prizes": model_prizes,
    }
    with open(history_fname, "wb") as f:
        pickle.dump(history_data, f)
    print(f"已輸出回測統計檔：{history_fname}")

    # 80~92：預測各模型
    control.set_status("預測下一期（各模型）")
    control.set_progress(82)
    control.check_pause_stop()

    all_model_predictions_prob = {}
    all_model_predictions_size = {}
    all_model_pred_scores = {}

    def predict_one_model(model_name):
        control.check_pause_stop()
        i = len(X_bt) - 1
        start_idx = 0 if (TRAIN_WINDOW is None) else max(0, i - TRAIN_WINDOW)
        seed_offset = 999_000 + (model_names.index(model_name) * 100)

        try:
            model_obj = fit_model_for_i(model_name, X_bt, y_all, base_columns, start_idx, i, seed_offset=seed_offset)
            scores = predict_scores_for_i(model_name, model_obj, X_bt, base_columns, i)
        except Exception as e:
            print(f"\n{Fore.LIGHTRED_EX}{model_name} 預測例外: {e}{Style.RESET_ALL}")
            scores = np.zeros(39, dtype=np.float32)

        pred_size = pick_topn_stable(scores, PRED_TOP_N, desc=True)

        # 落球序（機率大→小）：用穩定排序做出「機率由大到小 + 同分號碼小優先」
        # 先拿到穩定 TopN 的 idx，再依 (-score, num) 排成顯示用順序
        top_nums = pred_size[:]  # 已是 1-based
        pred_prob = sorted(top_nums, key=lambda num: (-float(scores[num - 1]), num))

        return pred_prob, pred_size, scores

    pred_total = len(model_names)
    for idx_p, mn in enumerate(model_names, 1):
        control.set_status(f"預測中：{mn} ({idx_p}/{pred_total})")
        control.check_pause_stop()
        control.set_progress(82 + (idx_p - 1) * (10 / pred_total))

        t0m = time.time()
        print(f"\n>>> [PRED] 開始訓練+預測：{mn} ...")
        pred_prob, pred_size, scores = predict_one_model(mn)
        print(f">>> [PRED] 完成：{mn}，耗時 {time.time() - t0m:.2f} 秒")

        all_model_predictions_prob[mn] = pred_prob
        all_model_predictions_size[mn] = pred_size
        all_model_pred_scores[mn] = scores.tolist()

        print(f"\n{mn:<12} | 預測期數 {predict_next_issue} / 日期(估) {predict_next_date}")
        print("  落球序預測（機率大→小）："
              f"{format_nums_with_marks(pred_prob, mark_level)}")
        print("  大小序預測（正序）    ："
              f"{format_nums_with_marks(pred_size, mark_level)}")
        print("-" * 60)

        if SAVE_PROBA_CSV:
            out_csv = f"pred_scores_{mn}.csv"
            pd.DataFrame({
                "number": [f"{i:02d}" for i in range(1, 40)],
                "proba": scores
            }).to_csv(out_csv, index=False, encoding="utf-8-sig")

        control.set_progress(82 + idx_p * (10 / pred_total))

    def save_latest_predict(predict_issue, predict_date, preds_dict):
        filename = "latest_predict.csv"
        with open(filename, mode="w", newline="", encoding="utf-8-sig") as f:
            writer = csv.writer(f)
            writer.writerow(["預測期數", "預測日期", "模型", "預測號碼"])
            for model_name, numbers in preds_dict.items():
                nums_str = ",".join([f"{n:02d}" for n in sorted(numbers)])
                writer.writerow([str(predict_issue), str(predict_date), model_name, nums_str])
        print(f"\n已儲存最新一期各模型預測號碼於 {filename}！（預測 TOP_{PRED_TOP_N}，採大小序；對獎優先用期數）")

    save_latest_predict(predict_next_issue, str(predict_next_date), all_model_predictions_size)

    # 92~98：綜合票選
    control.set_status("綜合票選（含錯題本）")
    control.set_progress(94)
    control.check_pause_stop()

    score_sum_unweighted = np.zeros(39, dtype=np.float32)
    for _, s in all_model_pred_scores.items():
        score_sum_unweighted += np.array(s, dtype=np.float32)

    penalty_counts = load_penalty_from_real_results(result_file="latest_predict_result.csv")
    auto_alpha = get_auto_mistake_alpha("latest_predict_result.csv")
    penalty = auto_alpha * penalty_counts
    print(f"錯題本自動懲罰係數 MISTAKE_ALPHA = {auto_alpha:.3f}（依真實對獎紀錄量自動調整）")

    combined_A = np.maximum(0.0, score_sum_unweighted - penalty)
    top_common_A = pick_topn_stable(combined_A, PRED_TOP_N, desc=True)

    print(
        f"\n所有模型【未加權+錯題本懲罰(真實對獎)】綜合票選（TOP_{PRED_TOP_N}）："
        f"{format_nums_with_marks(sorted(top_common_A), mark_level)}"
    )

    model_weight = {k: max(1e-6, float(np.mean(v))) for k, v in model_hits.items()}
    score_sum_weighted = np.zeros(39, dtype=np.float32)
    for mn, s in all_model_pred_scores.items():
        score_sum_weighted += model_weight.get(mn, 1.0) * np.array(s, dtype=np.float32)

    combined_B = np.maximum(0.0, score_sum_weighted - penalty)
    top_common_B = pick_topn_stable(combined_B, PRED_TOP_N, desc=True)

    print(
        f"所有模型【表現加權(WF回測)+錯題本懲罰(真實對獎)】綜合票選（TOP_{PRED_TOP_N}）："
        f"{format_nums_with_marks(sorted(top_common_B), mark_level)}"
    )

    all_nums_flat = [num for pred_list in all_model_predictions_size.values() for num in pred_list]
    cnt = Counter(all_nums_flat)

    overlap_min = 2
    overlap_nums = [n for n, v in cnt.items() if v >= overlap_min]
    if overlap_nums:
        print(
            f"所有模型【至少 {overlap_min} 個模型都推薦】號碼："
            f"{format_nums_with_marks(sorted(overlap_nums), mark_level)}"
        )

    union_nums = sorted(set(all_nums_flat))
    print(
        f"所有模型【聯合集合】推薦號碼（TOP_{PRED_TOP_N} 之 union）："
        f"{format_nums_with_marks(sorted(top_common_A), mark_level)}"
    )

    control.set_progress(98)

    # ========= 做「最後執行結果摘要」給新視窗顯示 =========
    profit_rank = []
    for k in model_names:
        total_profit = sum(model_prizes[k][star]['profit'] for star in ["2星", "3星", "4星"])
        profit_rank.append((k, int(total_profit)))
    profit_rank.sort(key=lambda x: x[1], reverse=True)

    summary_lines = []
    summary_lines.append(f"回測期數：{backtest_N}（被預測開獎日：{backtest_eval_start_date} ~ {backtest_eval_end_date}）")
    summary_lines.append(f"回測：{BACKTEST_TOP_N}；預測：{PRED_TOP_N}；K={WALK_FORWARD_RETRAIN_INTERVAL}")
    summary_lines.append(f"下一期：期數 {predict_next_issue} / 日期(估) {predict_next_date}")
    summary_lines.append("")
    summary_lines.append("【各模型平均命中】")
    for k in model_names:
        v = model_hits.get(k, [])
        summary_lines.append(f"- {k:<12} 平均命中 {np.mean(v):.2f}（σ={np.std(v):.2f}）")
    summary_lines.append("")
    summary_lines.append("【各模型總計盈虧排名】")
    for idx, (k, profit) in enumerate(profit_rank, 1):
        summary_lines.append(f"{idx}. {k:<12} 總計盈虧：{profit} 元")
    summary_lines.append("")
    summary_lines.append("【各模型下一期預測（大小序）】")
    for k in model_names:
        pred_size = all_model_predictions_size.get(k, [])
        summary_lines.append(f"- {k:<12} {format_nums_with_marks(pred_size, mark_level)}")
    summary_lines.append("")
    summary_lines.append(f"【未加權+錯題本】TOP_{PRED_TOP_N}：{format_nums_with_marks(sorted(top_common_A), mark_level)}")
    summary_lines.append(f"【加權(WF)+錯題本】TOP_{PRED_TOP_N}：{format_nums_with_marks(sorted(top_common_B), mark_level)}")
    if overlap_nums:
        summary_lines.append(f"【至少 {overlap_min} 模型重疊】{format_nums_with_marks(sorted(overlap_nums), mark_level)}")
    summary_lines.append(f"【聯合集合 union】{format_nums_with_marks(union_nums, mark_level)}")
    summary_lines.append("")
    summary_lines.append(f"輸出檔案：{backtest_log_file}")
    summary_lines.append(f"統計檔：{history_fname}")
    summary_lines.append("（提醒）對獎以『期數』為準，日期僅為估計。")

    control.set_progress(100)
    control.set_status("完成")
    return "\n".join(summary_lines)


# ==============================================
# GUI 主視窗
# ==============================================
class App(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("今彩539 自動化預測系統（多模型 + 特徵工程 + Walk-forward 回測 ）")

        self.geometry("980x620")
        self.minsize(920, 560)

        self.control = RunControl()
        self.log_queue = queue.Queue()
        self.worker_thread = None

        # ✅ 記住「最後摘要」：即使關掉視窗也能再打開
        self.last_summary_text = ""
        self.last_summary_time = ""

        # ===== 上方容器 =====
        top = ttk.Frame(self)
        top.pack(fill="x", padx=12, pady=10)

        # ===== 第一排：參數區 =====
        top_params = ttk.Frame(top)
        top_params.pack(fill="x")

        self.var_backtestN = tk.IntVar(value=400)
        self.var_bt_topn = tk.IntVar(value=9)
        self.var_pred_topn = tk.IntVar(value=9)

        def make_spin(parent, text, var, from_, to_, width=8):
            f = ttk.Frame(parent)
            ttk.Label(f, text=text).pack(side="left")
            sp = ttk.Spinbox(f, from_=from_, to=to_, textvariable=var, width=width, increment=1)
            sp.pack(side="left", padx=(6, 0))
            sp.configure(justify="center")
            return f

        make_spin(top_params, "回測最近期數（建議400）：", self.var_backtestN, 50, 5000, width=10).pack(side="left", padx=(0, 14))
        make_spin(top_params, "回測：", self.var_bt_topn, 1, 39, width=6).pack(side="left", padx=(0, 14))
        make_spin(top_params, "預測：", self.var_pred_topn, 1, 39, width=6).pack(side="left", padx=(0, 14))

        # ===== 按鈕區 =====
        btns = ttk.Frame(top)
        btns.pack(fill="x", pady=(8, 0))

        self.btn_run = ttk.Button(btns, text="執行", command=self.on_run)
        self.btn_pause = ttk.Button(btns, text="暫停", command=self.on_pause)
        self.btn_stop = ttk.Button(btns, text="停止", command=self.on_stop)
        self.btn_show_result = ttk.Button(btns, text="查看最後結果", command=self.on_show_last_result)

        self.btn_run.pack(side="left", padx=6)
        self.btn_pause.pack(side="left", padx=6)
        self.btn_stop.pack(side="left", padx=6)
        self.btn_show_result.pack(side="left", padx=6)

        self.btn_pause.state(["disabled"])
        self.btn_stop.state(["disabled"])
        self.btn_show_result.state(["disabled"])  # ✅ 沒有摘要時先禁用；之後有產生摘要會自動啟用

        # ===== 中間：狀態 + 進度條(百分比) =====
        mid = ttk.Frame(self)
        mid.pack(fill="x", padx=12, pady=(0, 8))

        self.var_status = tk.StringVar(value="待命")
        ttk.Label(mid, text="狀態：").pack(side="left")
        self.lbl_status = ttk.Label(mid, textvariable=self.var_status)
        self.lbl_status.pack(side="left", padx=(0, 10))

        self.var_progress = tk.StringVar(value="0%")
        self.lbl_progress = ttk.Label(mid, textvariable=self.var_progress)
        self.lbl_progress.pack(side="right", padx=(8, 0))

        self.pbar = ttk.Progressbar(mid, mode="determinate", length=220, maximum=100)
        self.pbar.pack(side="right")
        self.pbar["value"] = 0

        # （已移除）模型內進度（小進度條）

        # ===== 下方：輸出框 =====
        body = ttk.Frame(self)
        body.pack(fill="both", expand=True, padx=12, pady=(0, 12))

        self.txt = tk.Text(
            body,
            wrap="word",
            font=("Cascadia Mono", 11),
            bg="#0B0F14",
            fg="#D7DEE9",
            insertbackground="#FFFFFF",
            relief="flat",
            padx=12,
            pady=10,
            spacing1=2,
            spacing2=1,
            spacing3=4,
            selectbackground="#1E3A8A",
            selectforeground="#FFFFFF"
        )
        self.txt.pack(side="left", fill="both", expand=True)

        scroll = ttk.Scrollbar(body, orient="vertical", command=self.txt.yview)
        scroll.pack(side="right", fill="y")
        self.txt.configure(yscrollcommand=scroll.set)

        # ===== Text Tag 顏色 =====
        self.txt.tag_configure("INFO", foreground="#9CA3AF")
        self.txt.tag_configure("GOOD", foreground="#22C55E")
        self.txt.tag_configure("WARN", foreground="#F59E0B")
        self.txt.tag_configure("BAD",  foreground="#EF4444")
        self.txt.tag_configure("TITLE", foreground="#60A5FA")
        self.txt.tag_configure("MODEL", foreground="#A78BFA")
        self.txt.tag_configure("DIM", foreground="#64748B")

        self._tag_rules = [
            ("BAD",  re.compile(r"(錯誤|例外|Exception|Traceback|ERROR|Fail|失敗)", re.I)),
            ("GOOD", re.compile(r"(完成|成功|✅|已輸出|已儲存)", re.I)),
            ("WARN", re.compile(r"(提醒|注意|警告|⚠)", re.I)),
            ("TITLE", re.compile(r"^=+.*=+$")),
            ("MODEL", re.compile(r"\b(XGBoost|LightGBM|CatBoost|Logistic|RandomForest|CRF)\b", re.I)),
            ("DIM",  re.compile(r"^\s*[-=]{3,}\s*$")),
        ]

        self.after(80, self.pump_logs)
        self.after(250, self.refresh_status)

        self._tqdm_line_start = None  # ✅ tqdm 單行覆蓋用（每個模型都只顯示一行進度）

        self.protocol("WM_DELETE_WINDOW", self.on_close)

    def _append_log(self, s: str):
        s = ANSI_ESCAPE_RE.sub("", s)
        if not s:
            return

        def _choose_tag(line: str):
            tag = None
            for tname, cre in self._tag_rules:
                if cre.search(line):
                    tag = tname
                    break
            if tag is None:
                tag = "INFO" if line.strip() == "" else None
            return tag

        def overwrite_tqdm_line(text: str, tag_name="INFO"):
            # tqdm 單行更新：用 \r 回到行首覆蓋（GUI Text 需要手動做）
            if self._tqdm_line_start is None:
                self._tqdm_line_start = self.txt.index("end-1c")

            # 刪掉上一版 tqdm 行內容
            try:
                self.txt.delete(self._tqdm_line_start, "end-1c")
            except Exception:
                self._tqdm_line_start = self.txt.index("end-1c")

            text = text.replace("\n", "")
            self.txt.insert("end", text, tag_name)

        # 先用 \r 切段：tqdm 更新會走 \r
        parts = s.split("\r")

        # 第一段：正常輸出（可能含多行）
        first = parts[0]
        if first:
            for line in first.splitlines(True):
                tag = _choose_tag(line)
                if tag:
                    self.txt.insert("end", line, tag)
                else:
                    self.txt.insert("end", line)

                # 一旦真的換行，表示 tqdm 行結束，重置覆蓋狀態
                if "\n" in line:
                    self._tqdm_line_start = None

        # 後續段：都是同一行覆蓋更新（每個模型的 tqdm 都會在這裡更新）
        for p in parts[1:]:
            if not p:
                continue

            # tqdm 完成時可能包含 '\n'，要把最後那條固定成一行
            if "\n" in p:
                before, after = p.split("\n", 1)

                if before:
                    overwrite_tqdm_line(before, "INFO")

                # 固定這行（補換行）
                self.txt.insert("end", "\n", "INFO")
                self._tqdm_line_start = None

                # after 可能還有其他輸出（照正常模式插入）
                if after:
                    for line in after.splitlines(True):
                        tag = _choose_tag(line)
                        if tag:
                            self.txt.insert("end", line, tag)
                        else:
                            self.txt.insert("end", line)
            else:
                overwrite_tqdm_line(p, "INFO")

        self.txt.see("end")


    def pump_logs(self):
        try:
            while True:
                s = self.log_queue.get_nowait()
                self._append_log(s)
        except queue.Empty:
            pass
        self.after(80, self.pump_logs)

    def refresh_status(self):
        self.var_status.set(self.control.get_status())

        try:
            p = float(self.control.get_progress())
        except Exception:
            p = 0.0
        p = max(0.0, min(100.0, p))

        self.pbar["value"] = p
        self.var_progress.set(f"{int(p)}%")

        self.after(250, self.refresh_status)

    def on_show_last_result(self):
        """✅ 新增：隨時再打開『最後執行結果（摘要）』"""
        if not self.last_summary_text.strip():
            messagebox.showinfo("提示", "目前沒有可查看的最後結果（請先執行一次並成功產生摘要）。")
            return
        title = "最後執行結果（摘要）"
        if self.last_summary_time:
            title = f"{title} - {self.last_summary_time}"
        self.open_result_window(self.last_summary_text, title=title)

    def on_run(self):
        if self.worker_thread and self.worker_thread.is_alive():
            messagebox.showinfo("提示", "程式正在執行中。")
            return

        try:
            backtestN = int(self.var_backtestN.get())
            bt_topn = int(self.var_bt_topn.get())
            pred_topn = int(self.var_pred_topn.get())
        except Exception:
            messagebox.showerror("錯誤", "參數必須是整數。")
            return

        self.control = RunControl()
        self.control.set_status("啟動中")
        self.control.set_progress(0)

        self.btn_run.state(["disabled"])
        self.btn_pause.state(["!disabled"])
        self.btn_stop.state(["!disabled"])
        self.btn_pause.configure(text="暫停")

        # 執行中先不允許點（避免誤會）
        self.btn_show_result.state(["disabled"])

        self.txt.delete("1.0", "end")

        self.pbar["value"] = 0
        self.var_progress.set("0%")

        self.worker_thread = threading.Thread(
            target=self._worker_main,
            args=(backtestN, bt_topn, pred_topn),
            daemon=True
        )
        self.worker_thread.start()

    def on_pause(self):
        if not self.worker_thread or not self.worker_thread.is_alive():
            return

        if self.control.pause_event.is_set():
            self.control.request_pause()
            self.control.set_status("已暫停（等待續跑）")
            self.btn_pause.configure(text="續跑")
        else:
            self.control.request_resume()
            self.control.set_status("續跑中")
            self.btn_pause.configure(text="暫停")

    def on_stop(self):
        if not self.worker_thread or not self.worker_thread.is_alive():
            return
        self.control.request_stop()
        self.control.set_status("停止中（正在安全中斷）")

    def on_close(self):
        if self.worker_thread and self.worker_thread.is_alive():
            if messagebox.askyesno("確認", "程式仍在執行，確定要停止並關閉？"):
                self.control.request_stop()
                self.after(300, self.destroy)
        else:
            self.destroy()

    def _worker_main(self, backtestN, bt_topn, pred_topn):
        final_summary = ""
        try:
            with redirect_output_to_queue(self.log_queue):
                print("===== GUI 模式啟動 =====")
                print(f"回測期數={backtestN}，回測支數={bt_topn}，預測支數={pred_topn}")
                print("")
                final_summary = run_pipeline(backtestN, bt_topn, pred_topn, self.control)

        except KeyboardInterrupt:
            with redirect_output_to_queue(self.log_queue):
                print("\n【已停止】使用者停止執行。\n")
        except Exception as e:
            with redirect_output_to_queue(self.log_queue):
                print(f"\n【錯誤】{type(e).__name__}: {e}\n")
        finally:
            self.after(0, lambda: self._finish_ui(final_summary))

    def _finish_ui(self, final_summary: str):
        self.btn_run.state(["!disabled"])
        self.btn_pause.state(["disabled"])
        self.btn_stop.state(["disabled"])
        self.btn_pause.configure(text="暫停")

        if self.control.get_status() == "完成":
            self.pbar["value"] = 100
            self.var_progress.set("100%")

        # ✅ 成功產生摘要：記住它，並啟用「查看最後結果」
        if final_summary and ("【錯誤】" not in final_summary) and final_summary.strip():
            self.last_summary_text = final_summary
            self.last_summary_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            self.btn_show_result.state(["!disabled"])

            messagebox.showinfo("完成", "執行完成！已輸出所有結果檔案。")
            self.open_result_window(final_summary, title=f"最後執行結果（摘要） - {self.last_summary_time}")
        else:
            # 若沒有成功摘要，但之前曾有摘要，仍可讓你點「查看最後結果」看上一份
            if self.last_summary_text.strip():
                self.btn_show_result.state(["!disabled"])
            if final_summary.strip():
                self.open_result_window(final_summary, title="最後執行結果（摘要）")

    def open_result_window(self, summary_text: str, title="最後執行結果（摘要）"):
        win = tk.Toplevel(self)
        win.title(title)
        win.geometry("900x560")
        win.minsize(820, 520)

        frm = ttk.Frame(win)
        frm.pack(fill="both", expand=True, padx=10, pady=10)

        txt = tk.Text(
            frm,
            wrap="word",
            font=("Cascadia Mono", 11),
            bg="#0B0F14",
            fg="#D7DEE9",
            insertbackground="#FFFFFF",
            relief="flat",
            padx=12,
            pady=10
        )
        txt.pack(side="left", fill="both", expand=True)

        scr = ttk.Scrollbar(frm, orient="vertical", command=txt.yview)
        scr.pack(side="right", fill="y")
        txt.configure(yscrollcommand=scr.set)

        txt.insert("end", summary_text)
        txt.see("1.0")


def main():
    app = App()
    app.mainloop()


if __name__ == "__main__":
    main()
