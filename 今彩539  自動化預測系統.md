# ==============================================
# 今彩539 自動化預測系統（多模型 + 特徵工程 + Walk-forward 回測）GUI版
# 主要功能：資料下載/清洗、特徵工程、Walk-forward 回測、錯題本、版路拖牌、加權票選、輸出 CSV
# ==============================================

import warnings
import os
import sys
import re
import csv
import time
import pickle
import random
import tempfile
import contextlib
import multiprocessing
from io import StringIO
from datetime import timedelta, datetime
from collections import Counter, defaultdict
from itertools import combinations
import math
import json
import time as _time

import requests
import numpy as np

def _fmt_nums(nums):
    try:
        return "[" + ", ".join(f"{int(x):02d}" for x in nums) + "]"
    except Exception:
        return str(nums)

def _print_model_backtest_records(model_name: str, records: list):
    """
    records: list of dict with keys:
      '期數','日期','命中顆數','開獎號碼','模型號碼'
    """
    if not records:
        return
    print(f"\n【{model_name} 回測逐期紀錄】(期數/日期/命中/開獎/模型)")
    for r in records:
        issue = r.get("期數", "")
        date = r.get("日期", "")
        hit = r.get("命中顆數", "")
        actual = r.get("開獎號碼", [])
        pred = r.get("模型號碼", [])
        print(f"期數 {issue} | 日期 {date} | 命中 {hit} | 開獎 {_fmt_nums(actual)} | 模型 {_fmt_nums(pred)}")
    print("")
from tqdm.auto import tqdm

import pandas as pd

# ===== Optional deps（缺少也能跑；只是不顯示顏色/跳過部分模型） =====
try:
    from colorama import Fore, Style
except Exception:
    class _Fore:
        def __getattr__(self, _):
            return ''
    class _Style:
        RESET_ALL = ''
        def __getattr__(self, _):
            return ''
    Fore, Style = _Fore(), _Style()

XGBClassifier = None
LGBMClassifier = None
CatBoostClassifier = None
sklearn_crfsuite = None
XGBOOST_AVAILABLE = False
LIGHTGBM_AVAILABLE = False
CATBOOST_AVAILABLE = False
CRF_AVAILABLE = False
try:
    from xgboost import XGBClassifier  # type: ignore
    XGBOOST_AVAILABLE = True
except Exception:
    XGBOOST_AVAILABLE = False
try:
    from lightgbm import LGBMClassifier  # type: ignore
    LIGHTGBM_AVAILABLE = True
except Exception:
    LIGHTGBM_AVAILABLE = False
try:
    from catboost import CatBoostClassifier  # type: ignore
    CATBOOST_AVAILABLE = True
except Exception:
    CATBOOST_AVAILABLE = False
try:
    import sklearn_crfsuite  # type: ignore
    CRF_AVAILABLE = True
except Exception:
    CRF_AVAILABLE = False
from sklearn.multioutput import MultiOutputClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.exceptions import ConvergenceWarning
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.base import BaseEstimator, ClassifierMixin

# ===== GUI =====
import tkinter as tk
from tkinter import ttk, messagebox
import threading
import queue

# ===== ANSI 色碼剝除（Colorama / Console 顏色碼）=====
ANSI_ESCAPE_RE = re.compile(r"\x1b\[[0-9;]*m|\[[0-9]{1,3}m|\[0m")


# ===== 小工具：統一輸出（避免 _print 未定義）=====
def _print(*args, **kwargs):
    try:
        s = ' '.join(str(a) for a in args)
        s = ANSI_ESCAPE_RE.sub('', s)
        print(s, **{k:v for k,v in kwargs.items() if k != 'flush'})
    except Exception:
        try:
            print(*args, **kwargs)
        except Exception:
            pass

# ===== CatBoost 暫存目錄（避免 NameError）=====
catboost_train_dir = os.path.join(tempfile.gettempdir(), 'catboost_tmp')
try:
    os.makedirs(catboost_train_dir, exist_ok=True)
except Exception:
    pass


# ==============================================
# CatBoost sklearn 相容 wrapper
# ==============================================
class CatBoostSklearnCompat(CatBoostClassifier if CatBoostClassifier is not None else object, BaseEstimator, ClassifierMixin):
    """補 __sklearn_tags__ 讓 MultiOutputClassifier 可用"""
    def __sklearn_tags__(self):
        return BaseEstimator.__sklearn_tags__(self)


# ==============================================
# 輸出/雜訊控制
# ==============================================
os.environ.setdefault("PYTHONWARNINGS", "ignore")

warnings.simplefilter("ignore")
warnings.filterwarnings("ignore", category=ConvergenceWarning)
warnings.filterwarnings("ignore", message=".*lbfgs failed to converge.*", module=r"sklearn\.linear_model\._logistic")
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=FutureWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)


@contextlib.contextmanager
def suppress_all_output(enable=True):
    """enable=True：stdout/stderr/warnings 全部消音（訓練/預測用）"""
    if not enable:
        yield
        return
    old_showwarning = warnings.showwarning
    warnings.showwarning = lambda *args, **kwargs: None
    with open(os.devnull, "w") as devnull:
        with contextlib.redirect_stdout(devnull), contextlib.redirect_stderr(devnull):
            try:
                yield
            finally:
                warnings.showwarning = old_showwarning


# ==============================================
# 多執行緒/CPU 設定
# ==============================================
CPU_LOGICAL = multiprocessing.cpu_count()
AUTO_THREADS = max(1, CPU_LOGICAL - 1)

os.environ["OMP_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["MKL_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["OPENBLAS_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["NUMEXPR_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["VECLIB_MAXIMUM_THREADS"] = str(AUTO_THREADS)
os.environ["JOBLIB_MULTIPROCESSING"] = "1"

N_JOBS = AUTO_THREADS


# ==============================================
# 可調參數
# ==============================================
FAST_MODE = True

# 固定訓練窗：只用最近 N 期訓練（加速）
TRAIN_WINDOW = 900
DOWNLOAD_RETRY = 3

# 錯題本懲罰強度（自動隨真實對獎紀錄量變強）
MISTAKE_ALPHA = None
SAVE_PROBA_CSV = True

USE_DETERMINISTIC = True
GLOBAL_SEED = 42

# Walk-forward：每 K 期才重訓一次
WALK_FORWARD_RETRAIN_INTERVAL = 10

# 版路拖牌
DRAG_ENABLE = True
MAX_LAG = 10
MIN_CHAIN_RUN = 2
DRAG_MAX_ROWS = 260
DRAG_PREDICT_LAGS = list(range(1, 11))


def get_auto_mistake_alpha(result_file="latest_predict_result.csv"):
    """依真實對獎紀錄筆數自動調整錯題本懲罰強度"""
    try:
        if not os.path.exists(result_file):
            return 0.05
        df = pd.read_csv(result_file, dtype=str, encoding="utf-8-sig")
        n = len(df)
    except Exception:
        return 0.05

    if n < 30:
        return 0.05
    elif n < 80:
        return 0.08
    elif n < 150:
        return 0.10
    else:
        return 0.12


def auto_tau_from_real_results(result_file: str = "latest_predict_result.csv", base_tau: float = 0.5,
                               lookback: int = 20, min_tau: float = 0.35, max_tau: float = 0.85) -> float:
    """依『真實對獎』結果自動調整 tau（探索/穩定）

    目的：當連輸或近期平均命中偏低時，提高 tau 增加探索；
         當近期穩定（平均命中較高）時，降低 tau 聚焦高分號。

    只讀 latest_predict_result.csv，不會污染回測。
    檔案格式只要有『命中數』欄位即可。
    """
    try:
        import pandas as _pd
        if not os.path.exists(result_file):
            return float(base_tau)
        df = _pd.read_csv(result_file, encoding='utf-8-sig')
        if df is None or df.empty:
            return float(base_tau)
        col = None
        for c in df.columns:
            if str(c).strip() == '命中數':
                col = c
                break
        if col is None:
            return float(base_tau)

        tail = df.tail(int(max(1, lookback))).copy()
        hits = []
        for v in tail[col].tolist():
            try:
                hits.append(float(v))
            except Exception:
                pass
        if not hits:
            return float(base_tau)

        avg_hit = sum(hits) / max(1, len(hits))
        lose_streak = 0
        for v in reversed(hits):
            if v <= 0:
                lose_streak += 1
            else:
                break

        tau = float(base_tau)
        # 規則（可自行調）
        if lose_streak >= 5:
            tau += 0.20
        elif lose_streak >= 3:
            tau += 0.12

        if avg_hit < 1.0:
            tau += 0.10
        elif avg_hit > 1.6:
            tau -= 0.08
        elif avg_hit > 1.3:
            tau -= 0.04

        if tau < float(min_tau):
            tau = float(min_tau)
        if tau > float(max_tau):
            tau = float(max_tau)
        return float(tau)
    except Exception:
        return float(base_tau)

# ==============================================
# 固定 seed（回測/預測可重現）
# ==============================================
def set_global_seed(seed=42):
    random.seed(seed)
    np.random.seed(seed)
    os.environ["PYTHONHASHSEED"] = str(seed)


if USE_DETERMINISTIC:
    set_global_seed(GLOBAL_SEED)


# ==============================================
# GUI 端自繪「tqdm 風格」單行進度條（用 \r 覆寫同一行）
# ==============================================
class _TqdmQueueFile:
    """讓 tqdm 輸出走 Queue（給 Tk Text 使用）
    ✅ Tk Text 不是真終端機，tqdm 的 \r 覆寫會變成殘影
    ✅ 解法：進度條行不即時輸出，只保留「最後一行」，close 時再輸出一次（通常就是 100%）
    """
    def __init__(self, q):
        self.q = q
        self.encoding = "utf-8"
        self.closed = False
        self._last_bar_line = ""

    def isatty(self):
        # 讓 tqdm 維持互動輸出型態（但我們仍不在 Text 中做即時覆寫）
        return True

    def _looks_like_bar(self, s: str) -> bool:
        ss = str(s)
        # 你的 bar 都是「回測WF [模型]」這種格式，直接用它判斷最穩
        return "回測WF [" in ss

    def write(self, s):
        try:
            if not s:
                return

            ss = str(s)

            # tqdm 會用 \r 刷新：取最後一次刷新結果
            if "\r" in ss:
                ss = ss.split("\r")[-1]

            # 逐行處理
            for line in ss.split("\n"):
                if not line:
                    continue

                if self._looks_like_bar(line):
                    # ✅ 進度條行：只記住最後一行（避免 0% 殘影）
                    self._last_bar_line = line
                else:
                    # ✅ 一般訊息：照常輸出
                    self.q.put(line + "\n")
        except Exception:
            pass

    def flush_final_bar(self):
        """close 時呼叫：只輸出最後一次 bar 行（通常是 100% 那行）"""
        try:
            if self._last_bar_line:
                self.q.put(self._last_bar_line.rstrip("\r\n") + "\n")
                self._last_bar_line = ""
        except Exception:
            pass

    def flush(self):
        return

    def fileno(self):
        return 0



class GuiTqdm:
    """
    ✅ tqdm 版（GUI）：把 tqdm 的輸出導到 Tk Text 的 queue
    - 你原本 _text_write() 已支援 \r 單行覆寫，所以 tqdm 的行為會自然生效
    - 支援 tqdm.write() 風格訊息（不破壞進度條）
    """
    def __init__(self, total, desc="", width=22, q=None, min_interval=0.05):
        self.total = max(1, int(total))
        self.desc = str(desc)
        self.q = q
        self._file = _TqdmQueueFile(q) if q else None
        # tqdm 會自動處理寬度/ETA；ncols 讓它在 GUI 端不要太長
        ncols = int(max(20, width + 40))
        self._bar = tqdm(
            total=self.total,
            desc=self.desc,
            file=self._file,
            ncols=ncols,
            mininterval=float(min_interval),
            dynamic_ncols=False,
            leave=True
        )

    def update(self, n=1):
        try:
            self._bar.update(int(n))
        except Exception:
            pass

    def set_description(self, desc: str):
        try:
            self._bar.set_description(str(desc), refresh=True)
        except Exception:
            pass

    def write(self, msg: str):
        try:
            tqdm.write(str(msg), file=self._file)
        except Exception:
            # fallback：直接丟 queue（確保有換行）
            try:
                self.q.put(str(msg) + "\n")
            except Exception:
                pass

    def close(self):
        try:
            # 先關閉 tqdm（會把最後狀態寫到 file.write → 我們會存到 _last_bar_line）
            try:
                self._bar.close()
            except Exception:
                pass

            # ✅ 這行才是關鍵：把最後一次（100%）進度條行吐出來一次
            try:
                if self._file:
                    self._file.flush_final_bar()
            except Exception:
                pass

            # ✅ 不要在這裡 q.put("\n")，避免「完成模型」上方變成空兩行
            # 空行要由「完成模型 print」那邊去控制（你才會一致）

        except Exception:
            pass





class ConsoleTqdm:
    """
    ✅ tqdm 版（Console）：直接用 tqdm 印到終端
    """
    def __init__(self, total, desc="", width=22, min_interval=0.05):
        self.total = max(1, int(total))
        self.desc = str(desc)
        ncols = int(max(20, width + 40))
        self._bar = tqdm(
            total=self.total,
            desc=self.desc,
            ncols=ncols,
            mininterval=float(min_interval),
            dynamic_ncols=True,
            leave=True
        )

    def update(self, n=1):
        try:
            self._bar.update(int(n))
        except Exception:
            pass

    def set_description(self, desc: str):
        try:
            self._bar.set_description(str(desc), refresh=True)
        except Exception:
            pass

    def write(self, msg: str):
        try:
            tqdm.write(str(msg))
        except Exception:
            print(str(msg))

    def close(self):
        try:
            self._bar.close()
        except Exception:
            pass

class RunControl:
    def __init__(self):
        self.pause_event = threading.Event()
        self.stop_event = threading.Event()
        self.pause_event.set()   # 預設執行中

        # ✅ 新增：提供 GUI 判斷用
        self.paused = False

        self.status_lock = threading.Lock()
        self.status_text = "待命"

        self.progress_lock = threading.Lock()
        self.progress_value = 0.0

    def set_status(self, text: str):
        with self.status_lock:
            self.status_text = str(text)

    def get_status(self) -> str:
        with self.status_lock:
            return self.status_text

    def set_progress(self, value: float, *args, **kwargs):
        """設定進度(0~100)。
        - 新版：set_progress(value)
        - 相容舊版：set_progress(current, total) 會自動換算成百分比
        """
        # ✅ 相容舊呼叫：set_progress(current, total)
        if args:
            try:
                cur = float(value)
                total = float(args[0])
                if total > 0:
                    value = (cur / total) * 100.0
            except Exception:
                # 若舊參數不合法，退回用原 value
                pass
        # clamp 0~100
        try:
            value = float(value)
        except Exception:
            value = 0.0
        if value < 0: value = 0.0
        if value > 100: value = 100.0
        try:
            v = float(value)
        except Exception:
            return
        v = 0.0 if v < 0 else (100.0 if v > 100 else v)
        with self.progress_lock:
            self.progress_value = v

    def get_progress(self) -> float:
        with self.progress_lock:
            return float(self.progress_value)

    # ✅ 新增：讓 on_pause_resume() 可以可靠判斷
    def is_paused(self) -> bool:
        try:
            return bool(self.paused) or (not self.pause_event.is_set())
        except Exception:
            return not self.pause_event.is_set()

    def request_pause(self):
        self.paused = True
        self.pause_event.clear()
        self.set_status("暫停中")

    def request_resume(self):
        self.paused = False
        self.pause_event.set()
        self.set_status("執行中")

    def request_stop(self):
        self.stop_event.set()
        self.paused = False
        self.pause_event.set()
        self.set_status("停止中")

    def check_pause_stop(self):
        if self.stop_event.is_set():
            raise KeyboardInterrupt("使用者停止")
        while not self.pause_event.is_set():
            if self.stop_event.is_set():
                raise KeyboardInterrupt("使用者停止")
            time.sleep(0.15)


# ==============================================
# GUI log：把 print 導到 Text
# ==============================================
# ==============================================
# GUI log：把 print 導到 Text（修正：輸出切行，避免黏在一起）
# ==============================================
class QueueWriter:
    def __init__(self, q: queue.Queue):
        self.q = q
        self._buf = ""

    def write(self, s: str):
        if not s:
            return

        # ✅ 進度條/覆寫行（含 \r）直接送出
        if "\r" in s:
            self.q.put(s)
            return

        # ✅ 修正：tqdm 有時最後 100% 行不帶 \r，會被當碎片緩衝 → 順序被「全部完成」插隊
        #    只要看起來像進度條，就直接送出，不進 buffer
        ss = str(s)
        looks_like_bar = (
            ("回測WF [" in ss and "%" in ss and ("/" in ss)) or
            ("%" in ss and ("it/s" in ss or "s/it" in ss)) or
            ("|########" in ss) or ("|####" in ss)
        )
        if looks_like_bar:
            if not ss.endswith("\n"):
                ss += "\n"
            self.q.put(ss)
            return

        # 一般輸出：緩衝，直到出現換行才送出整行（避免碎片黏一起）
        self._buf += ss

        while "\n" in self._buf:
            line, self._buf = self._buf.split("\n", 1)
            self.q.put(line + "\n")


    def flush(self):
        # 把最後殘留的碎片也送出，並補一個換行，避免黏在下一段後面
        if self._buf:
            self.q.put(self._buf + "\n")
            self._buf = ""


@contextlib.contextmanager
def redirect_output_to_queue(q: queue.Queue):
    old_out, old_err = sys.stdout, sys.stderr
    sys.stdout = QueueWriter(q)
    sys.stderr = QueueWriter(q)
    try:
        yield
    finally:
        sys.stdout = old_out
        sys.stderr = old_err


# ==============================================
# 小工具：抓網頁文字（公告抓日期用）
# ==============================================
def _fetch_text(url: str, timeout=6):
    try:
        r = requests.get(url, timeout=timeout, headers={
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
            "Accept-Language": "zh-TW,zh;q=0.9",
        })
        r.raise_for_status()
        r.encoding = r.apparent_encoding or "utf-8"
        return r.text
    except Exception:
        return ""


# ==============================================
# 下載/快取今彩539資料 + 清洗
# ==============================================
def load_tw539(force_download=False):
    """下載/讀取快取今彩539資料。

    ✅ 新增：
    - 回傳 df 同時附帶 df.attrs：
      - fetch_source: 來源 URL 或 CACHE
      - fetch_time: 抓取/快取檔時間（字串）
      - latest_draw_date: 最新開獎日期（YYYY-MM-DD）
      - latest_issue: 最新期數

    （注意）資料來源為 biga 歷史資料鏡像；你在 GUI 看到的「官方日期」以資料檔最新一期的『日期』為準。
    """
    DATA_CACHE = "tw539_latest.csv"
    DATA_URL = "https://biga.com.tw/HISTORYDATA/tw539.csv"

    def _attach_meta(df, fetch_source: str, fetch_time_dt):
        # 最新期數（以期數最大為準）
        try:
            latest_issue = int(pd.to_numeric(df["期數"], errors="coerce").max()) if len(df) else ""
        except Exception:
            latest_issue = ""

        # 最新開獎日期（以日期最大為準）
        try:
            latest_date = pd.to_datetime(df["日期"], errors="coerce").max()
            latest_date_str = latest_date.strftime("%Y-%m-%d") if pd.notna(latest_date) else ""
        except Exception:
            latest_date_str = ""

        df.attrs["fetch_source"] = str(fetch_source)
        df.attrs["fetch_time"] = fetch_time_dt.strftime("%Y-%m-%d %H:%M:%S") if hasattr(fetch_time_dt, "strftime") else str(fetch_time_dt)
        df.attrs["latest_draw_date"] = str(latest_date_str)
        df.attrs["latest_issue"] = str(latest_issue)
        return df

    # --- 讀快取 ---
    if (not force_download) and os.path.exists(DATA_CACHE):
        df = None
        for enc in ("utf-8-sig", "utf-8", "cp950", "big5"):
            try:
                df = pd.read_csv(DATA_CACHE, encoding=enc)
                break
            except Exception:
                df = None
        if df is None:
            raise RuntimeError(f"快取檔 {DATA_CACHE} 讀取失敗：可能檔案已損毀或非文字編碼")

        if "日期" in df.columns:
            df["日期"] = pd.to_datetime(df["日期"], errors="coerce")

        try:
            mtime = datetime.fromtimestamp(os.path.getmtime(DATA_CACHE))
        except Exception:
            mtime = datetime.now()

        return _attach_meta(df, fetch_source="CACHE", fetch_time_dt=mtime)

    # --- 下載 ---
    last_err = None
    for _ in range(DOWNLOAD_RETRY):
        try:
            r = requests.get(DATA_URL, timeout=15)
            r.raise_for_status()
            csv_str = r.content.decode("utf-8-sig")
            df = pd.read_csv(StringIO(csv_str), header=None)
            df.columns = [
                "日期", "期數",
                "落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5",
                "",
                "正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"
            ]
            df["日期"] = pd.to_datetime(df["日期"], errors="coerce")

            num_cols = [
                "落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5",
                "正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"
            ]
            for c in num_cols:
                df[c] = pd.to_numeric(df[c], errors="coerce")

            df["期數"] = pd.to_numeric(df["期數"], errors="coerce")
            df = df.dropna(subset=["日期", "期數"] + num_cols).reset_index(drop=True)

            df["期數"] = df["期數"].astype(int)
            df[num_cols] = df[num_cols].astype(int)

            if len(df) and (df["日期"].iloc[0] > df["日期"].iloc[-1]):
                df = df.iloc[::-1].reset_index(drop=True)

            df = df.drop(columns=[""])
            df.to_csv(DATA_CACHE, index=False, encoding="utf-8-sig")

            return _attach_meta(df, fetch_source=DATA_URL, fetch_time_dt=datetime.now())
        except Exception as e:
            last_err = e
            time.sleep(1.0)

    raise RuntimeError(f"下載官方資料失敗：{last_err}")



# ==============================================
# 對獎：以「期數」優先（避免日期推算誤差）
# ==============================================
def try_save_latest_prediction_result(df, nums):
    pred_file = "latest_predict.csv"
    result_file = "latest_predict_result.csv"
    if not os.path.exists(pred_file):
        return

    pred_df = pd.read_csv(pred_file, dtype=str, encoding="utf-8-sig")
    df2 = df.copy()
    df2["日期"] = pd.to_datetime(df2["日期"], errors="coerce")

    if os.path.exists(result_file):
        result_df = pd.read_csv(result_file, dtype=str, encoding="utf-8-sig")
        recorded_keys = set(result_df.apply(lambda r: f"{r.get('預測期數','')}_{r.get('模型','')}", axis=1))
    else:
        result_df = pd.DataFrame()
        recorded_keys = set()

    new_records = []
    for _, row in pred_df.iterrows():
        model = str(row.get("模型", "")).strip()
        pred_issue = str(row.get("預測期數", "")).strip()
        pred_date = str(row.get("預測日期", "")).strip()
        pred_main_str = str(row.get("預測號碼","")).strip()

        key = f"{pred_issue}_{model}"
        if key in recorded_keys:
            continue
        if not pred_main_str:
            continue

        pred_main = [int(n) for n in pred_main_str.split(",") if str(n).strip().isdigit()]

        real_row = None
        if pred_issue.isdigit():
            real_row = df2[df2["期數"] == int(pred_issue)]
        if (real_row is None) or real_row.empty:
            if pred_date:
                real_row = df2[df2["日期"].dt.strftime("%Y-%m-%d") == pred_date]

        if real_row is None or real_row.empty:
            continue

        real_numbers = [int(n) for n in real_row.iloc[0][nums].values]
        real_date = real_row.iloc[0]["日期"].strftime("%Y-%m-%d")
        real_issue = int(real_row.iloc[0]["期數"])

        hit_set = sorted(set(pred_main) & set(real_numbers))

        new_records.append({
            "預測日期": pred_date if pred_date else "",
            "預測期數": str(pred_issue) if pred_issue else "",
            "實際開獎日期": real_date,
            "實際開獎期數": str(real_issue),
            "模型": model,
            "預測號碼": ",".join(f"{n:02d}" for n in sorted(pred_main)),
            "開獎號碼": ",".join(f"{n:02d}" for n in sorted(real_numbers)),
            "命中數": str(len(hit_set)),
            "命中號碼": ",".join(f"{n:02d}" for n in hit_set),
        })

    if new_records:
        df_new = pd.DataFrame(new_records)
        if os.path.exists(result_file):
            old = pd.read_csv(result_file, dtype=str, encoding="utf-8-sig")
            result_df = pd.concat([old, df_new], ignore_index=True)
        else:
            result_df = df_new

        # ✅ 修正：原本只印 log，這裡補上真正寫入檔案
        try:
            result_df.to_csv(result_file, index=False, encoding="utf-8-sig")
        except Exception as e:
            print(f"【警告】對獎結果寫檔失敗：{type(e).__name__}: {e}")
        print(f"\n自動完成對獎結果存檔：{result_file}（本次新增 {len(df_new)} 筆）")


# ==============================================
# 特徵工程（一次建滿；後續切片）
# ==============================================
FEATURE_CACHE = {}


def feature_engineering(df, nums, features, *, progress=None):
    cache_key = (df.index[0] if len(df) else -1, df.index[-1] if len(df) else -1)

    _t0 = _time.perf_counter()

    # ✅ 控制：是否印特徵工程 log
    if not bool(globals().get("GUI_VERBOSE_STAGE", True)):
        if cache_key in FEATURE_CACHE:
            return FEATURE_CACHE[cache_key].copy()
        X = df[features].copy()
        FEATURE_CACHE[cache_key] = X.copy()
        return X

    _state = {
        "active": False,
        "last": "",
        "had_sub": False,   # 這段是否刷過 i/n（但不再拿來自動補 1/1）
    }

    def _end_block():
        """
        ✅ 修正重點：
        - 不再自動補 '1/1'
        - 沒子進度就維持空白，符合你要的格式
        """
        if _state["active"]:
            print()      # 結束進度行（可能是空白的 '進度：'）
            print()      # 空一行
            _state["active"] = False
            _state["last"] = ""
            _state["had_sub"] = False

    def _prog(major=None, i=None, n=None):
        if not bool(globals().get("GUI_VERBOSE_STAGE", True)):
            return

        # 新大項
        if major is not None:
            _end_block()
            mj = str(major).strip()
            print(f"[特徵工程] {mj}")

            # ✅ 預設至少顯示 1/1
            print("大項進度：1/1", end="", flush=True)

            _state["active"] = True
            _state["last"] = "大項進度：1/1"
            _state["had_sub"] = False
            return

        # 子進度（若存在則顯示；至少也是 1/1）
        if _state["active"]:
            ii = int(i) if i is not None else 1
            nn = int(n) if n is not None else 1
            if nn <= 0:
                nn = 1
            if ii <= 0:
                ii = 1

            line = f"子進度：{ii}/{nn}"
            if line != _state["last"]:
                print("\r" + line + " " * 20, end="", flush=True)
                _state["last"] = line

            _state["had_sub"] = True

            if progress:
                try:
                    progress("子進度", ii, nn)
                except Exception:
                    pass
            return


    # ---------------- cache ----------------
    if cache_key in FEATURE_CACHE:
        return FEATURE_CACHE[cache_key].copy()

    X = df[features].copy()

    # =========================
    # 日期特徵
    # =========================
    _prog("日期特徵")
    if "日期" in df.columns:
        X["weekday"] = df["日期"].dt.weekday.astype(np.int8)
        X["month"] = df["日期"].dt.month.astype(np.int8)
        X["is_weekend"] = (X["weekday"] >= 5).astype(np.int8)

    # =========================
    # 統計特徵
    # =========================
    _prog("統計特徵")

    _prog("基本統計")
    X["max_num"] = df[nums].max(axis=1)
    X["min_num"] = df[nums].min(axis=1)
    X["sum_num"] = df[nums].sum(axis=1)
    X["mean_num"] = df[nums].mean(axis=1)
    X["std_num"] = df[nums].std(axis=1)
    X["range_num"] = X["max_num"] - X["min_num"]

    # =========================
    # 奇偶特徵
    # =========================
    _prog("奇偶特徵")
    X["odd_count"] = df[nums].apply(lambda r: sum(int(n) % 2 for n in r), axis=1).astype(np.int8)
    X["even_count"] = (5 - X["odd_count"]).astype(np.int8)
    X["odd_even_ratio"] = X["odd_count"] / (X["even_count"] + 1e-6)

    # =========================
    # 間距特徵
    # =========================
    _prog("間距特徵")
    X["num_gap"] = df[nums].apply(lambda r: np.mean(np.diff(sorted(r))), axis=1)

    # =========================
    # 連號特徵
    # =========================
    _prog("連號特徵")

    def count_serials(arr):
        s = sorted(arr)
        return sum((s[i + 1] - s[i]) == 1 for i in range(4))

    X["serial_count"] = df[nums].apply(count_serials, axis=1).astype(np.int8)

    # =========================
    # 上期重複特徵
    # =========================
    _prog("上期重複特徵")

    def repeat_count(cur, prev):
        return len(set(cur) & set(prev))

    X["repeat_prev"] = [0] + [repeat_count(df.loc[i, nums], df.loc[i - 1, nums]) for i in range(1, len(df))]
    X["repeat_prev"] = pd.Series(X["repeat_prev"], dtype=np.int8)

    # =========================
    # 大小號特徵
    # =========================
    _prog("大小號特徵")
    X["small_count"] = df[nums].apply(lambda r: sum(1 <= int(n) <= 19 for n in r), axis=1).astype(np.int8)
    X["big_count"] = df[nums].apply(lambda r: sum(20 <= int(n) <= 38 for n in r), axis=1).astype(np.int8)
    X["draw39_count"] = df[nums].apply(lambda r: sum(int(n) == 39 for n in r), axis=1).astype(np.int8)
    X["big_small_score"] = (X["big_count"] - X["small_count"]).astype(np.int8)

    # =========================
    # 尾數特徵 / 合數特徵（你原順序：先尾數再合數）
    # =========================
    _prog("尾數特徵")
    for i in range(1, 6):
        _prog(None, i, 5)
        X[f"num{i}_尾數"] = (df[f"正序號碼{i}"] % 10).astype(np.int8)

    _prog("合數特徵")
    for i in range(1, 6):
        _prog(None, i, 5)
        X[f"num{i}_合數"] = ((df[f"正序號碼{i}"] // 10 + df[f"正序號碼{i}"] % 10) % 10).astype(np.int8)

    # =========================
    # 熱度特徵（01~39）
    # =========================
    _prog("熱度特徵")
    hot_frames = []
    for n in range(1, 40):
        _prog(None, n, 39)
        num_mask = (df[nums] == n).sum(axis=1).astype(np.int16)
        col_all = pd.DataFrame({f"hot_{n:02d}_all": num_mask.cumsum().astype(np.int32)})
        col_windows = pd.DataFrame({
            f"hot_{n:02d}_{w}": num_mask.rolling(w, min_periods=1).sum().astype(np.float32)
            for w in [5, 10, 20, 30]
        })
        hot_frames.append(pd.concat([col_all, col_windows], axis=1))
    X = pd.concat([X.reset_index(drop=True), pd.concat(hot_frames, axis=1).reset_index(drop=True)], axis=1)

    # =========================
    # 遺漏特徵
    # =========================
    _prog("遺漏特徵")

    miss_features = pd.DataFrame(index=df.index)
    last_pos = {n: -1 for n in range(1, 40)}
    miss_counts = {n: [] for n in range(1, 40)}

    for idx in range(len(df)):
        if (idx + 1) % 200 == 0 or (idx + 1) == len(df):
            _prog(None, idx + 1, len(df))
        cur_set = set(df.loc[idx, nums])
        for n in range(1, 40):
            if n in cur_set:
                miss_counts[n].append(0)
                last_pos[n] = idx
            else:
                miss_counts[n].append(idx - last_pos[n] if last_pos[n] != -1 else idx + 1)

    for n in range(1, 40):
        _prog(None, n, 39)
        miss_features[f"miss_{n:02d}"] = pd.Series(miss_counts[n], dtype=np.int16)

    X = pd.concat([X.reset_index(drop=True), miss_features.reset_index(drop=True)], axis=1)

    # =========================
    # 共現特徵
    # =========================
    _prog("共現特徵")

    pair_mean_list = []
    pair_max_list = []
    pair_counts = defaultdict(int)

    for idx in range(len(df)):
        if (idx + 1) % 200 == 0 or (idx + 1) == len(df):
            _prog(None, idx + 1, len(df))

        row_nums = sorted(int(df.loc[idx, col]) for col in nums)
        pair_scores = []
        for a in range(4):
            for b in range(a + 1, 5):
                p = (row_nums[a], row_nums[b])
                pair_scores.append(pair_counts[p])

        pair_mean_list.append(float(np.mean(pair_scores)) if pair_scores else 0.0)
        pair_max_list.append(float(np.max(pair_scores)) if pair_scores else 0.0)

        for a in range(4):
            for b in range(a + 1, 5):
                p = (row_nums[a], row_nums[b])
                pair_counts[p] += 1

    X["pair_cofreq_mean"] = pd.Series(pair_mean_list, index=df.index).astype(np.float32)
    X["pair_cofreq_max"] = pd.Series(pair_max_list, index=df.index).astype(np.float32)

    # =========================
    # 群組映射（八卦/生肖/均值/五行/六沖/七政）
    # =========================
    GROUP_NAME_ZH = {
        "bagua": "八卦特徵",
        "shengxiao": "生肖特徵",
        "mean_group": "均值特徵",
        "wuxing": "五行特徵",
        "liuchong": "六沖特徵",
        "qizheng": "七政特徵",
    }

    def apply_group_feats(df, nums, name, mapping, X):
        """
        ✅ 修正重點：
        - 群組映射進度只顯示 5/5（以「五顆球」為單位）
        - 群組 count 不再刷進度（避免把 5/5 蓋掉）
        """
        zh = GROUP_NAME_ZH.get(name, name)

        # 大項標題（固定兩行）
        _prog(zh)

        # 每顆球 dummy（進度 1/5）
        dummy_frames = []
        for i in range(1, 6):
            _prog(None, i, 5)
            cat_col = df[f"正序號碼{i}"].map(mapping).astype("category")
            dummies = pd.get_dummies(cat_col, prefix=f"{name}_num{i}")
            dummy_frames.append(dummies)

        if dummy_frames:
            X = pd.concat([X.reset_index(drop=True), pd.concat(dummy_frames, axis=1).reset_index(drop=True)], axis=1)

        # 群組 count（照算，但不刷進度）
        all_groups = sorted(set(mapping.values()))
        for k in all_groups:
            X[f"{name}_{k}_count"] = df[nums].apply(
                lambda row: sum(mapping.get(n, "") == k for n in row),
                axis=1
            )
        return X

    # --- mapping 原樣保留（不省略）---
    mean_group_map = {**{i: 'A' for i in range(1, 5)}, **{i: 'B' for i in range(5, 9)}, **{i: 'C' for i in range(9, 13)},
                      **{i: 'D' for i in range(13, 17)}, **{i: 'E' for i in range(17, 21)}, **{i: 'F' for i in range(21, 25)},
                      **{i: 'G' for i in range(25, 29)}, **{i: 'H' for i in range(29, 33)}, **{i: 'I' for i in range(33, 37)},
                      **{i: 'J' for i in range(37, 40)}}

    bagua_map = {1: '乾', 16: '乾', 17: '乾', 32: '乾', 8: '坤', 9: '坤', 24: '坤', 25: '坤', 6: '坎', 11: '坎', 22: '坎', 27: '坎',
                 3: '離', 14: '離', 19: '離', 30: '離', 38: '離', 5: '震', 12: '震', 21: '震', 28: '震', 36: '震', 4: '巽', 13: '巽', 20: '巽',
                 29: '巽', 37: '巽', 2: '艮', 15: '艮', 18: '艮', 31: '艮', 39: '艮', 7: '兌', 10: '兌', 23: '兌', 26: '兌', 34: '兌'}

    shengxiao_map = {11: '羊', 23: '羊', 35: '羊', 10: '猴', 22: '猴', 34: '猴', 9: '雞', 21: '雞', 33: '雞', 8: '狗', 20: '狗', 32: '狗',
                     7: '豬', 19: '豬', 31: '豬', 6: '鼠', 18: '鼠', 30: '鼠', 5: '牛', 17: '牛', 29: '牛', 4: '虎', 16: '虎', 28: '虎',
                     3: '兔', 15: '兔', 27: '兔', 39: '兔', 2: '龍', 14: '龍', 26: '龍', 38: '龍', 1: '蛇', 13: '蛇', 25: '蛇', 37: '蛇',
                     12: '馬', 24: '馬', 36: '馬'}

    wuxing_map = {13: '金', 14: '金', 21: '金', 22: '金', 29: '金', 30: '金', 1: '木', 2: '木', 9: '木', 10: '木', 17: '木', 18: '木', 31: '木',
                  32: '木', 39: '木', 3: '水', 4: '水', 11: '水', 12: '水', 25: '水', 26: '水', 33: '水', 34: '水', 7: '火', 8: '火', 15: '火',
                  16: '火', 23: '火', 24: '火', 37: '火', 38: '火', 5: '土', 6: '土', 19: '土', 20: '土', 27: '土', 28: '土', 35: '土', 36: '土'}

    liuchong_map = {1: '子午', 7: '子午', 13: '子午', 19: '子午', 25: '子午', 31: '子午', 37: '子午', 2: '丑未', 8: '丑未', 14: '丑未',
                    20: '丑未', 26: '丑未', 32: '丑未', 38: '丑未', 3: '寅申', 9: '寅申', 15: '寅申', 21: '寅申', 27: '寅申', 33: '寅申',
                    39: '寅申', 4: '卯酉', 10: '卯酉', 16: '卯酉', 22: '卯酉', 28: '卯酉', 34: '卯酉', 5: '辰戌', 11: '辰戌', 17: '辰戌',
                    23: '辰戌', 29: '辰戌', 35: '辰戌', 6: '巳亥', 12: '巳亥', 18: '巳亥', 24: '巳亥', 30: '巳亥', 36: '巳亥'}

    qizheng_map = {1: '日', 8: '日', 15: '日', 22: '日', 29: '日', 36: '日', 2: '月', 9: '月', 16: '月', 23: '月', 30: '月', 37: '月',
                   3: '火', 10: '火', 17: '火', 24: '火', 31: '火', 38: '火', 4: '水', 11: '水', 18: '水', 25: '水', 32: '水', 39: '水',
                   5: '木', 12: '木', 19: '木', 26: '木', 33: '木', 6: '金', 13: '金', 20: '金', 27: '金', 34: '金', 7: '土', 14: '土',
                   21: '土', 28: '土', 35: '土'}

    X = apply_group_feats(df, nums, "bagua", bagua_map, X)
    X = apply_group_feats(df, nums, "shengxiao", shengxiao_map, X)
    X = apply_group_feats(df, nums, "mean_group", mean_group_map, X)
    X = apply_group_feats(df, nums, "wuxing", wuxing_map, X)
    X = apply_group_feats(df, nums, "liuchong", liuchong_map, X)
    X = apply_group_feats(df, nums, "qizheng", qizheng_map, X)

    # =========================
    # 型別壓縮
    # =========================
    _prog("型別壓縮：")
    for col in X.select_dtypes(include=["float64"]).columns:
        X[col] = X[col].astype(np.float32)
    for col in X.select_dtypes(include=["int64"]).columns:
        X[col] = X[col].astype(np.int32)

    # ✅ 最後收尾（把最後一段進度行收掉）
    _end_block()

    FEATURE_CACHE[cache_key] = X.copy()
    return X


def build_full_features_once(df, *, control=None):
    nums = ["正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"]
    features = nums + ["落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5"]

    def _fe_progress(msg, i=None, n=None):
        try:
            if control and hasattr(control, "set_status"):
                if i is not None and n is not None:
                    control.set_status(f"{msg}（{i}/{n}）")
                else:
                    control.set_status(str(msg))
        except Exception:
            pass

    X_full = feature_engineering(df, nums, features, progress=_fe_progress)
    base_columns = list(X_full.columns)
    return X_full, base_columns, nums, features


def fix_columns(df, columns):
    return df.reindex(columns=columns, fill_value=0)


# ==============================================
# 39 樂合彩固定賠付（你指定）
# ==============================================
LEHECAI39_FIXED_PRIZE = {
    2: 1125,
    3: 11250,
    4: 212500,
}

LEHECAI39_FIXED_PRIZE_MAP = dict(LEHECAI39_FIXED_PRIZE)

# ✅ 新增：39 樂合彩每注成本（你程式其他地方也用 25）
LEHECAI_TICKET_PRICE = 25
lehecai_ticket_price = LEHECAI_TICKET_PRICE

LOTTO539_FIXED_PRIZE = {
    2: 50,
    3: 300,
    4: 20000,
    5: 8000000,
}


def calc_lehecai39_profit_multi(
    pred_main_nums: list,
    actual_main_nums: list,
    *,
    play_ks=(2, 3, 4),
    ticket_price: int = 25,
):
    """39 樂合彩【二合 + 三合 + 四合】合併下注"""

    total = {"bets": 0, "cost": 0, "win": 0, "prize": 0, "profit": 0, "detail": {}}
    pred = sorted({int(x) for x in pred_main_nums})
    actual = set(int(x) for x in actual_main_nums)

    for k in play_ks:
        k = int(k)
        combos = list(combinations(pred, k))
        bets_k = len(combos)
        win_k = sum(1 for c in combos if set(c).issubset(actual))
        per_prize = int(LEHECAI39_FIXED_PRIZE.get(k, 0))
        prize_k = win_k * per_prize
        cost_k = bets_k * int(ticket_price)

        total["bets"] += bets_k
        total["cost"] += cost_k
        total["win"] += win_k
        total["prize"] += prize_k
        total["detail"][f"{k}合"] = {
            "play_k": k, "bets": bets_k, "win": win_k,
            "per_prize": per_prize, "prize": prize_k,
            "cost": cost_k, "profit": prize_k - cost_k,
        }

    total["profit"] = total["prize"] - total["cost"]
    return total


def calc_prize(
    hits,
    top_n,
    payout_mode="casino",
    *,
    pred_main_nums=None,
    actual_main_nums=None,
    play_ks=(2, 3, 4),
    ticket_price=25,
):
    """
    三模式回傳固定欄位：
      - avg_hit/std_hit/n/top_n
      - win/bets/cost/prize/profit
    """
    hits = list(hits or [])
    pm = str(payout_mode).strip().lower()

    out = {
        "mode": str(payout_mode),
        "avg_hit": float(np.mean(hits)) if hits else 0.0,
        "std_hit": float(np.std(hits)) if hits else 0.0,
        "n": int(len(hits)),
        "top_n": int(top_n),
        "win": 0,
        "bets": int(len(hits)),
        "cost": 0,
        "prize": 0,
        "profit": 0,
        "detail": {},
    }

    if pm == "casino":
        return out

    if pm == "tw539":
        cost = out["bets"] * 50
        prize = 0
        win = 0
        for h in hits:
            h = int(h)
            p = int(LOTTO539_FIXED_PRIZE.get(h, 0))
            if p > 0:
                win += 1
                prize += p
        out["win"] = int(win)
        out["cost"] = int(cost)
        out["prize"] = int(prize)
        out["profit"] = int(prize - cost)
        out["detail"] = {"539_fixed_prize": LOTTO539_FIXED_PRIZE}
        return out

    if pm == "lehecai39":
        if pred_main_nums is None or actual_main_nums is None:
            # 這個模式若沒傳入每期預測/開獎號碼，無法用 hits 直接算
            return out
        pl = calc_lehecai39_profit_multi(
            pred_main_nums=pred_main_nums,
            actual_main_nums=actual_main_nums,
            play_ks=play_ks,
            ticket_price=ticket_price,
        )
        out["bets"] = int(pl["bets"])
        out["cost"] = int(pl["cost"])
        out["win"] = int(pl["win"])
        out["prize"] = int(pl["prize"])
        out["profit"] = int(pl["profit"])
        out["detail"] = pl.get("detail", {})
        return out

    raise ValueError(f"Unknown payout_mode: {payout_mode}")

# ==============================================
# ✅ EV（期望值）選組合：casino / tw539 / lehecai39
# ==============================================
def _scores_to_probs(scores_arr: np.ndarray, eps: float = 1e-6) -> np.ndarray:
    """
    把模型分數轉成近似「每顆球入選」機率 p_i（0~1）。
    注意：這不是嚴格機率，只是用來做 EV 排序的一致標尺。
    """
    s = np.array(scores_arr, dtype=np.float64).copy()
    s = np.nan_to_num(s, nan=0.0, posinf=0.0, neginf=0.0)

    mx = float(np.max(s)) if s.size else 0.0
    if mx <= eps:
        # 全部沒訊號：給很小但非 0 的機率，避免 EV 全一樣
        p = np.full_like(s, 0.02, dtype=np.float64)
    else:
        p = s / (mx + eps)

    # 夾住，避免 0 或 1 造成 DP/乘積退化
    p = np.clip(p, 0.001, 0.999)
    return p.astype(np.float64)

def _hit_distribution(probs_5: list) -> np.ndarray:
    """
    給 5 顆球的入選機率 p1..p5，用獨立近似算命中數分佈 P(H=h)。
    dp[h] = P(命中 h 顆), h=0..5
    """
    p = [float(x) for x in probs_5]
    dp = np.zeros(6, dtype=np.float64)
    dp[0] = 1.0
    for pi in p:
        ndp = np.zeros(6, dtype=np.float64)
        for h in range(6):
            if dp[h] <= 0:
                continue
            ndp[h] += dp[h] * (1.0 - pi)
            if h + 1 <= 5:
                ndp[h + 1] += dp[h] * pi
        dp = ndp
    return dp


# ============================================================
# ✅ 推薦預測（指定顆數 N）回測選池：用「固定 N 顆號碼集合」回測過去命中率
# - 目的：你要的是「推薦預測候選池（N 顆）」不是 5 顆買票
# - 回測指標（可調）：P(hit>=2)、P(hit>=3)、avg_hit
# - 搜尋策略：以分數向量為引導，做「TopN + 擾動交換」啟發式搜尋
# ============================================================

RECO_POOL_ENABLE = True
FINAL_RECO_EQUALS_VAR_PRED_TOPN = True   # ✅ 最終推薦 = var_pred_topn（指定顆數 N）          # ✅ 是否啟用「推薦預測候選池（N顆）」回測選池
RECO_POOL_TRIALS = 1200          # 搜尋嘗試次數（越大越慢、但更穩）
RECO_POOL_SWAP_K = 3             # 每次擾動交換幾顆（2~4 常用）
RECO_POOL_METRIC = "p_ge2"       # "p_ge2" / "p_ge3" / "avg" 以哪個為主

def _hits_for_pool(pool_nums, real_nums):
    return len(set(pool_nums) & set(real_nums))

def _pool_backtest_stats(df_bt, draw_cols, pool_nums, *, start_i=0, end_i=None):
    """
    df_bt：含開獎歷史
    pool_nums：固定 N 顆號碼集合
    回傳：dict(avg, std, p_ge2, p_ge3, hits)
    """
    if end_i is None:
        end_i = len(df_bt)
    end_i = min(int(end_i), len(df_bt))
    start_i = max(0, int(start_i))

    hits = []
    for i in range(start_i, end_i):
        real_numbers = df_bt.iloc[i][draw_cols].tolist()
        hit = _hits_for_pool(pool_nums, real_numbers)
        hits.append(int(hit))

    if not hits:
        return {"avg": 0.0, "std": 0.0, "p_ge2": 0.0, "p_ge3": 0.0, "hits": []}

    import numpy as _np
    arr = _np.asarray(hits, dtype=_np.float64)
    avg = float(arr.mean())
    std = float(arr.std(ddof=0))
    p_ge2 = float((_np.sum(arr >= 2) / len(arr)) if len(arr) else 0.0)
    p_ge3 = float((_np.sum(arr >= 3) / len(arr)) if len(arr) else 0.0)
    return {"avg": avg, "std": std, "p_ge2": p_ge2, "p_ge3": p_ge3, "hits": hits}


def recommend_pool_by_backtest(
    df_bt,
    draw_cols,
    score_vec_39,
    *,
    pool_n: int,
    backtest_n: int = 500,
    trials: int = None,
    swap_k: int = None,
    metric: str = None,
    seed: int = 7,
):
    """
    回傳：(best_pool_nums, best_stat)
    - best_pool_nums：N 顆集合（遞增）
    - best_stat：{avg,std,p_ge2,p_ge3}
    """
    import numpy as _np
    rng = random.Random(int(seed))

    trials = int(RECO_POOL_TRIALS if trials is None else trials)
    swap_k = int(RECO_POOL_SWAP_K if swap_k is None else swap_k)

    pool_n = max(1, int(pool_n))
    if pool_n > 39:
        pool_n = 39

    bt_n = max(1, int(backtest_n))
    start_i = max(0, len(df_bt) - bt_n)
    end_i = len(df_bt)

    s = _np.asarray(score_vec_39, dtype=_np.float64).reshape(-1)
    if s.size != 39:
        s = _np.zeros(39, dtype=_np.float64)

    base_rank = list(_np.argsort(-s))
    best_pool = sorted({int(i + 1) for i in base_rank[:pool_n]})
    best_stat = _pool_backtest_stats(df_bt, draw_cols, best_pool, start_i=start_i, end_i=end_i)

    def _score(stat):
        return (stat["p_ge2"], stat["p_ge3"], stat["avg"], -stat["std"])

    best_key = _score(best_stat)

    all_nums = list(range(1, 40))

    for _ in range(trials):
        cur = list(best_pool)
        out_set = set(cur)

        # 純隨機丟掉
        drops = rng.sample(cur, min(swap_k, len(cur)))

        cur_set = set(cur)
        for d in drops:
            cur_set.discard(d)

        # 純隨機補進
        outside = [n for n in all_nums if n not in out_set]
        adds = rng.sample(outside, min(swap_k, len(outside)))
        for a in adds:
            cur_set.add(a)


        if len(cur_set) < pool_n:
            need = pool_n - len(cur_set)
            for i in base_rank:
                n = int(i + 1)
                if n in cur_set:
                    continue
                cur_set.add(n)
                need -= 1
                if need <= 0:
                    break
        elif len(cur_set) > pool_n:
            cur_list = sorted(cur_set, key=lambda n: (float(s[n - 1]), -n))
            cur_set = set(cur_list[-pool_n:])

        cand_pool = sorted(cur_set)
        stat = _pool_backtest_stats(df_bt, draw_cols, cand_pool, start_i=start_i, end_i=end_i)
        key = _score(stat)
        if key > best_key:
            best_key = key
            best_pool = cand_pool
            best_stat = stat

    return best_pool, best_stat


def _ticket_ev_and_stats(
    ticket_nums: list,
    p_vec: np.ndarray,
    payout_mode: str,
    *,
    lehecai_play_ks=(2, 3, 4),
    lehecai_ticket_price: int = None,
) -> dict:
    """
    回傳：
      - ev_profit: 期望盈虧（casino 用 ev_hit 當排序主體）
      - ev_hit: 期望命中數
      - p_ge2 / p_ge3: 命中>=2 / >=3 機率
      - ev_prize / ev_cost: 期望獎金/成本（非 casino）
    """
    pm = str(payout_mode).strip().lower()
    nums = [int(x) for x in ticket_nums]

    probs_5 = []
    plen = len(p_vec)

    for n in nums:
        idx = int(n) - 1
        if 0 <= idx < plen:
            probs_5.append(float(p_vec[idx]))
        else:
            # 超出機率向量範圍，直接視為 0（避免 IndexError）
            probs_5.append(0.0)

    dp = _hit_distribution(probs_5)  # 0..5
    ev_hit = float(sum(h * dp[h] for h in range(6)))
    p_ge2 = float(np.sum(dp[2:]))
    p_ge3 = float(np.sum(dp[3:]))

    if pm == "casino":
        return {
            "ev_profit": ev_hit,   # 用 hit 當 profit 來排（名字沿用）
            "ev_hit": ev_hit,
            "p_ge2": p_ge2,
            "p_ge3": p_ge3,
            "ev_prize": 0.0,
            "ev_cost": 0.0,
        }

    if pm == "tw539":
        ev_prize = 0.0
        for h in range(6):
            ev_prize += dp[h] * float(LOTTO539_FIXED_PRIZE.get(h, 0))
        ev_cost = 50.0
        ev_profit = ev_prize - ev_cost
        return {
            "ev_profit": float(ev_profit),
            "ev_hit": ev_hit,
            "p_ge2": p_ge2,
            "p_ge3": p_ge3,
            "ev_prize": float(ev_prize),
            "ev_cost": float(ev_cost),
        }

    if pm == "lehecai39":
        play_ks = tuple(int(k) for k in (lehecai_play_ks or ()) if int(k) in (2, 3, 4))

        if lehecai_ticket_price is None:
            try:
                lehecai_ticket_price = int(LEHECAI_TICKET_PRICE)
            except Exception:
                lehecai_ticket_price = 25

        ev_prize = 0.0
        ev_cost = 0.0

        # 依玩法 k 計算：命中 k 才有獎（以你檔案內 LEHECAI39_FIXED_PRIZE_MAP 為主）
        for k in play_ks:
            k = int(k)
            if k <= 0 or k > 5:
                continue

            p_hit_k = float(dp[k])  # 命中剛好 k 的機率
            prize_k = float(LEHECAI39_FIXED_PRIZE_MAP.get(k, 0.0))
            ev_prize += p_hit_k * prize_k
            ev_cost += float(lehecai_ticket_price)

        ev_profit = float(ev_prize - ev_cost)
        return {
            "ev_profit": float(ev_profit),
            "ev_hit": ev_hit,
            "p_ge2": p_ge2,
            "p_ge3": p_ge3,
            "ev_prize": float(ev_prize),
            "ev_cost": float(ev_cost),
        }

    # 其他模式：保守回傳
    return {
        "ev_profit": ev_hit,
        "ev_hit": ev_hit,
        "p_ge2": p_ge2,
        "p_ge3": p_ge3,
        "ev_prize": 0.0,
        "ev_cost": 0.0,
    }


def pick_top_tickets_by_ev(
    score_arr: np.ndarray,
    *,
    payout_mode: str = None,
    pm: str = None,                 # 相容舊參數名
    n_tickets: int = 1,
    top_k: int = None,              # 相容舊參數名
    pool_size: int = 18,
    max_overlap: int = 5,
    lehecai_play_ks=(2, 3, 4),
    lehecai_play_k: int = None,     # 相容：只給單一 K
    lehecai_ticket_price: int = None,
    allow_duplicate: bool = False,
    rng=None,
    verbose: bool = False,
):
    """
    依「期望值 EV」從分數向量(score_arr)挑選彩券組合。
    - 支援台灣彩券(今彩539)與 樂合彩39（可選二/三/四合一）
    - 支援三環境：不同 pool_size / max_overlap / K 組合
    - 相容舊呼叫：pm= / top_k=
    """
    # --------------------------
    # 參數相容 & 預設
    # --------------------------
    if payout_mode is None:
        payout_mode = pm
    if payout_mode is None:
        payout_mode = "tw539"

    # ✅ 模式正規化（避免大小寫/空白造成 tw539 規則失效）
    _pm_norm = str(payout_mode).strip().lower()

    if top_k is not None:
        n_tickets = int(top_k)

    if lehecai_ticket_price is None:
        # 樂合彩預設每注 25；台彩今彩539預設每注 50（你原本系統的常數）
        # 這裡採用你檔案內既有常數，避免 NameError
        lehecai_ticket_price = globals().get("LEHECAI_TICKET_PRICE", 25)


    # ✅ 今彩539：每注 50（若你檔內有 TW539_TICKET_PRICE 就用它）
    if _pm_norm == "tw539":
        try:
            lehecai_ticket_price = int(globals().get("TW539_TICKET_PRICE", 50))
        except Exception:
            lehecai_ticket_price = 50

    if rng is None:
        rng = random.Random(42)

    # 若只給單一 lehecai_play_k，就覆蓋 lehecai_play_ks
    if lehecai_play_k is not None:
        lehecai_play_ks = (int(lehecai_play_k),)
    if lehecai_play_ks is None:
        lehecai_play_ks = (2, 3, 4)


    # ✅ 今彩539 固定選 5 顆：強制只枚舉 k=5（不然會出現 2/3/4 顆票）
    if _pm_norm == "tw539":
        lehecai_play_ks = (5,)

    # --------------------------
    # 準備候選 pool
    # --------------------------
    score_arr = np.asarray(score_arr).reshape(-1)
    n_nums = len(score_arr)

    # num 範圍：今彩539=1..39；樂合彩39=1..39
    all_nums = list(range(1, n_nums + 1))

    # 取分數最高的 pool_size 個號碼做候選池
    idx_sorted = sorted(all_nums, key=lambda n: (-float(score_arr[n - 1]), n))
    pool = idx_sorted[: max(5, min(pool_size, len(idx_sorted)))]
    pool_set = set(pool)

    # --------------------------
    # 枚舉候選票（組合數可控：C(18,4)=3060）
    # --------------------------
    candidates = []
    for k in lehecai_play_ks:
        k = int(k)
        if k <= 0 or k > len(pool):
            continue

        for combi in combinations(pool, k):  # ✅ 使用已匯入的 combinations
            ticket = tuple(sorted(combi))

            stat = _ticket_ev_and_stats(
                ticket_nums=ticket,
                p_vec=score_arr,                 # ✅ score_arr 就是你的機率/分數向量
                payout_mode=payout_mode,
                lehecai_play_ks=(k,),            # ✅ 單一玩法就包成 tuple
                lehecai_ticket_price=lehecai_ticket_price,
            )

            # ✅ 統一從 stat 取值（避免你前面 ev,cost,roi,meta 那套舊回傳格式）
            ev_profit = float(stat.get("ev_profit", 0.0))
            ev_cost = float(stat.get("ev_cost", 0.0))
            ev_prize = float(stat.get("ev_prize", 0.0))
            roi = (ev_profit / ev_cost) if ev_cost > 0 else 0.0

            meta = {
                "ev_hit": float(stat.get("ev_hit", 0.0)),
                "p_ge2": float(stat.get("p_ge2", 0.0)),
                "p_ge3": float(stat.get("p_ge3", 0.0)),
                "ev_prize": ev_prize,
                "ev_cost": ev_cost,
            }

            candidates.append(
                {
                    "nums": list(ticket),
                    "k": k,
                    "ev_per_draw": ev_profit,      # ✅ 用期望盈虧當 EV 排序
                    "cost": ev_cost,
                    "roi": float(roi),
                    "meta": meta,
                }
            )


    if not candidates:
        # 退化：直接挑分數前 5
        top5 = sorted(pool, key=lambda n: (-float(score_arr[n - 1]), n))[:5]
        return [{"nums": sorted(top5), "k": 5, "ev_per_draw": 0.0, "cost": 0.0, "roi": 0.0, "meta": {}}]

    # EV 由大到小
    candidates.sort(key=lambda d: (d["ev_per_draw"], d["roi"]), reverse=True)

    # --------------------------
    # 依 max_overlap 選出 n_tickets
    # --------------------------
    picked = []
    picked_sets = []

    def overlap(a_set, b_set):
        return len(a_set & b_set)

    for cand in candidates:
        cand_set = set(cand["nums"])

        if not allow_duplicate:
            # 必須在 pool 內（理論上已是）
            if not cand_set.issubset(pool_set):
                continue

        ok = True
        for ps in picked_sets:
            if overlap(cand_set, ps) > int(max_overlap):
                ok = False
                break
        if not ok:
            continue

        picked.append(cand)
        picked_sets.append(cand_set)
        if len(picked) >= int(n_tickets):
            break

    # 若因 overlap 太嚴格挑不到足夠張，就放寬（直接補最前面的）
    if len(picked) < int(n_tickets):
        for cand in candidates:
            if len(picked) >= int(n_tickets):
                break
            cand_set = set(cand["nums"])
            # 避免完全重複
            if any(cand_set == ps for ps in picked_sets):
                continue
            picked.append(cand)
            picked_sets.append(cand_set)

    if verbose:
        _print(f"[EV選票] payout_mode={payout_mode}, pool_size={pool_size}, max_overlap={max_overlap}, K={list(lehecai_play_ks)}")
        if picked:
            _print(f"[EV選票] 最佳EV={picked[0]['ev_per_draw']:.2f}, ROI={picked[0]['roi']:.2f}% -> {picked[0]['nums']}")
        else:
            _print("[EV選票] 無法產生票，已退化為 top5")

    return picked
def calc_scheme_ev_stats(
    scheme_key: str,
    *,
    pm: str,
    reco_hits: dict,
    reco_pl: dict,
    backtest_N: int,
    lehecai_play_ks=(2, 3, 4),
    lehecai_ticket_price: int = LEHECAI_TICKET_PRICE,
) -> dict:
    """
    回傳統一格式（給摘要用）：
      - per_draw_cost：每期成本
      - per_draw_ev：每期 EV（盈虧/期）
      - roi：per_draw_ev / per_draw_cost（成本=0 則 0）
      - p_ge2 / p_ge3 / avg_hit：命中統計（用 reco_hits）
    注意：
      - casino：用命中數做 EV（不算彩券盈虧）
      - tw539：用固定獎金表 LOTTO539_FIXED_PRIZE 做「回測期平均盈虧/期」
      - lehecai39：直接用 reco_pl 的 profit/cost 做「回測期平均盈虧/期」
    """
    pm = str(pm).strip().lower()
    hits_list = list((reco_hits or {}).get(str(scheme_key), []) or [])
    n = int(backtest_N) if backtest_N else len(hits_list)
    n = max(1, int(n))

    if hits_list:
        a = np.array(hits_list, dtype=np.int32)
        avg_hit = float(np.mean(a))
        p_ge2 = float(np.mean(a >= 2))
        p_ge3 = float(np.mean(a >= 3))
    else:
        avg_hit, p_ge2, p_ge3 = 0.0, 0.0, 0.0

    # --- casino：用命中數當 EV（不算彩券盈虧）---
    if pm == "casino":
        per_draw_cost = 0.0
        per_draw_ev = float(avg_hit)  # 「期望命中數」
        roi = 0.0
        return {
            "scheme": str(scheme_key),
            "mode": pm,
            "n": n,
            "per_draw_cost": float(per_draw_cost),
            "per_draw_ev": float(per_draw_ev),
            "roi": float(roi),
            "p_ge2": float(p_ge2),
            "p_ge3": float(p_ge3),
            "avg_hit": float(avg_hit),
        }

    # --- tw539：用固定獎金表算回測平均盈虧/期 ---
    if pm == "tw539":
        # 每期成本 = 50（單注）
        per_draw_cost = 50.0

        if hits_list:
            prize_list = [float(LOTTO539_FIXED_PRIZE.get(int(h), 0)) for h in hits_list]
            avg_prize = float(np.mean(prize_list)) if prize_list else 0.0
        else:
            avg_prize = 0.0

        per_draw_ev = avg_prize - per_draw_cost
        roi = (per_draw_ev / per_draw_cost) if per_draw_cost > 0 else 0.0
        return {
            "scheme": str(scheme_key),
            "mode": pm,
            "n": n,
            "per_draw_cost": float(per_draw_cost),
            "per_draw_ev": float(per_draw_ev),
            "roi": float(roi),
            "p_ge2": float(p_ge2),
            "p_ge3": float(p_ge3),
            "avg_hit": float(avg_hit),
        }

    # --- lehecai39：用 reco_pl 的累積盈虧/成本換算每期 ---
    if pm == "lehecai39":
        pl = dict((reco_pl or {}).get(str(scheme_key), {}) or {})
        total_cost = float(pl.get("cost", 0.0) or 0.0)
        total_profit = float(pl.get("profit", 0.0) or 0.0)

        per_draw_cost = total_cost / n
        per_draw_ev = total_profit / n
        roi = (per_draw_ev / per_draw_cost) if per_draw_cost > 0 else 0.0
        return {
            "scheme": str(scheme_key),
            "mode": pm,
            "n": n,
            "per_draw_cost": float(per_draw_cost),
            "per_draw_ev": float(per_draw_ev),
            "roi": float(roi),
            "p_ge2": float(p_ge2),
            "p_ge3": float(p_ge3),
            "avg_hit": float(avg_hit),
        }

    # 其他未知模式：保底
    return {
        "scheme": str(scheme_key),
        "mode": pm,
        "n": n,
        "per_draw_cost": 0.0,
        "per_draw_ev": 0.0,
        "roi": 0.0,
        "p_ge2": float(p_ge2),
        "p_ge3": float(p_ge3),
        "avg_hit": float(avg_hit),
    }

def load_penalty_from_real_results(result_file="latest_predict_result.csv"):
    """錯題本：只讀真實預測對獎結果（今彩539 => 1~39，向量長度固定 39）"""
    penalty = np.zeros(39, dtype=np.float32)  # ✅ 修正：49 -> 39
    if not os.path.exists(result_file):
        return penalty

    try:
        df = pd.read_csv(result_file, dtype=str, encoding="utf-8-sig")
    except Exception:
        return penalty

    for _, r in df.iterrows():
        pred = str(r.get("預測號碼", "")).strip()
        ans = str(r.get("開獎號碼", "")).strip()
        hit_s = str(r.get("命中數", "")).strip()
        if not pred or not ans:
            continue

        try:
            pred_nums = [int(x) for x in pred.split(",") if x.strip().isdigit()]
            ans_nums = [int(x) for x in ans.split(",") if x.strip().isdigit()]
            hit = int(hit_s) if hit_s.isdigit() else len(set(pred_nums) & set(ans_nums))
        except Exception:
            continue

        # ✅ 命中>=2 不懲罰（你的原規則保留）
        if hit >= 2:
            continue

        # ✅ 0中更重、1中稍輕（你的原規則保留）
        w = 3.0 if hit == 0 else 2.0

        miss_nums = sorted(set(pred_nums) - set(ans_nums))
        for m in miss_nums:
            if 1 <= m <= 39:
                penalty[m - 1] += w  # ✅ 0-based index, 長度 39

    return penalty


# ==============================================
# 多模型：XGB / LGBM / CatBoost / Logistic / RF（MultiOutput） + CRF
# ==============================================
def _seed(seed_offset=0):
    if USE_DETERMINISTIC:
        return int((GLOBAL_SEED + seed_offset) % (2**32 - 1))
    raw = int(time.time_ns()) + random.randint(0, 1_000_000)
    return int(raw % (2**32 - 1))


def make_base_estimator(model_name, seed_offset=0):
    n_cpu = max(1, multiprocessing.cpu_count() - 1)

    if model_name == "XGBoost":
        if not XGBOOST_AVAILABLE or XGBClassifier is None:
            raise ImportError('缺少 xgboost 套件，無法使用 XGBoost 模型')
        params_fast = dict(n_estimators=60, max_depth=3, learning_rate=0.12, subsample=0.8, colsample_bytree=0.8)
        params_full = dict(n_estimators=160, max_depth=4, learning_rate=0.10, subsample=0.9, colsample_bytree=0.9)
        params = params_fast if FAST_MODE else params_full
        return XGBClassifier(
            tree_method="hist",
            use_label_encoder=False,
            eval_metric="logloss",
            n_jobs=n_cpu,
            verbosity=0,
            random_state=_seed(seed_offset),
            **params
        )

    if model_name == "LightGBM":
        if not LIGHTGBM_AVAILABLE or LGBMClassifier is None:
            raise ImportError('缺少 lightgbm 套件，無法使用 LightGBM 模型')
        params_fast = dict(n_estimators=120, num_leaves=31, learning_rate=0.08, subsample=0.9, colsample_bytree=0.9)
        params_full = dict(n_estimators=300, num_leaves=63, learning_rate=0.06, subsample=0.9, colsample_bytree=0.9)
        params = params_fast if FAST_MODE else params_full
        return LGBMClassifier(
            **params,
            n_jobs=n_cpu,
            random_state=_seed(seed_offset),
            verbose=-1
        )

    if model_name == "CatBoost":
        if not CATBOOST_AVAILABLE or CatBoostClassifier is None:
            raise ImportError('缺少 catboost 套件，無法使用 CatBoost 模型')
        params_fast = dict(iterations=120, depth=4, learning_rate=0.12)
        params_full = dict(iterations=500, depth=5, learning_rate=0.10)
        params = params_fast if FAST_MODE else params_full

        run_dir = os.path.join(catboost_train_dir, f"run_{os.getpid()}_{int(time.time() * 1000)}")
        os.makedirs(run_dir, exist_ok=True)

        return CatBoostSklearnCompat(
            task_type="CPU",
            thread_count=n_cpu,
            verbose=0,
            train_dir=run_dir,
            allow_writing_files=True,
            random_seed=_seed(seed_offset),
            **params
        )

    if model_name == "Logistic":
        max_iter = 3000 if FAST_MODE else 8000
        tol = 1e-3 if FAST_MODE else 5e-4
        base_lr = LogisticRegression(
            C=1.0,
            max_iter=max_iter,
            tol=tol,
            solver="saga",
            penalty="l2",
            n_jobs=1
        )
        return Pipeline([("scaler", StandardScaler()), ("clf", base_lr)])

    if model_name == "RandomForest":
        params_fast = dict(n_estimators=80, max_depth=7)
        params_full = dict(n_estimators=200, max_depth=None)
        params = params_fast if FAST_MODE else params_full
        return RandomForestClassifier(
            **params,
            n_jobs=n_cpu,
            random_state=_seed(seed_offset)
        )

    raise ValueError("Unknown model")


def make_multi_model(model_name, seed_offset=0):
    base = make_base_estimator(model_name, seed_offset=seed_offset)
    return MultiOutputClassifier(base, n_jobs=1)


def proba_from_multioutput(mo_clf, X_pred_row):
    probas = []
    for est in mo_clf.estimators_:
        p = est.predict_proba(X_pred_row)
        probas.append(float(p[0, 1]) if p.shape[1] == 2 else float(p[0, 0]))
    return np.array(probas, dtype=np.float32)


# ==============================================
# CRF：每期一條序列（1~39）
# ==============================================
def crf_token_features_from_row(row, n):
    fmt = f"{n:02d}"
    return {
        "n": n,
        "n_mod10": n % 10,
        "n_bin": n // 10,
        "hot_all": float(row.get(f"hot_{fmt}_all", 0.0)),
        "hot_5": float(row.get(f"hot_{fmt}_5", 0.0)),
        "hot_10": float(row.get(f"hot_{fmt}_10", 0.0)),
        "hot_20": float(row.get(f"hot_{fmt}_20", 0.0)),
        "hot_30": float(row.get(f"hot_{fmt}_30", 0.0)),
        "miss": float(row.get(f"miss_{fmt}", 0.0)),
        "odd_cnt": int(row.get("odd_count", 0)),
        "even_cnt": int(row.get("even_count", 0)),
        "serial_cnt": int(row.get("serial_count", 0)),
        "repeat_prev": int(row.get("repeat_prev", 0)),
        "big_small": float(row.get("big_small_score", 0.0)),
    }


def build_crf_seq_features(X_bt, idx):
    row = X_bt.iloc[idx]
    return [crf_token_features_from_row(row, n) for n in range(1, 40)]


def build_crf_labels(y_all, idx):
    row = y_all.iloc[idx]
    return ['1' if int(row[f"y_{n:02d}"]) == 1 else '0' for n in range(1, 40)]


def fit_crf(X_bt, y_all, start_idx, end_idx):
    X_seqs = [build_crf_seq_features(X_bt, t) for t in range(start_idx, end_idx)]
    y_seqs = [build_crf_labels(y_all, t) for t in range(start_idx, end_idx)]
    max_iter = 60 if FAST_MODE else 150
    crf = sklearn_crfsuite.CRF(
        algorithm='lbfgs',
        c1=0.1, c2=0.1,
        max_iterations=max_iter,
        all_possible_transitions=True
    )
    with suppress_all_output(True):
        crf.fit(X_seqs, y_seqs)
    return crf


def crf_predict_proba(crf, X_bt, idx):
    feats = build_crf_seq_features(X_bt, idx)
    marginals = crf.predict_marginals_single(feats)
    probs = [float(m.get('1', 0.0)) for m in marginals]
    return np.array(probs, dtype=np.float32)


# ==============================================
# 版路拖牌：原功能保留（你的函式群，完整保留）
# ==============================================
def _build_rows_for_mode(df_bt_use, nums, mode):
    if mode == "size":
        return [sorted(int(row[c]) for c in nums) for _, row in df_bt_use.iterrows()]
    if mode == "order":
        cols = [f"落序號碼{i}" for i in range(1, 6)]
        return df_bt_use[cols].astype(int).values.tolist()
    raise ValueError("mode must be 'size' or 'order'")


def _analyze_pattern_unpos_next(seqs, dates, A, B, lag, last_base_idx):
    N = len(seqs)
    if N <= lag or last_base_idx < 0 or last_base_idx >= N:
        return None
    if A not in set(seqs[last_base_idx]):
        return None

    events = []
    for base_idx in range(0, N - lag):
        if A not in set(seqs[base_idx]):
            continue
        drag_idx = base_idx + lag
        is_success = (B in set(seqs[drag_idx]))
        events.append((base_idx, drag_idx, is_success))

    if not events:
        return None

    success_count = sum(1 for e in events if e[2])
    fail_count = len(events) - success_count
    if success_count < MIN_CHAIN_RUN:
        return None

    valid_events = [e for e in events if e[0] < last_base_idx]
    if not valid_events:
        return None
    valid_events.sort(key=lambda x: x[0], reverse=True)

    chain_run = 0
    tail_events = []
    for base_idx, drag_idx, is_success in valid_events:
        tail_events.append((base_idx, drag_idx, is_success))
        if is_success:
            chain_run += 1
        else:
            break
    if chain_run < MIN_CHAIN_RUN:
        return None

    total_events = success_count + fail_count
    success_rate = success_count / total_events if total_events > 0 else 0.0

    last_success_drag_date = None
    for base_idx, drag_idx, is_success in valid_events:
        if is_success:
            last_success_drag_date = dates[drag_idx]
            break

    return {
        "A": A, "B": B, "lag": lag,
        "chain_run": chain_run,
        "last_base_date": dates[last_base_idx],
        "last_success_drag_date": last_success_drag_date,
        "success_count": success_count,
        "fail_count": fail_count,
        "success_rate": success_rate,
        "tail_events": tail_events[:50],
        "predict_target": "NEXT"
    }


def _analyze_pattern_pos_next(seqs, dates, A, B, lag, pos_a, pos_b, last_base_idx):
    N = len(seqs)
    if N <= lag or last_base_idx < 0 or last_base_idx >= N:
        return None
    if seqs[last_base_idx][pos_a] != A:
        return None

    events = []
    for base_idx in range(0, N - lag):
        if seqs[base_idx][pos_a] != A:
            continue
        drag_idx = base_idx + lag
        is_success = (seqs[drag_idx][pos_b] == B)
        events.append((base_idx, drag_idx, is_success))

    if not events:
        return None

    success_count = sum(1 for e in events if e[2])
    fail_count = len(events) - success_count
    if success_count < MIN_CHAIN_RUN:
        return None

    valid_events = [e for e in events if e[0] < last_base_idx]
    if not valid_events:
        return None
    valid_events.sort(key=lambda x: x[0], reverse=True)

    chain_run = 0
    tail_events = []
    for base_idx, drag_idx, is_success in valid_events:
        tail_events.append((base_idx, drag_idx, is_success))
        if is_success:
            chain_run += 1
        else:
            break
    if chain_run < MIN_CHAIN_RUN:
        return None

    total_events = success_count + fail_count
    success_rate = success_count / total_events if total_events > 0 else 0.0

    last_success_drag_date = None
    for base_idx, drag_idx, is_success in valid_events:
        if is_success:
            last_success_drag_date = dates[drag_idx]
            break

    return {
        "A": A, "B": B, "lag": lag,
        "pos_a": pos_a, "pos_b": pos_b,
        "chain_run": chain_run,
        "last_base_date": dates[last_base_idx],
        "last_success_drag_date": last_success_drag_date,
        "success_count": success_count,
        "fail_count": fail_count,
        "success_rate": success_rate,
        "tail_events": tail_events[:50],
        "predict_target": "NEXT"
    }


def _format_unpos_block_next(label, res, dates):
    A = res["A"]; B = res["B"]; lag = res["lag"]
    chain_run = res["chain_run"]
    base_date = res["last_base_date"]
    last_success_drag_date = res["last_success_drag_date"]
    sc = res["success_count"]; fc = res["fail_count"]
    total = sc + fc
    rate = sc / total if total > 0 else 0.0

    lines = []
    lines.append(label)
    lines.append(f"【預測目標】以最新開獎日 {base_date} 為起點 → 預測隔 {lag} 期可能拖出")
    lines.append(f"起始牌(A)：{A:02d}")
    lines.append(f"拖牌(B)：{B:02d}")
    lines.append("")
    lines.append("--- 近期連版（由近到遠，最後一次為可驗證歷史）---")

    for base_idx, drag_idx, is_success in res["tail_events"]:
        base_d = dates[base_idx]
        drag_d = dates[drag_idx]
        mark = "✔" if is_success else "✖"
        extra = "   ← 斷點" if (not is_success) else ""
        lines.append(
            f"{base_d} 出現A {A:02d} → {drag_d} "
            f"{'出現' if is_success else '未出現'}B {B:02d} {mark}{extra}"
        )

    lines.append("")
    lines.append(f"近期連版：{chain_run} 次（最近連續 {chain_run} 次 A 出現後，隔 {lag} 期都有出 B）")
    if last_success_drag_date is not None:
        lines.append(f"最近一次成功拖出日期：{last_success_drag_date}")
    lines.append(f"成功紀錄共：{sc} 次")
    lines.append(f"失敗紀錄共：{fc} 次")
    lines.append(f"成功率：{sc} / {total} = {rate * 100:.1f}%")
    lines.append("--------------------------------")
    return "\n".join(lines)


def _format_pos_block_next(label, res, dates):
    A = res["A"]; B = res["B"]; lag = res["lag"]
    chain_run = res["chain_run"]
    base_date = res["last_base_date"]
    last_success_drag_date = res["last_success_drag_date"]
    sc = res["success_count"]; fc = res["fail_count"]
    total = sc + fc
    rate = sc / total if total > 0 else 0.0
    pos_a = res["pos_a"] + 1
    pos_b = res["pos_b"] + 1

    lines = []
    lines.append(label)
    lines.append(f"【預測目標】以最新開獎日 {base_date} 為起點 → 預測隔 {lag} 期可能拖出")
    lines.append(f"起始牌(A)：{A:02d}")
    lines.append(f"拖牌(B)：{B:02d}")
    lines.append(f"定位：起牌第 {pos_a} 球 → 拖牌第 {pos_b} 球")
    lines.append("")
    lines.append("--- 近期連版（由近到遠）---")

    for base_idx, drag_idx, is_success in res["tail_events"]:
        base_d = dates[base_idx]
        drag_d = dates[drag_idx]
        mark = "✔" if is_success else "✖"
        extra = "   ← 斷點" if (not is_success) else ""
        lines.append(
            f"{base_d} (第{pos_a}球)=A {A:02d} → {drag_d} "
            f"{'出現' if is_success else '未出現'}(第{pos_b}球)=B {B:02d} {mark}{extra}"
        )

    lines.append("")
    lines.append(f"近期連版：{chain_run} 次")
    if last_success_drag_date is not None:
        lines.append(f"最近一次成功拖出日期：{last_success_drag_date}")
    lines.append(f"成功紀錄共：{sc} 次")
    lines.append(f"失敗紀錄共：{fc} 次")
    lines.append(f"成功率：{sc} / {total} = {rate * 100:.1f}%")
    lines.append("--------------------------------")
    return "\n".join(lines)

def analyze_drag_layers(drag_results):
    """
    回傳：
      layer2_txt: str
      layer3_txt: str
      prob_rank: list[(n, sc, total, rate, score)]
      mark_level: dict[int, int]  # 0/2/3
    保證：任何情況都回傳 4 個值
    """

    layer2_txt = ""
    layer3_txt = ""
    prob_rank = []
    mark_level = {}

    if not drag_results:
        return layer2_txt, layer3_txt, prob_rank, mark_level

    best_chain = {}
    prob_stats = {}

    for r in drag_results:
        try:
            n = int(r.get("B", 0))
            chain = int(r.get("chain_run", 0))
            sc = int(r.get("success_count", 0))
            fc = int(r.get("fail_count", 0))
        except Exception:
            continue

        if n <= 0:
            continue

        total = sc + fc
        best_chain[n] = max(best_chain.get(n, 0), chain)
        old_sc, old_total = prob_stats.get(n, (0, 0))
        prob_stats[n] = (old_sc + sc, old_total + total)

    layer2 = sorted([n for n, c in best_chain.items() if c == 2])
    layer3 = sorted([n for n, c in best_chain.items() if c >= 3])

    if layer2:
        layer2_txt = "[" + ", ".join(f"{n:02d}" for n in layer2) + "]"
    if layer3:
        layer3_txt = "[" + ", ".join(f"{n:02d}" for n in layer3) + "]"

    method = str(globals().get("DRAG_PROB_METHOD", "wilson")).strip().lower()
    z = float(globals().get("DRAG_PROB_Z", 1.96))
    min_total = int(globals().get("DRAG_PROB_MIN_TOTAL", 0))
    min_success = int(globals().get("DRAG_PROB_MIN_SUCCESS", 0))

    for n, (sc, total) in prob_stats.items():
        if total <= 0:
            continue
        if total < min_total or sc < min_success:
            continue
        rate = float(sc) / float(total)
        score = rate if method == "rate" else _wilson_lower_bound(sc, total, z=z)
        prob_rank.append((n, sc, total, rate, score))

    prob_rank.sort(key=lambda x: (x[4], x[2], x[1], -x[0]), reverse=True)

    for n, c in best_chain.items():
        mark_level[n] = 3 if c >= 3 else (2 if c == 2 else 0)

    return layer2_txt, layer3_txt, prob_rank, mark_level


def _wilson_lower_bound(success: int, total: int, z: float = 1.96) -> float:
    """Wilson score interval lower bound（避免小樣本假高）"""
    if total <= 0:
        return 0.0
    phat = float(success) / float(total)
    z2 = float(z) * float(z)
    denom = 1.0 + z2 / float(total)
    center = phat + z2 / (2.0 * float(total))
    margin = float(z) * math.sqrt((phat * (1.0 - phat) + z2 / (4.0 * float(total))) / float(total))
    lb = (center - margin) / denom
    if lb < 0.0:
        return 0.0
    if lb > 1.0:
        return 1.0
    return float(lb)


def build_drag_bonus_map_from_prob_rank(prob_rank, *, topk=12, min_total=20, min_success=3,
                                        method="wilson", z=1.96):
    """
    prob_rank 支援：
      - 舊版：[(n, sc, total, rate), ...]
      - 新版：[(n, sc, total, rate, score), ...]
    回傳：bonus_map{num->bonus(0..1)}, picked_list
    """
    rows = []
    method = str(method).strip().lower()

    for r in (prob_rank or []):
        if not r:
            continue
        if len(r) == 4:
            n, sc, total, rate = r
            n = int(n); sc = int(sc); total = int(total); rate = float(rate)
            if total < int(min_total) or sc < int(min_success):
                continue
            score = rate if method == "rate" else _wilson_lower_bound(sc, total, z=float(z))
            rows.append((n, sc, total, rate, score))
        else:
            n = int(r[0]); sc = int(r[1]); total = int(r[2]); rate = float(r[3]); score = float(r[4])
            if total < int(min_total) or sc < int(min_success):
                continue
            if method == "rate":
                score = rate
            rows.append((n, sc, total, rate, score))

    rows.sort(key=lambda x: (x[4], x[2], x[1], -x[0]), reverse=True)
    rows = rows[: int(topk)]

    if not rows:
        return {}, []

    scores = [x[4] for x in rows]
    smin, smax = float(min(scores)), float(max(scores))
    denom = (smax - smin) if (smax > smin) else 1.0

    bonus_map = {}
    picked = []
    for (n, sc, total, rate, score) in rows:
        bonus = (float(score) - smin) / denom
        bonus_map[int(n)] = float(bonus)
        picked.append(int(n))

    return bonus_map, picked


def build_drag_bonus_map_from_overview(overview_nums, *, topk=12):
    """
    overview_nums: list[int]（來自 📌版路拖牌總覽）
    回傳：bonus_map{num->bonus(0..1)} / picked list
    """
    nums = [int(x) for x in (overview_nums or []) if 1 <= int(x) <= 39]
    # 去重保序
    nums = list(dict.fromkeys(nums))
    nums = nums[: int(topk)]

    if not nums:
        return {}, []

    k = len(nums)
    bonus_map = {}
    for i, n in enumerate(nums):
        bonus = 1.0 if k == 1 else (1.0 - (i / (k - 1)))
        bonus_map[int(n)] = float(bonus)

    return bonus_map, nums


def apply_drag_bonus_to_scores(scores_39, bonus_map):
    """scores_39: array-like len=39; bonus_map: {num->bonus}"""
    s = np.asarray(scores_39, dtype=np.float32).copy()
    if not bonus_map:
        return s

    for n, b in bonus_map.items():
        idx = int(n) - 1
        if 0 <= idx < 39:
            s[idx] += float(b)
    return s



def compute_drag_notebooks(df_bt, nums, predict_lags=1):
    if not DRAG_ENABLE:
        msg = "（未啟用版路拖牌功能 DRAG_ENABLE=False）\n"
        return msg, msg, msg, msg, set(), []

    # ✅ 快取：同一份資料/同一組 lags 重跑時直接回傳（避免重複計算拖牌筆記本）
    try:    
        if isinstance(predict_lags, (list, tuple, set, np.ndarray)):
            _lag_list = sorted({int(x) for x in predict_lags if str(x).strip().isdigit() and int(x) >= 1})
        else:
            _lag_list = [int(predict_lags)]
        if not _lag_list:
            _lag_list = [1]
    except Exception:
        _lag_list = [1]

    try:
        _last_date = df_bt["日期"].iloc[-1].date() if ("日期" in df_bt.columns and len(df_bt) > 0) else None
    except Exception:
        _last_date = None

    _cache_key = (int(len(df_bt)) if df_bt is not None else -1, _last_date, tuple(_lag_list), int(DRAG_MAX_ROWS), int(MIN_CHAIN_RUN))

    _DRAG_CACHE = {}

    if _cache_key in _DRAG_CACHE:
        return _DRAG_CACHE[_cache_key]

    def _ensure_not_empty(txt, title, lag_list):
        if txt is None or str(txt).strip() == "":
            return (
                f"{title}\n"
                f"搜尋不到拖牌資訊（條件過嚴或樣本不足）。\n"
                f"（目前設定：預測隔 {lag_list} 期、MIN_CHAIN_RUN={MIN_CHAIN_RUN}）\n"
            )
        return txt

    try:
        if DRAG_MAX_ROWS is not None and len(df_bt) > DRAG_MAX_ROWS:
            df_bt_use = df_bt.tail(DRAG_MAX_ROWS).reset_index(drop=True)
        else:
            df_bt_use = df_bt.copy().reset_index(drop=True)

        if len(df_bt_use) < 2:
            msg = "資料不足，無法計算拖牌（至少需要 2 期以上）。\n"
            return msg, msg, msg, msg, set(), []

        dates = df_bt_use["日期"].dt.date.tolist()
        last_base_idx = len(dates) - 1
        last_base_date = dates[last_base_idx]

        if isinstance(predict_lags, (list, tuple, set, np.ndarray)):
            lag_list = sorted({int(x) for x in predict_lags if str(x).strip().isdigit() and int(x) >= 1})
        else:
            lag_list = [int(predict_lags)]
        if not lag_list:
            lag_list = [1]

        print(f"\n==== 開始計算版路拖牌（以最新開獎日為起點：{last_base_date}，預測隔 {lag_list} 期）====")
        t0 = time.time()

        size_seqs = _build_rows_for_mode(df_bt_use, nums, mode="size")
        order_seqs = _build_rows_for_mode(df_bt_use, nums, mode="order")

        drag_nums_size_unpos = set()
        drag_nums_size_pos = set()
        drag_nums_order_unpos = set()
        drag_nums_order_pos = set()

        drag_result = []

        def _append_drag_results(results_list, src_name):
            for r in results_list:
                try:
                    drag_result.append({
                        "B": int(r.get("B")),
                        "chain_run": int(r.get("chain_run", 0)),
                        "lag": int(r.get("lag", 0)),
                        "src": str(src_name),
                        "success_count": int(r.get("success_count", 0)),
                        "fail_count": int(r.get("fail_count", 0)),
                    })
                except Exception:
                    continue

        def build_unpos_notebook_next(seqs, label_header, collect_set):
            results = []
            base_row = seqs[last_base_idx]
            base_set = set(base_row)

            for lag in lag_list:
                for A in sorted(base_set):
                    for B in range(1, 40):
                        res = _analyze_pattern_unpos_next(seqs, dates, A, B, lag, last_base_idx)
                        if res is not None:
                            results.append(res)
                            collect_set.add(B)

            results.sort(key=lambda r: (r["lag"], -r["chain_run"], -r["success_rate"], r["A"], r["B"]))
            blocks = [_format_unpos_block_next(label_header, r, dates) for r in results]
            return "\n\n".join(blocks), results

        def build_pos_notebook_next(seqs, label_header, collect_set):
            results = []
            base_row = seqs[last_base_idx]

            for lag in lag_list:
                for pos_a, A in enumerate(base_row):
                    for pos_b in range(5):
                        for B in range(1, 40):
                            res = _analyze_pattern_pos_next(seqs, dates, A, B, lag, pos_a, pos_b, last_base_idx)
                            if res is not None:
                                results.append(res)
                                collect_set.add(B)

            results.sort(key=lambda r: (r["lag"], -r["chain_run"], -r["success_rate"], r["A"], r["B"]))
            blocks = [_format_pos_block_next(label_header, r, dates) for r in results]
            return "\n\n".join(blocks), results

        txt_size_unpos, res_size_unpos = build_unpos_notebook_next(size_seqs, "【大小序 / 不定位】", drag_nums_size_unpos)
        txt_size_pos,   res_size_pos   = build_pos_notebook_next(size_seqs, "【大小序 / 定位】",   drag_nums_size_pos)
        txt_order_unpos, res_order_unpos = build_unpos_notebook_next(order_seqs, "【落球序 / 不定位】", drag_nums_order_unpos)
        txt_order_pos,  res_order_pos  = build_pos_notebook_next(order_seqs, "【落球序 / 定位】",   drag_nums_order_pos)

        _append_drag_results(res_size_unpos,  "size_unpos")
        _append_drag_results(res_size_pos,    "size_pos")
        _append_drag_results(res_order_unpos, "order_unpos")
        _append_drag_results(res_order_pos,   "order_pos")

        txt_size_unpos = _ensure_not_empty(txt_size_unpos, "【大小序 / 不定位】", lag_list)
        txt_size_pos   = _ensure_not_empty(txt_size_pos,   "【大小序 / 定位】",   lag_list)
        txt_order_unpos = _ensure_not_empty(txt_order_unpos, "【落球序 / 不定位】", lag_list)
        txt_order_pos  = _ensure_not_empty(txt_order_pos,  "【落球序 / 定位】",   lag_list)

        drag_hint_nums_all = (drag_nums_size_unpos | drag_nums_size_pos | drag_nums_order_unpos | drag_nums_order_pos)

        t1 = time.time()
        print(f"版路拖牌計算完成，耗時約 {t1 - t0:.2f} 秒。")
        _ret = (txt_size_unpos, txt_size_pos, txt_order_unpos, txt_order_pos, drag_hint_nums_all, drag_result)
        {}[_cache_key] = _ret
        return _ret


    except Exception as e:
        err = f"版路拖牌計算發生例外：{type(e).__name__}: {e}\n"
        msg = "搜尋不到拖牌資訊（執行時發生例外）。\n" + err
        return msg, msg, msg, msg, set(), []


# ==============================================
# 推估下一次開獎日（週一~週六）+ 公告校正
# ==============================================
def _parse_dates_from_text(text):
    if not text:
        return set()

    found = set()

    for m in re.findall(r"(20\d{2})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})", text):
        y, mo, d = int(m[0]), int(m[1]), int(m[2])
        try:
            found.add(datetime(y, mo, d).date())
        except Exception:
            pass

    for m in re.findall(r"(\d{2,3})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})", text):
        yy, mo, d = int(m[0]), int(m[1]), int(m[2])
        if 1 <= yy <= 199:
            y = yy + 1911
            try:
                found.add(datetime(y, mo, d).date())
            except Exception:
                pass

    return found


def fetch_twlottery_announcement_dates_539(lookahead_days=45, *, status_cb=None, max_total_sec=8.0):
    candidate_urls = [
        "https://www.taiwanlottery.com.tw/",
        "https://www.taiwanlottery.com.tw/Upload/",
        "https://www.taiwanlottery.com.tw/lotto/Lotto539/history.aspx",
        "https://www.taiwanlottery.com.tw/News/News.aspx",
        "https://www.taiwanlottery.com.tw/News/NewsList.aspx",
    ]

    t0 = time.time()
    all_dates = set()
    total = len(candidate_urls)

    for k, url in enumerate(candidate_urls, 1):
        # ✅ 總耗時上限：避免網路差時卡太久
        if (time.time() - t0) >= float(max_total_sec):
            break

        msg = f"查詢台彩公告網址 ({k}/{total})"
        if status_cb:
            try:
                status_cb(msg)
            except Exception:
                pass
        if bool(globals().get("GUI_VERBOSE_STAGE", True)):
            print(msg)

        html = _fetch_text(url, timeout=6)
        if not html:
            continue
        all_dates |= _parse_dates_from_text(html)

    today = datetime.now().date()
    upper = today + timedelta(days=int(lookahead_days))
    all_dates = {d for d in all_dates if today <= d <= upper}
    all_dates = {d for d in all_dates if d.weekday() != 6}  # 排除週日
    return all_dates


def infer_next_draw_date_tw539_with_announcement(past_dates, *, status_cb=None):
    now_date = datetime.now().date()
    base = now_date if (not past_dates) else past_dates[-1]
    s = set(past_dates) if past_dates else set()

    # 先用「不重複且非週日」的 cand 當保底答案
    cand = base + timedelta(days=1)
    for _ in range(60):
        if cand.weekday() != 6 and cand not in s:
            break
        cand += timedelta(days=1)

    t0 = time.time()
    if status_cb:
        try:
            status_cb("查詢台彩公告中（若網路慢會自動跳過）")
        except Exception:
            pass
    if bool(globals().get("GUI_VERBOSE_STAGE", True)):
        print("==== 查詢台彩公告中（若網路慢會自動跳過） ====")

    try:
        announced = fetch_twlottery_announcement_dates_539(
            lookahead_days=60,
            status_cb=status_cb,
            max_total_sec=float(globals().get("ANNOUNCE_FETCH_MAX_SEC", 8.0)),
        )
    except Exception:
        announced = set()

    if bool(globals().get("GUI_VERBOSE_STAGE", True)):
        print(f"==== 公告查詢完成，耗時 {time.time()-t0:.2f} 秒 ====")

    candidates = set([cand]) | set(announced)
    future_candidates = sorted([d for d in candidates if d > now_date])
    return future_candidates[0] if future_candidates else cand


# ==============================================
# Walk-forward：訓練/預測封裝
# ==============================================
def fit_model_for_i(model_name, X_bt, y_all, base_columns, start_idx, i, seed_offset=0, *, status_cb=None):

    # 大重點：讓 GUI/console 看起來有段落、不黏字
    def _fmt_fit_msg(stage: str, *, dt: float = None) -> str:
        name = f"{model_name:<12}"  # 讓 'Logistic' / 'RandomForest' 對齊更好看
        idx_s = f"idx {start_idx:>4}..{i:>4}"
        n_s = f"n={i-start_idx+1:>4}"

        if stage == "start":
            # ✅ 你要的格式：印完 FIT 後「空一行」
            return f"\n[FIT] {name} | {idx_s} | {n_s}"

        if stage == "done":
            # ✅ done 也獨立一行結尾，避免跟後面黏住
            return f"[FIT] {name} | {idx_s} | {n_s} | done {float(dt or 0.0):>6.2f}s"

        return f"[FIT] {name} | {idx_s} | {n_s} | {stage}"


    def _log(msg: str):
        if not bool(globals().get('GUI_VERBOSE_STAGE', True)):
            return
        if status_cb:
            try:
                status_cb(msg)   # ✅ 外層可用 tqdm.write 或 GUI queue，避免打斷進度條
                return
            except Exception:
                pass
        print(msg)               # fallback（沒有 tqdm/GUI 時）

    _t0 = time.time()

    # ✅ 只在模型開始時印一次 FIT
    _log(_fmt_fit_msg("start"))

    if model_name == "CRF":
        if not CRF_AVAILABLE:
            raise RuntimeError("CRF 模型未安裝 sklearn_crfsuite")
        mo = fit_crf(X_bt, y_all, start_idx, i)
        return mo


    y_cols = [f"y_{k:02d}" for k in range(1, 40)]
    X_train = fix_columns(X_bt.iloc[start_idx:i], base_columns)
    y_train = y_all[y_cols].iloc[start_idx:i]

    mo = make_multi_model(model_name, seed_offset=seed_offset)
    with suppress_all_output(True):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            mo.fit(X_train, y_train)

    # _dt = time.time() - _t0      # ⛔ 不再印 done
    return mo


def predict_scores_for_i(model_name, model_obj, X_bt, base_columns, i):
    """
    單期預測機率輸出（統一入口）
    """
    if model_name == "CRF":
        with suppress_all_output(True):
            return crf_predict_proba(model_obj, X_bt, i)

    X_pred = fix_columns(X_bt.iloc[[i]], base_columns)
    with suppress_all_output(True):
        return proba_from_multioutput(model_obj, X_pred)



# ==============================================
# 核心流程：GUI 呼叫
# ==============================================
def run_pipeline(
    backtest_N: int,
    BACKTEST_TOP_N: int,
    PRED_TOP_N: int,
    control: RunControl,
    payout_mode: str,
    lehecai_play_ks=(2, 3, 4),
    gui_queue: queue.Queue = None,
):
    warnings.simplefilter(action="ignore", category=FutureWarning)
    warnings.simplefilter(action="ignore", category=pd.errors.SettingWithCopyWarning)

    q = gui_queue  # GuiTqdm 用
    pm = str(payout_mode).strip().lower()

    pm_label = {
        "casino": "線上娛樂城",
        "tw539": "台灣彩券（今彩539）",
        "lehecai39": "台灣彩券（39樂合彩）",
    }.get(pm, "線上娛樂城")

    if BACKTEST_TOP_N <= 0 or BACKTEST_TOP_N > 39 or PRED_TOP_N <= 0 or PRED_TOP_N > 39:
        raise ValueError("TOP_N 數量需介於 1 ~ 39 之間。")

    n_cpu_all = multiprocessing.cpu_count()
    print(f"本機核心數：{n_cpu_all} 核心")
    print(f"彩金模式：{pm_label}")

    # 0~12：下載/對獎
    control.set_status("下載/載入官方資料")
    control.set_progress(2)
    control.check_pause_stop()
    print("下載/載入官方資料...")
    df = load_tw539(force_download=True)
    control.set_progress(10)

    # ✅ 顯示『抓官方日期』：資料抓取時間 + 最新開獎日期（以資料檔最新一期為準）
    try:
        src = str(df.attrs.get("fetch_source", ""))
        ft  = str(df.attrs.get("fetch_time", ""))
        ld  = str(df.attrs.get("latest_draw_date", ""))
        li  = str(df.attrs.get("latest_issue", ""))
        if src or ft or ld or li:
            if src:
                print(f"✅ 資料來源：{src}")
            if ft:
                print(f"✅ 資料抓取時間：{ft}")
            if ld or li:
                print(f"✅ 官方最新開獎日期：{ld}（期數 {li}）")
            print("")
    except Exception:
        pass

    nums = ["正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"]


    def pretty_print_row(row, title=""):
        print(f"{Fore.LIGHTYELLOW_EX}==== {title} ===={Style.RESET_ALL}")
        print(f"{Fore.LIGHTCYAN_EX}日期        {pd.to_datetime(row['日期']).strftime('%Y-%m-%d')}{Style.RESET_ALL}")
        print(f"{Fore.LIGHTCYAN_EX}期數        {int(row['期數'])}{Style.RESET_ALL}")
        print(f"{Fore.LIGHTWHITE_EX}落序號碼1~5  ", end="")
        for i in range(1, 6):
            print(f"{int(row[f'落序號碼{i}']):02d} ", end="")
        print(Style.RESET_ALL)
        print(f"{Fore.LIGHTWHITE_EX}正序號碼1~5  ", end="")
        for i in range(1, 6):
            print(f"{int(row[f'正序號碼{i}']):02d} ", end="")
        print(Style.RESET_ALL)
        print()

    pretty_print_row(df.iloc[0], "第一筆資料")
    pretty_print_row(df.iloc[-1], "最後一筆資料")
    print(f"{Fore.LIGHTGREEN_EX}==== 全部期數：{len(df)} 筆 ===={Style.RESET_ALL}\n")

    control.set_status("自動對獎（若有 latest_predict.csv）")
    control.set_progress(12)
    control.check_pause_stop()
    try_save_latest_prediction_result(df, nums)

    # 12~30：建特徵
    control.set_status("建特徵（一次建滿）")
    control.set_progress(15)
    control.check_pause_stop()
    X_full, base_columns, _, _ = build_full_features_once(df, control=control)
    control.set_progress(30)

    X_bt = X_full.reset_index(drop=True)
    df_bt = df.reset_index(drop=True)

    future_open = df[nums].shift(-1)
    y_all = pd.DataFrame(
        {f"y_{i:02d}": future_open.apply(lambda x, i=i: int(i in x.values), axis=1).astype(np.int8)
         for i in range(1, 40)}
    ).reset_index(drop=True)

    num_rows = X_bt.shape[0]
    feature_row_count = num_rows - 1
    if feature_row_count < backtest_N or backtest_N <= 0:
        raise ValueError(f"【錯誤】可回測期數 ({feature_row_count}) 必須大於回測期數 ({backtest_N})！")

    backtest_indexes = list(range(feature_row_count - backtest_N, feature_row_count))
    backtest_eval_start_date = df_bt.iloc[backtest_indexes[0] + 1]["日期"].date()
    backtest_eval_end_date = df_bt.iloc[backtest_indexes[-1] + 1]["日期"].date()
    print(f"==== 回測評估日期（實際被預測的開獎日）: {backtest_eval_start_date} ~ {backtest_eval_end_date} ====")

    latest_issue = int(df_bt.iloc[-1]["期數"])
    predict_next_issue = latest_issue + 1
    predict_next_date = infer_next_draw_date_tw539_with_announcement(df_bt["日期"].dt.date.tolist())
    print(f"==== 預測下一期：期數 {predict_next_issue} / 日期（估計）{predict_next_date} ====")
    print(f"==== Walk-forward：每 {WALK_FORWARD_RETRAIN_INTERVAL} 期重訓一次（K={WALK_FORWARD_RETRAIN_INTERVAL}） ====")

    # 30~50：拖牌
    control.set_status("計算版路拖牌")
    control.set_progress(33)
    control.check_pause_stop()

    drag_hint_nums_all = set()
    mark_level = {}
    if DRAG_ENABLE:
        drag_bonus_map = {}
        drag_topk_nums = []

        txt_size_unpos, txt_size_pos, txt_order_unpos, txt_order_pos, drag_hint_nums_all, drag_result = compute_drag_notebooks(
            df_bt, nums, predict_lags=DRAG_PREDICT_LAGS
        )

        files_and_txt = [
            ("版路拖牌_順球_未定位.txt", txt_size_unpos),
            ("版路拖牌_順球_定位.txt", txt_size_pos),
            ("版路拖牌_落球_未定位.txt", txt_order_unpos),
            ("版路拖牌_落球_定位.txt", txt_order_pos),
        ]
        for fname, content in files_and_txt:
            with open(fname, "w", encoding="utf-8-sig") as f:
                f.write(content)

        print("版路拖牌筆記本已輸出為：版路拖牌_順球_未定位.txt / 版路拖牌_順球_定位.txt / 版路拖牌_落球_未定位.txt / 版路拖牌_落球_定位.txt")

        if drag_hint_nums_all:
            print("\n📌 版路拖牌總覽：[" + ", ".join(f"{n:02d}" for n in sorted(drag_hint_nums_all)) + "]")
            layer2, layer3, prob_rank, mark_level = analyze_drag_layers(drag_result)
        
            print("\n🎯 最近 連 2 版拖牌號碼：")
            print(layer2 if layer2 else "（無）")
        
            print("\n🔥 最近 連 ≥3 版拖牌號碼：")
            print(layer3 if layer3 else "（無）")
    
        
            print("\n📊 拖牌版路機率（穩健篩選後，高 → 低）：")
            if prob_rank:
                method = str(globals().get("DRAG_PROB_METHOD", "wilson")).strip().lower()
                z = float(globals().get("DRAG_PROB_Z", 1.96))
                min_total = int(globals().get("DRAG_PROB_MIN_TOTAL", 0))
                min_success = int(globals().get("DRAG_PROB_MIN_SUCCESS", 0))
                topk = int(globals().get("DRAG_PROB_TOPK", 30))
                tag = "Wilson下界" if method != "rate" else "成功率"
                extra = f"（篩選：total≥{min_total}, success≥{min_success}；排序：{tag}）"
                if method != "rate":
                    extra += f"（z={z:.2f}）"
                print(extra)
                for n, sc, total, rate, score in prob_rank[:topk]:
                    if method == "rate":
                        print(f"號碼 {n:02d}｜命中 {sc} / {total}｜歷史 {DRAG_MAX_ROWS}期 成功率 {rate*100:.0f}%")
                    else:
                        print(f"號碼 {n:02d}｜命中 {sc} / {total}｜歷史 {DRAG_MAX_ROWS}期 成功率 {rate*100:.0f}%｜Wilson下界 {score*100:.0f}%")
            else:
                print("（無；可能是篩選條件太嚴或樣本不足，可調 DRAG_PROB_MIN_TOTAL / DRAG_PROB_MIN_SUCCESS）")
        else:
            print("\n📌 版路拖牌總覽：（無）")
            mark_level = {}
            drag_bonus_map, drag_topk_nums = {}, []
    # ✅ 修正：RunControl.set_progress 只接受一個參數(0~100)
    # 這裡位於「版路拖牌」階段結束點（30~50），因此直接推進到 50%
    control.set_progress(50)

    # 模型清單
    # 模型清單（自動跳過未安裝的套件）
    model_names = ["Logistic", "RandomForest"]
    if XGBOOST_AVAILABLE: model_names.append("XGBoost")
    if LIGHTGBM_AVAILABLE: model_names.append("LightGBM")
    if CATBOOST_AVAILABLE: model_names.append("CatBoost")
    if CRF_AVAILABLE: model_names.append("CRF")


    def pick_topn_stable(scores, top_n, desc=True):
        s = np.asarray(scores, dtype=np.float64)
        n = s.shape[0]
        order = np.lexsort((np.arange(n, dtype=np.int32), -s if desc else s))
        pick_idx = order[:top_n]
        return sorted([int(i + 1) for i in pick_idx])

    def format_nums(nums_list):
        return "[" + ", ".join(f"{n:02d}" for n in sorted(nums_list)) + "]"

    def format_nums_with_marks(nums_list, mark_level: dict):
        parts = []
        for n in nums_list:
            lvl = int(mark_level.get(int(n), 0))
            mark = "🔥" if lvl >= 3 else ("🎯" if lvl >= 2 else "")
            parts.append(f"{int(n):02d}{mark}")
        return "[" + ", ".join(parts) + "]"

    # ===== 回測資料容器 =====
    error_logs = []
    model_hits = {}
    model_logs = {}
    model_prize_stat = {}
    model_pl_stat = {}  # 每模型累計（win/bets/cost/prize/profit）

    # ========= Walk-forward 回測 =========
    def run_backtest_walkforward(model_name):
        hits, logs, rows = [], [], []
        if q:
            q.put(f"\r--- 開始模型 [{model_name}] Walk-forward 回測 ---")
        else:
            print(f"\n--- 開始模型 [{model_name}] Walk-forward 回測 ---")

        K = max(1, int(WALK_FORWARD_RETRAIN_INTERVAL))
        model_obj = None
        last_fit_i = None
        fit_count = 0

        total_steps = len(backtest_indexes)
        bar = GuiTqdm(total=total_steps, desc=f"回測WF [{model_name}]", width=22, q=q) if q else ConsoleTqdm(total=total_steps, desc=f"回測WF [{model_name}]", width=22)

        for step_idx, i in enumerate(backtest_indexes, 1):
            control.check_pause_stop()

            start_idx = 0 if (TRAIN_WINDOW is None) else max(0, i - TRAIN_WINDOW)
            need_refit = (model_obj is None) or (last_fit_i is None) or ((i - last_fit_i) >= K)

            if need_refit:
                try:
                    seed_offset = (fit_count * 1000) + (model_names.index(model_name) * 100)
                    model_obj = fit_model_for_i(
                        model_name,
                        X_bt,
                        y_all,
                        base_columns,
                        start_idx,
                        i,
                        seed_offset=seed_offset,
                        status_cb=(bar.write if bar else None),
                    )
                    last_fit_i = i
                    fit_count += 1
                except Exception as e:
                    error_logs.append(f"{model_name} | fit_i={i} | {e}")
                    model_obj = None

            try:
                pred_scores = np.zeros(39, dtype=np.float32) if (model_obj is None) else predict_scores_for_i(model_name, model_obj, X_bt, base_columns, i)
            except Exception as e:
                error_logs.append(f"{model_name} | pred_i={i} | {e}")
                pred_scores = np.zeros(39, dtype=np.float32)

            pred_top_n = pick_topn_stable(pred_scores, BACKTEST_TOP_N, desc=True)

            real_idx = i + 1
            real_date = df_bt.iloc[real_idx]["日期"].date()
            real_issue = int(df_bt.iloc[real_idx]["期數"]) 
            real_numbers = df_bt.iloc[real_idx][nums].tolist()
            hit = len(set(pred_top_n) & set(real_numbers))
            hits.append(hit)

            # 每期盈虧
            period_cost = 0
            period_prize = 0
            period_profit = 0

            if pm in ("tw539", "lehecai39"):
                model_pl_stat.setdefault(model_name, {"win": 0, "bets": 0, "cost": 0, "prize": 0, "profit": 0})

                if pm == "tw539":
                    ticket_price = 50
                    period_cost = ticket_price
                    period_prize = int(LOTTO539_FIXED_PRIZE.get(int(hit), 0))
                    period_profit = period_prize - period_cost

                    model_pl_stat[model_name]["bets"] += 1
                    model_pl_stat[model_name]["cost"] += period_cost
                    model_pl_stat[model_name]["prize"] += period_prize
                    model_pl_stat[model_name]["profit"] += period_profit
                    if period_prize > 0:
                        model_pl_stat[model_name]["win"] += 1

                else:
                    pl = calc_lehecai39_profit_multi(
                        pred_main_nums=pred_top_n,
                        actual_main_nums=real_numbers,
                        play_ks=lehecai_play_ks,
                        ticket_price=25,
                    )
                    period_cost = int(pl["cost"])
                    period_prize = int(pl["prize"])
                    period_profit = int(pl["profit"])

                    model_pl_stat[model_name]["bets"] += int(pl["bets"])
                    model_pl_stat[model_name]["cost"] += period_cost
                    model_pl_stat[model_name]["prize"] += period_prize
                    model_pl_stat[model_name]["profit"] += period_profit
                    model_pl_stat[model_name]["win"] += int(pl["win"])

            profit_str = f"{int(period_profit):+d}"
            logs.append(
                f"{model_name:<12} | {real_date} | 命中:{hit:<2d} | 盈虧:{profit_str} | 成本:{period_cost} | 獎金:{period_prize} | "
                f"預測:{format_nums(pred_top_n)} | 開獎:{format_nums(real_numbers)}"
            )

            # ✅ 每期回測紀錄（每模型輸出）
            rows.append({
                "模型": str(model_name),
                "期數": int(real_issue),
                "日期": str(real_date),
                "命中顆數": int(hit),
                "開獎號碼": ",".join(f"{int(x):02d}" for x in list(real_numbers)),
                "模型號碼": ",".join(f"{int(x):02d}" for x in list(pred_top_n)),
            })

            if bar:
                bar.update(1)

        if bar:
            bar.close()
            # ✅ 讓 tqdm 最後一行(100%)真的先「落地」到 GUI Text，再開始印下一段
            try:
                print("")
            except Exception:
                pass

        # 回測統計（avg/std + 盈虧另外統計）
        if pm == "tw539":
            prize_stat = calc_prize(hits, BACKTEST_TOP_N, payout_mode="tw539")
        elif pm == "lehecai39":
            prize_stat = calc_prize(hits, BACKTEST_TOP_N, payout_mode="casino")
        else:
            prize_stat = calc_prize(hits, BACKTEST_TOP_N, payout_mode="casino")

        # ✅ 你要的：完成模型後「空一行」
        print(f"--- 完成模型 [{model_name}] Walk-forward 回測 ---\n")
        return model_name, hits, logs, prize_stat


    # 40~80：回測（每模型更新一次）
    total_start = time.time()
    bt_total = len(model_names)

    for idx_m, mn in enumerate(model_names, 1):
        control.set_status(f"模型回測(WF)：{mn} ({idx_m}/{bt_total})")
        control.check_pause_stop()

        # 40~80 平均分配
        p0 = 40 + (idx_m - 1) * (40 / bt_total)
        p1 = 40 + idx_m * (40 / bt_total)
        control.set_progress(p0)

        k, hits, logs, prize_stat = run_backtest_walkforward(mn)
        model_hits[k] = hits
        model_logs[k] = logs
        model_prize_stat[k] = prize_stat

        control.set_progress(p1)

    total_end = time.time()
    control.set_status("模型回測完成：整理統計中…")
    control.set_progress(80)
    print(f"\n回測全部模型總耗時：{total_end - total_start:.2f} 秒")

    control.set_progress(100)
    control.set_status("完成")

    return "\n".join([])


# ==============================================
# GUI 主視窗
# ==============================================
class App(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("今彩539 自動化預測系統（多模型 + 特徵工程 + Walk-forward 回測 ）")

        # ===== GUI 尺寸：依使用者螢幕解析度自動縮放（更穩：DPI/多螢幕）=====
        self.update_idletasks()

        sw = int(self.winfo_screenwidth())
        sh = int(self.winfo_screenheight())

        # vroot 在某些環境更接近「可用桌面」，拿不到就退回 sw/sh
        vw = int(getattr(self, "winfo_vrootwidth", lambda: sw)())
        vh = int(getattr(self, "winfo_vrootheight", lambda: sh)())

        # 以較小的可用值為準（避免多螢幕或縮放誤差）
        aw = min(sw, vw)
        ah = min(sh, vh)

        # 目標：寬佔 92%，高佔 86%
        W = int(aw * 0.92)
        H = int(ah * 0.86)

        # 安全邊界（避免壓到工作列/邊框）
        W = min(W, aw - 40)
        H = min(H, ah - 80)

        # 下限（避免太小擠爆）
        W = max(1100, W)
        H = max(650,  H)

        # 最小尺寸：給使用者縮放空間（不要直接貼住 W/H）
        self.minsize(1050, 620)

        # 置中（用 aw/ah 才準）
        x = max(0, (aw - W) // 2)
        y = max(0, (ah - H) // 2)
        self.geometry(f"{W}x{H}+{x}+{y}")


        # 如果想直接最大化就用這個（不建議預設，DPI/多螢幕有時會怪）
        # self.state("zoomed")


        self.control = RunControl()
        self.log_queue = queue.Queue()
        self.worker_thread = None

        self.last_summary_text = ""
        self.last_summary_time = ""

        top = ttk.Frame(self)
        top.pack(fill="x", padx=12, pady=10)

        row1 = ttk.Frame(top)
        row1.pack(fill="x")

        left_params = ttk.Frame(row1)
        left_params.pack(side="left")

        self.var_backtestN = tk.IntVar(value=600)
        self.var_bt_topn = tk.IntVar(value=6)
        self.var_pred_topn = tk.IntVar(value=6)
        self.var_payout_mode = tk.StringVar(value="casino")

        def make_spin(parent, text, var, from_, to_, width=8):
            f = ttk.Frame(parent)
            ttk.Label(f, text=text).pack(side="left")
            sp = ttk.Spinbox(f, from_=from_, to=to_, textvariable=var, width=width, justify="center")
            sp.pack(side="left", padx=(6, 12))
            return f

        make_spin(left_params, "回測最近期數(建議期數600期)：", self.var_backtestN, 50, 5000, 10).pack(side="left")
        make_spin(left_params, "回測：", self.var_bt_topn, 1, 39, 6).pack(side="left")
        make_spin(left_params, "預測：", self.var_pred_topn, 1, 39, 6).pack(side="left")

        right_ops = ttk.Frame(row1)
        right_ops.pack(side="right")

        self.btn_run = ttk.Button(right_ops, text="執行", command=self.on_run)
        self.btn_pause = ttk.Button(right_ops, text="暫停", command=self.on_pause_resume)  # ✅ 合併鍵
        self.btn_stop = ttk.Button(right_ops, text="停止", command=self.on_stop)
        self.btn_show = ttk.Button(right_ops, text="查看結果", command=self.on_show_result)

        for b in (self.btn_run, self.btn_pause, self.btn_stop):
            b.pack(side="left", padx=4)
        self.btn_show.pack(side="left", padx=(10, 0))


        # 彩金模式（✅ 修正：tw539 / lehecai39 / casino）
        mode_row = ttk.Frame(top)
        mode_row.pack(fill="x", pady=(8, 0))

        ttk.Label(mode_row, text="彩金模式：").pack(side="left")

        ttk.Radiobutton(mode_row, text="線上娛樂城", variable=self.var_payout_mode, value="casino", command=self._update_lehecai_state).pack(side="left", padx=6)
        ttk.Radiobutton(mode_row, text="今彩539", variable=self.var_payout_mode, value="tw539", command=self._update_lehecai_state).pack(side="left", padx=6)
        ttk.Radiobutton(mode_row, text="39樂合彩", variable=self.var_payout_mode, value="lehecai39", command=self._update_lehecai_state).pack(side="left")

        # 39 樂合彩 勾選（玩法 K）
        self.var_lehecai_2 = tk.BooleanVar(value=True)
        self.var_lehecai_3 = tk.BooleanVar(value=True)
        self.var_lehecai_4 = tk.BooleanVar(value=True)

        lehe_row = ttk.Frame(top)
        lehe_row.pack(fill="x", pady=(6, 0))

        ttk.Label(lehe_row, text="39樂合彩：").pack(side="left")

        self.chk_lehe_2 = ttk.Checkbutton(lehe_row, text="二合", variable=self.var_lehecai_2)
        self.chk_lehe_3 = ttk.Checkbutton(lehe_row, text="三合", variable=self.var_lehecai_3)
        self.chk_lehe_4 = ttk.Checkbutton(lehe_row, text="四合", variable=self.var_lehecai_4)

        self.chk_lehe_2.pack(side="left", padx=6)
        self.chk_lehe_3.pack(side="left", padx=6)
        self.chk_lehe_4.pack(side="left", padx=6)

        # 狀態 / 進度
        status_bar = ttk.Frame(self)
        status_bar.pack(fill="x", padx=12, pady=(0, 8))

        self.lbl_status = ttk.Label(status_bar, text="狀態：待命")
        self.lbl_status.pack(side="left")

        self.lbl_progress = ttk.Label(status_bar, text="0%")
        self.lbl_progress.pack(side="right", padx=(0, 8))

        self.progress = ttk.Progressbar(status_bar, length=260, mode="determinate")
        self.progress.pack(side="right", padx=(10, 0))

        # 輸出區
        out_card = ttk.LabelFrame(self, text="輸出紀錄")
        out_card.pack(fill="both", expand=True, padx=12, pady=(0, 12))

        wrap = ttk.Frame(out_card)
        wrap.pack(fill="both", expand=True, padx=10, pady=10)

        self.txt = tk.Text(
            wrap,
            bg="#0f0f0f",
            fg="#e8e8e8",
            insertbackground="#e8e8e8",
            font=("Consolas", 10),
            wrap="none",
            relief="flat",
        )
        self.txt.pack(side="left", fill="both", expand=True)

        sb = ttk.Scrollbar(wrap, orient="vertical", command=self.txt.yview)
        sb.pack(side="right", fill="y")
        self.txt.configure(yscrollcommand=sb.set)

        # ✅ 新增：水平卷軸 + 關閉自動換行（wrap=none）
        sbx = ttk.Scrollbar(out_card, orient="horizontal", command=self.txt.xview)
        sbx.pack(fill="x", padx=12, pady=(0, 10))
        self.txt.configure(xscrollcommand=sbx.set)

        self.after(60, self._pump_queue)
        self.after(250, self._update_status_progress)
        self._update_lehecai_state()

    def _clear_text(self):
        self.txt.delete("1.0", "end")

    def _text_write(self, s: str):
        if not s:
            return

        # ✅ 相容：若外部/舊版把進度條包成字串輸出：
        #     "REPLACE_LINE <id> {....}"（可能多段黏在一起）
        # 我們把花括號內的內容視為「應覆寫的單行進度條」。
        try:
            if "REPLACE_LINE" in s:
                matches = re.findall(r"REPLACE_LINE\s+[^\s]+\s+\{([^}]*)\}", s)
                if matches:
                    # 先依序覆寫（最後一個會停留在畫面上）
                    for m in matches:
                        self._text_write("\r" + m)
                    # 把已處理的 REPLACE_LINE 區段移除，保留後面真正 log
                    s = re.sub(r"REPLACE_LINE\s+[^\s]+\s+\{[^}]*\}", "", s)
        except Exception:
            pass

        try:
            s = ANSI_ESCAPE_RE.sub("", s)
        except Exception:
            pass

        try:
            parts = s.split("\r")
            if parts:
                head = parts[0]
                if head:
                    self.txt.insert("end", head)

            for p in parts[1:]:
                line_start = self.txt.index("end-1c linestart")
                line_end = self.txt.index("end-1c lineend")
                self.txt.delete(line_start, line_end)
                if p:
                    self.txt.insert("end", p)

            self.txt.see("end")
        except Exception:
            try:
                self.txt.insert("end", s)
                self.txt.see("end")
            except Exception:
                pass

    def _update_lehecai_state(self):
        mode = str(self.var_payout_mode.get()).strip().lower()
        state = "normal" if mode == "lehecai39" else "disabled"
        self.chk_lehe_2.config(state=state)
        self.chk_lehe_3.config(state=state)
        self.chk_lehe_4.config(state=state)

    def _pump_queue(self):
        try:
            while True:
                s = self.log_queue.get_nowait()
                if s:
                    self._text_write(s)
        except queue.Empty:
            pass
        self.after(60, self._pump_queue)

    def _update_status_progress(self):
        try:
            st = self.control.get_status()
            pv = float(self.control.get_progress())
            pv = max(0.0, min(100.0, pv))

            self.lbl_status.config(text=f"狀態：{st}")
            self.progress["value"] = pv
            self.lbl_progress.config(text=f"{int(round(pv))}%")
        except Exception:
            pass
        self.after(250, self._update_status_progress)

    def _open_summary_window(self, summary_text: str):
        win = tk.Toplevel(self)
        win.title("完成今彩539摘要")
        win.geometry("860x560")
        win.minsize(760, 480)

        top = ttk.Frame(win)
        top.pack(fill="x", padx=10, pady=10)

        ttk.Label(top, text="✅ 執行完成摘要", font=("Microsoft JhengHei UI", 12, "bold")).pack(side="left")

        body = ttk.Frame(win)
        body.pack(fill="both", expand=True, padx=10, pady=(0, 10))

        txt = tk.Text(
            body,
            bg="#101010",
            fg="#eaeaea",
            insertbackground="#eaeaea",
            wrap="none",
            font=("Consolas", 10),
            relief="flat",
        )
        txt.pack(side="left", fill="both", expand=True)

        sb = ttk.Scrollbar(body, orient="vertical", command=txt.yview)
        sb.pack(side="right", fill="y")
        txt.configure(yscrollcommand=sb.set)

        txt.insert("end", summary_text or "")
        txt.see("1.0")

        btns = ttk.Frame(win)
        btns.pack(fill="x", padx=10, pady=(0, 10))

        def copy_all():
            try:
                win.clipboard_clear()
                win.clipboard_append(summary_text or "")
                messagebox.showinfo("已複製", "摘要內容已複製到剪貼簿")
            except Exception:
                pass

        ttk.Button(btns, text="複製摘要", command=copy_all).pack(side="right")

    def on_run(self):
        if self.worker_thread and self.worker_thread.is_alive():
            messagebox.showwarning("執行中", "目前仍在執行，請先停止或等待完成。")
            return

        try:
            backtestN = int(self.var_backtestN.get())
            bt_topn = int(self.var_bt_topn.get())
            pred_topn = int(self.var_pred_topn.get())
            payout_mode = str(self.var_payout_mode.get()).strip().lower()

            lehecai_ks = []
            if self.var_lehecai_2.get():
                lehecai_ks.append(2)
            if self.var_lehecai_3.get():
                lehecai_ks.append(3)
            if self.var_lehecai_4.get():
                lehecai_ks.append(4)

            if payout_mode == "lehecai39" and not lehecai_ks:
                messagebox.showerror("設定錯誤", "39 樂合彩至少要勾選一種玩法（二合 / 三合 / 四合）")
                return
        except Exception:
            messagebox.showerror("參數錯誤", "請確認參數為整數。")
            return

        self.control.request_resume()
        self.control.stop_event.clear()
        self.control.set_status("準備開始")
        self.control.set_progress(0)

        try:
            self.btn_pause.config(text="暫停")  # ✅ 每次執行都先回到「暫停」
        except Exception:
            pass

        self._clear_text()
        self._text_write("==== 開始執行 ====\n")

        def _worker():
            summary = ""
            err = None
            start_ts = time.time()

            try:
                with redirect_output_to_queue(self.log_queue):
                    summary = run_pipeline(
                        backtestN,
                        bt_topn,
                        pred_topn,
                        self.control,
                        payout_mode=payout_mode,
                        lehecai_play_ks=tuple(lehecai_ks),
                        gui_queue=self.log_queue,
                    )
            except KeyboardInterrupt:
                err = "使用者停止"
            except Exception as e:
                err = f"{type(e).__name__}: {e}"

            end_ts = time.time()

            def _finish_ui():
                if err:
                    self.control.set_status("已停止" if err == "使用者停止" else "錯誤")
                    self._text_write(f"\n\n==== 結束：{err} ====\n")
                    return

                self.control.set_status("完成")
                self.control.set_progress(100)

                self.last_summary_text = summary or ""
                self.last_summary_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

                self._text_write("\n\n==== 全部完成 ====\n")
                self._text_write(f"耗時：{end_ts - start_ts:.2f} 秒\n")
                self._open_summary_window(self.last_summary_text)

            self.after(0, _finish_ui)

        self.worker_thread = threading.Thread(target=_worker, daemon=True)
        self.worker_thread.start()

    def on_pause(self):
        self.control.request_pause()
        self.control.set_status("暫停中（等待安全點）")

    def on_resume(self):
        self.control.request_resume()
        self.control.set_status("執行中")

    def on_pause_resume(self):
        if not hasattr(self, "control") or self.control is None:
            return

        # ✅ 最可靠：直接看 pause_event（True=執行中 / False=暫停中）
        try:
            is_running = bool(self.control.pause_event.is_set())
        except Exception:
            # fallback
            is_running = not bool(getattr(self.control, "paused", False))

        if is_running:
            # === 暫停 ===
            self.control.request_pause()
            self.control.set_status("暫停中（等待安全點）")
            try:
                self.btn_pause.config(text="繼續")
            except Exception:
                pass
        else:
            # === 繼續 ===
            self.control.request_resume()
            self.control.set_status("執行中")
            try:
                self.btn_pause.config(text="暫停")
            except Exception:
                pass


    def on_stop(self):
        self.control.request_stop()
        self.control.set_status("停止中（等待安全點）")

    def on_show_result(self):
        if not self.last_summary_text:
            messagebox.showinfo("尚無結果", "目前沒有摘要結果（請先執行一次）。")
            return
        self._open_summary_window(self.last_summary_text)
# ==============================================
# main
# ==============================================
if __name__ == "__main__":
    try:
        app = App()
        app.mainloop()
    except Exception as e:
        print("GUI 啟動失敗：", e)
