# ==============================================
# 今彩539 自動化預測系統（多模型 + 特徵工程 + Walk-forward 回測）
# 模型：XGB / LGBM / CatBoost / Logistic / RF / CRF
# 重點：
# - Walk-forward：每 K 期重訓一次（貼近真實策略）
# - 特徵一次建滿：熱度/遺漏/miss/pair 共現/群組映射等
# - 對獎以「期數」為準（避免日期推算誤差）
# - 錯題本只讀「真實預測對獎」結果（避免回測污染）
# - 版路拖牌：以最新開獎為起點，預測 lag 期後可能拖出的號碼
# By Party87 + ChatGPT | 2025/12/30
# ==============================================

import warnings
import os
import sys
import re
import csv
import time
import pickle
import random
import tempfile
import contextlib
import multiprocessing
from io import StringIO
from math import comb
from datetime import timedelta, datetime
from collections import Counter, defaultdict

import requests
import numpy as np
import pandas as pd
from tqdm import tqdm
from colorama import Fore, Style
from collections import deque, defaultdict

from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from catboost import CatBoostClassifier

import sklearn_crfsuite
from sklearn.multioutput import MultiOutputClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.exceptions import ConvergenceWarning
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.base import BaseEstimator, ClassifierMixin

# ===== GUI =====
import tkinter as tk
from tkinter import ttk, messagebox
import threading
import queue

# ===== ANSI 色碼剝除（Colorama / Console 顏色碼）=====
ANSI_ESCAPE_RE = re.compile(r"\x1b\[[0-9;]*m|\[[0-9]{1,3}m|\[0m")

# ==============================================
# 通用抓 HTML（避免 NameError）
# ==============================================
def _fetch_text(url, timeout=8):
    try:
        headers = {
            "User-Agent": "Mozilla/5.0"
        }
        r = requests.get(url, timeout=timeout, headers=headers)
        r.raise_for_status()
        r.encoding = r.apparent_encoding or "utf-8"
        return r.text
    except Exception:
        return ""

# ==============================================
# ✅抓台彩 539 最新開獎日期（避免 NameError）
# ==============================================
def fetch_twlottery_latest_draw_date_539(timeout=8):
    """
    嘗試從台彩 539 歷史頁抓「最新開獎日期」
    抓不到回傳 None
    """
    url = "https://www.taiwanlottery.com.tw/lotto/Lotto539/history.aspx"
    html = _fetch_text(url, timeout=timeout)
    if not html:
        return None

    # 盡量找 YYYY/MM/DD 或 YYYY-MM-DD
    dates = set()
    for m in re.findall(r"(20\d{2})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})", html):
        y, mo, d = int(m[0]), int(m[1]), int(m[2])
        try:
            dates.add(datetime(y, mo, d).date())
        except Exception:
            pass

    if not dates:
        return None
    return max(dates)

# ==============================================
# CatBoost sklearn 相容 wrapper
# ==============================================
class CatBoostSklearnCompat(CatBoostClassifier, BaseEstimator, ClassifierMixin):
    """
    修正：舊版 CatBoost 在新版 scikit-learn 會缺 __sklearn_tags__ 而爆炸
    這個 wrapper 補上 tags 讓 MultiOutputClassifier 可以正常工作
    """
    def __sklearn_tags__(self):
        return BaseEstimator.__sklearn_tags__(self)


# ==============================================
# 輸出/雜訊控制（避免 warnings / stderr 洗版）
# ==============================================
os.environ.setdefault("PYTHONWARNINGS", "ignore")

warnings.simplefilter("ignore")
warnings.filterwarnings("ignore", category=ConvergenceWarning)
warnings.filterwarnings("ignore", message=".*lbfgs failed to converge.*", module=r"sklearn\.linear_model\._logistic")
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=FutureWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)


@contextlib.contextmanager
def suppress_all_output(enable=True):
    """enable=True：stdout/stderr/warnings 全部消音（訓練/預測用）"""
    if not enable:
        yield
        return
    old_showwarning = warnings.showwarning
    warnings.showwarning = lambda *args, **kwargs: None
    with open(os.devnull, "w") as devnull:
        with contextlib.redirect_stdout(devnull), contextlib.redirect_stderr(devnull):
            try:
                yield
            finally:
                warnings.showwarning = old_showwarning


# ==============================================
# 多執行緒/CPU 設定（B方案建議：統一用 CPU_LOGICAL-1，避免超額開執行緒）
# ==============================================
CPU_LOGICAL = multiprocessing.cpu_count()
AUTO_THREADS = max(1, CPU_LOGICAL - 1)

os.environ["OMP_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["MKL_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["OPENBLAS_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["NUMEXPR_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["VECLIB_MAXIMUM_THREADS"] = str(AUTO_THREADS)
os.environ["JOBLIB_MULTIPROCESSING"] = "1"

N_JOBS = AUTO_THREADS


# ==============================================
# 可調參數
# ==============================================
FAST_MODE = True
TRAIN_WINDOW = 900 if FAST_MODE else None
DOWNLOAD_RETRY = 3

# 錯題本懲罰強度（自動隨真實對獎紀錄量變強）
MISTAKE_ALPHA = None  # 交給自動函數決定
SAVE_PROBA_CSV = True

USE_DETERMINISTIC = True
GLOBAL_SEED = 42

# Walk-forward：每 K 期才重訓一次
WALK_FORWARD_RETRAIN_INTERVAL = 10  # K

# 版路拖牌
DRAG_ENABLE = True
MAX_LAG = 30
MIN_CHAIN_RUN = 2
DRAG_MAX_ROWS = 365
DRAG_PREDICT_LAGS = list(range(1, 11))

# GUI 顯示控制
GUI_VERBOSE_STAGE = True
ANNOUNCE_FETCH_MAX_SEC = 8.0

def get_auto_mistake_alpha(result_csv="latest_predict_result.csv",
                           base=0.05,
                           recent_window=60,
                           target_ge2=0.28,
                           min_alpha=0.03,
                           max_alpha=0.18):
    """
    ✅ 動態錯題本懲罰 alpha（只用「真實對獎」）
    1) 依真實對獎累積筆數決定「可信度」基底（越多筆→越敢懲罰）
    2) 再依「近期命中表現」微調：
       - 若近期 命中>=2 比例偏低 → alpha 上調（更強烈避開錯誤型態）
       - 若近期表現偏好       → alpha 下調（避免過度排斥而失去多樣性）
    """
    # --- 讀檔 ---
    try:
        if not os.path.exists(result_csv):
            return float(base)
        df = pd.read_csv(result_csv, encoding="utf-8-sig")
        if df is None or len(df) == 0:
            return float(base)
    except Exception:
        return float(base)

    # --- 1) 依筆數給一個基底 alpha（你原本的邏輯保留，但用更平滑的方式） ---
    n = int(len(df))
    if n < 30:
        alpha = float(base)
    elif n < 80:
        alpha = 0.08
    elif n < 150:
        alpha = 0.10
    else:
        alpha = 0.12

    # --- 2) 依近期命中表現微調 ---
    # 盡量兼容不同欄位命名
    hit_col_candidates = ["命中數", "命中數_539", "hit", "hits", "hit_count"]
    hit_col = None
    for c in hit_col_candidates:
        if c in df.columns:
            hit_col = c
            break

    if hit_col is not None:
        try:
            recent = df.tail(int(recent_window)).copy()
            recent_hits = pd.to_numeric(recent[hit_col], errors="coerce").dropna()
            if len(recent_hits) >= 10:
                ge2_rate = float((recent_hits >= 2).mean())
                # 偏離目標越多，調整越多（上限約 ±0.04）
                delta = (float(target_ge2) - ge2_rate)
                alpha = alpha + max(-0.06, min(0.06, delta * 0.35))
        except Exception:
            pass

    # --- clamp ---
    alpha = float(max(float(min_alpha), min(float(max_alpha), float(alpha))))
    return alpha



# ==============================================
# CatBoost 訓練目錄
# ==============================================
def ensure_catboost_train_dir():
    base = os.path.join(tempfile.gettempdir(), "catboost_tmp")
    os.makedirs(base, exist_ok=True)

    os.environ["TMPDIR"] = base
    os.environ["TMP"] = base
    os.environ["TEMP"] = base
    os.environ["CATBOOST_TRAIN_DIR"] = base
    return base


catboost_train_dir = ensure_catboost_train_dir()


# ==============================================
# 固定 seed（讓回測/預測可重現）
# ==============================================
def set_global_seed(seed=42):
    random.seed(seed)
    np.random.seed(seed)
    os.environ["PYTHONHASHSEED"] = str(seed)


if USE_DETERMINISTIC:
    set_global_seed(GLOBAL_SEED)


# ==============================================
# GUI 控制：暫停/停止 + 狀態 + 進度(0~100)
# ==============================================
class RunControl:
    def __init__(self):
        # 事件
        self.pause_event = threading.Event()
        self.stop_event = threading.Event()
        self.pause_event.set()  # set = running

        # locks + 狀態
        self.status_lock = threading.Lock()
        self.status_text = "待命"

        # 進度
        self.progress_lock = threading.Lock()
        self.progress_value = 0.0

    # ✅ 防呆：若某些屬性因重複定義/覆蓋而不存在，自動補齊
    def _ensure_attrs(self):
        if not hasattr(self, "pause_event") or not isinstance(getattr(self, "pause_event", None), threading.Event):
            self.pause_event = threading.Event()
            self.pause_event.set()

        if not hasattr(self, "stop_event") or not isinstance(getattr(self, "stop_event", None), threading.Event):
            self.stop_event = threading.Event()

        if not hasattr(self, "status_lock"):
            self.status_lock = threading.Lock()
        if not hasattr(self, "status_text"):
            self.status_text = "待命"

        if not hasattr(self, "progress_lock"):
            self.progress_lock = threading.Lock()
        if not hasattr(self, "progress_value"):
            self.progress_value = 0.0

    def set_status(self, s: str):
        self._ensure_attrs()
        with self.status_lock:
            self.status_text = str(s)

    def get_status(self) -> str:
        self._ensure_attrs()
        with self.status_lock:
            return self.status_text

    def set_progress(self, v: float):
        self._ensure_attrs()
        v = 0.0 if v is None else float(v)
        if v < 0:
            v = 0.0
        if v > 100:
            v = 100.0
        with self.progress_lock:
            self.progress_value = v

    def get_progress(self) -> float:
        self._ensure_attrs()
        with self.progress_lock:
            return float(self.progress_value)

    def request_pause(self):
        self._ensure_attrs()
        self.pause_event.clear()

    def request_resume(self):
        self._ensure_attrs()
        self.pause_event.set()

    def request_stop(self):
        self._ensure_attrs()
        self.stop_event.set()
        self.pause_event.set()  # 解除卡住，讓程式能跳出

    def check_pause_stop(self):
        """在安全點呼叫：會阻塞暫停，停止則丟例外中斷"""
        self._ensure_attrs()
        if self.stop_event.is_set():
            raise KeyboardInterrupt("使用者停止")
        while not self.pause_event.is_set():
            if self.stop_event.is_set():
                raise KeyboardInterrupt("使用者停止")
            time.sleep(0.15)


# ==============================================
# GUI log：把 print 輸出導到 Text
# ==============================================
class QueueWriter:
    def __init__(self, q: queue.Queue):
        self.q = q

    def write(self, s: str):
        if s:
            self.q.put(s)

    def flush(self):
        pass


@contextlib.contextmanager
def redirect_output_to_queue(q: queue.Queue):
    old_out, old_err = sys.stdout, sys.stderr
    sys.stdout = QueueWriter(q)
    sys.stderr = QueueWriter(q)
    try:
        yield
    finally:
        sys.stdout = old_out
        sys.stderr = old_err


# ==============================================
# 下載/快取官方今彩539資料 + 清洗
# ==============================================
def load_tw539(force_download=False):
    """下載/讀取快取今彩539資料。

    ✅ 新增：
    - 回傳 df 同時附帶 df.attrs：
      - fetch_source: 來源 URL 或 CACHE
      - fetch_time: 抓取/快取檔時間（字串）
      - latest_draw_date: 最新開獎日期（YYYY-MM-DD）
      - latest_issue: 最新期數

    （注意）資料來源為 biga 歷史資料鏡像；你在 GUI 看到的「官方日期」以資料檔最新一期的『日期』為準。
    """
    DATA_CACHE = "tw539_latest.csv"
    DATA_URL = "https://biga.com.tw/HISTORYDATA/tw539.csv"

    def _attach_meta(df, fetch_source: str, fetch_time_dt):
        # 最新期數（以期數最大為準）
        try:
            latest_issue = int(pd.to_numeric(df["期數"], errors="coerce").max()) if len(df) else ""
        except Exception:
            latest_issue = ""

        # 最新開獎日期（以日期最大為準）
        try:
            latest_date = pd.to_datetime(df["日期"], errors="coerce").max()
            latest_date_str = latest_date.strftime("%Y-%m-%d") if pd.notna(latest_date) else ""
        except Exception:
            latest_date_str = ""

        df.attrs["fetch_source"] = str(fetch_source)
        df.attrs["fetch_time"] = fetch_time_dt.strftime("%Y-%m-%d %H:%M:%S") if hasattr(fetch_time_dt, "strftime") else str(fetch_time_dt)
        df.attrs["latest_draw_date"] = str(latest_date_str)
        df.attrs["latest_issue"] = str(latest_issue)
        return df

    # --- 讀快取 ---
    if (not force_download) and os.path.exists(DATA_CACHE):
        df = None
        for enc in ("utf-8-sig", "utf-8", "cp950", "big5"):
            try:
                df = pd.read_csv(DATA_CACHE, encoding=enc)
                break
            except Exception:
                df = None
        if df is None:
            raise RuntimeError(f"快取檔 {DATA_CACHE} 讀取失敗：可能檔案已損毀或非文字編碼")

        if "日期" in df.columns:
            df["日期"] = pd.to_datetime(df["日期"], errors="coerce")

        try:
            mtime = datetime.fromtimestamp(os.path.getmtime(DATA_CACHE))
        except Exception:
            mtime = datetime.now()

        return _attach_meta(df, fetch_source="CACHE", fetch_time_dt=mtime)

    # --- 下載 ---
    last_err = None
    for _ in range(DOWNLOAD_RETRY):
        try:
            r = requests.get(DATA_URL, timeout=15)
            r.raise_for_status()
            csv_str = r.content.decode("utf-8-sig")
            df = pd.read_csv(StringIO(csv_str), header=None)
            df.columns = [
                "日期", "期數",
                "落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5",
                "",
                "正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"
            ]
            df["日期"] = pd.to_datetime(df["日期"], errors="coerce")

            num_cols = [
                "落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5",
                "正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"
            ]
            for c in num_cols:
                df[c] = pd.to_numeric(df[c], errors="coerce")

            df["期數"] = pd.to_numeric(df["期數"], errors="coerce")
            df = df.dropna(subset=["日期", "期數"] + num_cols).reset_index(drop=True)

            df["期數"] = df["期數"].astype(int)
            df[num_cols] = df[num_cols].astype(int)

            if len(df) and (df["日期"].iloc[0] > df["日期"].iloc[-1]):
                df = df.iloc[::-1].reset_index(drop=True)

            df = df.drop(columns=[""])
            df.to_csv(DATA_CACHE, index=False, encoding="utf-8-sig")

            return _attach_meta(df, fetch_source=DATA_URL, fetch_time_dt=datetime.now())
        except Exception as e:
            last_err = e
            time.sleep(1.0)

    raise RuntimeError(f"下載官方資料失敗：{last_err}")


# ==============================================
# 對獎：以「期數」優先（避免日期推算誤差）
# ==============================================
def try_save_latest_prediction_result(df, nums):
    pred_file = "latest_predict.csv"
    result_file = "latest_predict_result.csv"
    if not os.path.exists(pred_file):
        return

    pred_df = pd.read_csv(pred_file, dtype=str)
    df2 = df.copy()
    df2["日期"] = pd.to_datetime(df2["日期"], errors="coerce")

    if os.path.exists(result_file):
        result_df = pd.read_csv(result_file, dtype=str)
        recorded_keys = set(result_df.apply(lambda r: f"{r.get('預測期數','')}_{r.get('模型','')}", axis=1))
    else:
        result_df = pd.DataFrame()
        recorded_keys = set()

    new_records = []
    for _, row in pred_df.iterrows():
        model = str(row.get("模型", "")).strip()
        pred_issue = str(row.get("預測期數", "")).strip()
        pred_date = str(row.get("預測日期", "")).strip()
        pred_nums_str = str(row.get("預測號碼", "")).strip()

        key = f"{pred_issue}_{model}"
        if key in recorded_keys:
            continue
        if not pred_nums_str:
            continue

        pred_numbers = [int(n) for n in pred_nums_str.split(",") if str(n).strip().isdigit()]

        real_row = None
        if pred_issue.isdigit():
            real_row = df2[df2["期數"] == int(pred_issue)]
        if (real_row is None) or real_row.empty:
            if pred_date:
                real_row = df2[df2["日期"].dt.strftime("%Y-%m-%d") == pred_date]

        if real_row is None or real_row.empty:
            continue

        real_numbers = [int(n) for n in real_row.iloc[0][nums].values]
        real_date = real_row.iloc[0]["日期"].strftime("%Y-%m-%d")
        real_issue = int(real_row.iloc[0]["期數"])

        hit_set = sorted(set(pred_numbers) & set(real_numbers))
        new_records.append({
            "預測日期": pred_date if pred_date else "",
            "預測期數": str(pred_issue) if pred_issue else "",
            "實際開獎日期": real_date,
            "實際開獎期數": str(real_issue),
            "模型": model,
            "預測號碼": ",".join(f"{n:02d}" for n in sorted(pred_numbers)),
            "開獎號碼": ",".join(f"{n:02d}" for n in sorted(real_numbers)),
            "命中數": str(len(hit_set)),
            "命中號碼": ",".join(f"{n:02d}" for n in hit_set)
        })

    if new_records:
        df_new = pd.DataFrame(new_records)
        if os.path.exists(result_file):
            old = pd.read_csv(result_file, dtype=str)
            result_df = pd.concat([old, df_new], ignore_index=True)
        else:
            result_df = df_new

        result_df.to_csv(result_file, index=False, encoding="utf-8-sig")
        print(f"\n自動完成對獎結果存檔：{result_file}（本次新增 {len(df_new)} 筆）")


# ==============================================
# 特徵工程（一次建滿；後續切片）
# ==============================================
FEATURE_CACHE = {}


def feature_engineering(df, nums, features, *, progress=None):
    cache_key = (df.index[0] if len(df) else -1, df.index[-1] if len(df) else -1)

    _t0 = time.perf_counter()

    # ✅ 控制：是否印特徵工程 log
    if not bool(globals().get("GUI_VERBOSE_STAGE", True)):
        if cache_key in FEATURE_CACHE:
            return FEATURE_CACHE[cache_key].copy()
        X = df[features].copy()
        FEATURE_CACHE[cache_key] = X.copy()
        return X

    _state = {
        "active": False,
        "last": "",
        "had_sub": False,   # 這段是否刷過 i/n（但不再拿來自動補 1/1）
    }

    def _end_block():
        """
        ✅ 修正重點：
        - 不再自動補 '1/1'
        - 沒子進度就維持空白，符合你要的格式
        """
        if _state["active"]:
            print()      # 結束進度行（可能是空白的 '進度：'）
            print()      # 空一行
            _state["active"] = False
            _state["last"] = ""
            _state["had_sub"] = False

    def _prog(major=None, i=None, n=None):
        if not bool(globals().get("GUI_VERBOSE_STAGE", True)):
            return

        # 新大項
        if major is not None:
            _end_block()
            mj = str(major).strip()
            print(f"[特徵工程] {mj}")

            # ✅ 預設至少顯示 1/1
            print("大項進度：1/1", end="", flush=True)

            _state["active"] = True
            _state["last"] = "大項進度：1/1"
            _state["had_sub"] = False
            return

        # 子進度（若存在則顯示；至少也是 1/1）
        if _state["active"]:
            ii = int(i) if i is not None else 1
            nn = int(n) if n is not None else 1
            if nn <= 0:
                nn = 1
            if ii <= 0:
                ii = 1

            line = f"子進度：{ii}/{nn}"
            if line != _state["last"]:
                print("\r" + line + " " * 20, end="", flush=True)
                _state["last"] = line

            _state["had_sub"] = True

            if progress:
                try:
                    progress("子進度", ii, nn)
                except Exception:
                    pass
            return


    # ---------------- cache ----------------
    if cache_key in FEATURE_CACHE:
        return FEATURE_CACHE[cache_key].copy()

    X = df[features].copy()

    # =========================
    # 日期特徵
    # =========================
    _prog("日期特徵")
    if "日期" in df.columns:
        X["weekday"] = df["日期"].dt.weekday.astype(np.int8)
        X["month"] = df["日期"].dt.month.astype(np.int8)
        X["is_weekend"] = (X["weekday"] >= 5).astype(np.int8)

    # =========================
    # 統計特徵
    # =========================
    _prog("統計特徵")

    _prog("基本統計")
    X["max_num"] = df[nums].max(axis=1)
    X["min_num"] = df[nums].min(axis=1)
    X["sum_num"] = df[nums].sum(axis=1)
    X["mean_num"] = df[nums].mean(axis=1)
    X["std_num"] = df[nums].std(axis=1)
    X["range_num"] = X["max_num"] - X["min_num"]

    # =========================
    # 奇偶特徵
    # =========================
    _prog("奇偶特徵")
    X["odd_count"] = df[nums].apply(lambda r: sum(int(n) % 2 for n in r), axis=1).astype(np.int8)
    X["even_count"] = (5 - X["odd_count"]).astype(np.int8)
    X["odd_even_ratio"] = X["odd_count"] / (X["even_count"] + 1e-6)

    # =========================
    # 間距特徵
    # =========================
    _prog("間距特徵")
    X["num_gap"] = df[nums].apply(lambda r: np.mean(np.diff(sorted(r))), axis=1)

    # =========================
    # 連號特徵
    # =========================
    _prog("連號特徵")

    def count_serials(arr):
        s = sorted(arr)
        return sum((s[i + 1] - s[i]) == 1 for i in range(4))

    X["serial_count"] = df[nums].apply(count_serials, axis=1).astype(np.int8)

    # =========================
    # 上期重複特徵
    # =========================
    _prog("上期重複特徵")

    def repeat_count(cur, prev):
        return len(set(cur) & set(prev))

    X["repeat_prev"] = [0] + [repeat_count(df.loc[i, nums], df.loc[i - 1, nums]) for i in range(1, len(df))]
    X["repeat_prev"] = pd.Series(X["repeat_prev"], dtype=np.int8)

    # =========================
    # 大小號特徵
    # =========================
    _prog("大小號特徵")
    X["small_count"] = df[nums].apply(lambda r: sum(1 <= int(n) <= 19 for n in r), axis=1).astype(np.int8)
    X["big_count"] = df[nums].apply(lambda r: sum(20 <= int(n) <= 38 for n in r), axis=1).astype(np.int8)
    X["draw39_count"] = df[nums].apply(lambda r: sum(int(n) == 39 for n in r), axis=1).astype(np.int8)
    X["big_small_score"] = (X["big_count"] - X["small_count"]).astype(np.int8)

    # =========================
    # 尾數特徵 / 合數特徵（你原順序：先尾數再合數）
    # =========================
    _prog("尾數特徵")
    for i in range(1, 6):
        _prog(None, i, 5)
        X[f"num{i}_尾數"] = (df[f"正序號碼{i}"] % 10).astype(np.int8)

    _prog("合數特徵")
    for i in range(1, 6):
        _prog(None, i, 5)
        X[f"num{i}_合數"] = ((df[f"正序號碼{i}"] // 10 + df[f"正序號碼{i}"] % 10) % 10).astype(np.int8)

    # =========================
    # 熱度特徵（01~39）
    # =========================
    _prog("熱度特徵")
    hot_frames = []
    for n in range(1, 40):
        _prog(None, n, 39)
        num_mask = (df[nums] == n).sum(axis=1).astype(np.int16)
        col_all = pd.DataFrame({f"hot_{n:02d}_all": num_mask.cumsum().astype(np.int32)})
        col_windows = pd.DataFrame({
            f"hot_{n:02d}_{w}": num_mask.rolling(w, min_periods=1).sum().astype(np.float32)
            for w in [5, 10, 20, 30]
        })
        hot_frames.append(pd.concat([col_all, col_windows], axis=1))
    X = pd.concat([X.reset_index(drop=True), pd.concat(hot_frames, axis=1).reset_index(drop=True)], axis=1)

    # =========================
    # 遺漏特徵
    # =========================
    _prog("遺漏特徵")

    miss_features = pd.DataFrame(index=df.index)
    last_pos = {n: -1 for n in range(1, 40)}
    miss_counts = {n: [] for n in range(1, 40)}

    for idx in range(len(df)):
        if (idx + 1) % 200 == 0 or (idx + 1) == len(df):
            _prog(None, idx + 1, len(df))
        cur_set = set(df.loc[idx, nums])
        for n in range(1, 40):
            if n in cur_set:
                miss_counts[n].append(0)
                last_pos[n] = idx
            else:
                miss_counts[n].append(idx - last_pos[n] if last_pos[n] != -1 else idx + 1)

    for n in range(1, 40):
        _prog(None, n, 39)
        miss_features[f"miss_{n:02d}"] = pd.Series(miss_counts[n], dtype=np.int16)

    X = pd.concat([X.reset_index(drop=True), miss_features.reset_index(drop=True)], axis=1)

    # =========================
    # 共現特徵
    # =========================
    _prog("共現特徵")

    pair_mean_list = []
    pair_max_list = []
    pair_counts = defaultdict(int)

    for idx in range(len(df)):
        if (idx + 1) % 200 == 0 or (idx + 1) == len(df):
            _prog(None, idx + 1, len(df))

        row_nums = sorted(int(df.loc[idx, col]) for col in nums)
        pair_scores = []
        for a in range(4):
            for b in range(a + 1, 5):
                p = (row_nums[a], row_nums[b])
                pair_scores.append(pair_counts[p])

        pair_mean_list.append(float(np.mean(pair_scores)) if pair_scores else 0.0)
        pair_max_list.append(float(np.max(pair_scores)) if pair_scores else 0.0)

        for a in range(4):
            for b in range(a + 1, 5):
                p = (row_nums[a], row_nums[b])
                pair_counts[p] += 1

    X["pair_cofreq_mean"] = pd.Series(pair_mean_list, index=df.index).astype(np.float32)
    X["pair_cofreq_max"] = pd.Series(pair_max_list, index=df.index).astype(np.float32)

    # =========================
    # 群組映射（八卦/生肖/均值/五行/六沖/七政）
    # =========================
    GROUP_NAME_ZH = {
        "bagua": "八卦特徵",
        "shengxiao": "生肖特徵",
        "mean_group": "均值特徵",
        "wuxing": "五行特徵",
        "liuchong": "六沖特徵",
        "qizheng": "七政特徵",
    }

    def apply_group_feats(df, nums, name, mapping, X):
        """
        ✅ 修正重點：
        - 群組映射進度只顯示 5/5（以「五顆球」為單位）
        - 群組 count 不再刷進度（避免把 5/5 蓋掉）
        """
        zh = GROUP_NAME_ZH.get(name, name)

        # 大項標題（固定兩行）
        _prog(zh)

        # 每顆球 dummy（進度 1/5）
        dummy_frames = []
        for i in range(1, 6):
            _prog(None, i, 5)
            cat_col = df[f"正序號碼{i}"].map(mapping).astype("category")
            dummies = pd.get_dummies(cat_col, prefix=f"{name}_num{i}")
            dummy_frames.append(dummies)

        if dummy_frames:
            X = pd.concat([X.reset_index(drop=True), pd.concat(dummy_frames, axis=1).reset_index(drop=True)], axis=1)

        # 群組 count（照算，但不刷進度）
        all_groups = sorted(set(mapping.values()))
        for k in all_groups:
            X[f"{name}_{k}_count"] = df[nums].apply(
                lambda row: sum(mapping.get(n, "") == k for n in row),
                axis=1
            )
        return X

    # --- mapping 原樣保留（不省略）---
    mean_group_map = {**{i: 'A' for i in range(1, 5)}, **{i: 'B' for i in range(5, 9)}, **{i: 'C' for i in range(9, 13)},
                      **{i: 'D' for i in range(13, 17)}, **{i: 'E' for i in range(17, 21)}, **{i: 'F' for i in range(21, 25)},
                      **{i: 'G' for i in range(25, 29)}, **{i: 'H' for i in range(29, 33)}, **{i: 'I' for i in range(33, 37)},
                      **{i: 'J' for i in range(37, 40)}}

    bagua_map = {1: '乾', 16: '乾', 17: '乾', 32: '乾', 8: '坤', 9: '坤', 24: '坤', 25: '坤', 6: '坎', 11: '坎', 22: '坎', 27: '坎',
                 3: '離', 14: '離', 19: '離', 30: '離', 38: '離', 5: '震', 12: '震', 21: '震', 28: '震', 36: '震', 4: '巽', 13: '巽', 20: '巽',
                 29: '巽', 37: '巽', 2: '艮', 15: '艮', 18: '艮', 31: '艮', 39: '艮', 7: '兌', 10: '兌', 23: '兌', 26: '兌', 34: '兌'}

    shengxiao_map = {11: '羊', 23: '羊', 35: '羊', 10: '猴', 22: '猴', 34: '猴', 9: '雞', 21: '雞', 33: '雞', 8: '狗', 20: '狗', 32: '狗',
                     7: '豬', 19: '豬', 31: '豬', 6: '鼠', 18: '鼠', 30: '鼠', 5: '牛', 17: '牛', 29: '牛', 4: '虎', 16: '虎', 28: '虎',
                     3: '兔', 15: '兔', 27: '兔', 39: '兔', 2: '龍', 14: '龍', 26: '龍', 38: '龍', 1: '蛇', 13: '蛇', 25: '蛇', 37: '蛇',
                     12: '馬', 24: '馬', 36: '馬'}

    wuxing_map = {13: '金', 14: '金', 21: '金', 22: '金', 29: '金', 30: '金', 1: '木', 2: '木', 9: '木', 10: '木', 17: '木', 18: '木', 31: '木',
                  32: '木', 39: '木', 3: '水', 4: '水', 11: '水', 12: '水', 25: '水', 26: '水', 33: '水', 34: '水', 7: '火', 8: '火', 15: '火',
                  16: '火', 23: '火', 24: '火', 37: '火', 38: '火', 5: '土', 6: '土', 19: '土', 20: '土', 27: '土', 28: '土', 35: '土', 36: '土'}

    liuchong_map = {1: '子午', 7: '子午', 13: '子午', 19: '子午', 25: '子午', 31: '子午', 37: '子午', 2: '丑未', 8: '丑未', 14: '丑未',
                    20: '丑未', 26: '丑未', 32: '丑未', 38: '丑未', 3: '寅申', 9: '寅申', 15: '寅申', 21: '寅申', 27: '寅申', 33: '寅申',
                    39: '寅申', 4: '卯酉', 10: '卯酉', 16: '卯酉', 22: '卯酉', 28: '卯酉', 34: '卯酉', 5: '辰戌', 11: '辰戌', 17: '辰戌',
                    23: '辰戌', 29: '辰戌', 35: '辰戌', 6: '巳亥', 12: '巳亥', 18: '巳亥', 24: '巳亥', 30: '巳亥', 36: '巳亥'}

    qizheng_map = {1: '日', 8: '日', 15: '日', 22: '日', 29: '日', 36: '日', 2: '月', 9: '月', 16: '月', 23: '月', 30: '月', 37: '月',
                   3: '火', 10: '火', 17: '火', 24: '火', 31: '火', 38: '火', 4: '水', 11: '水', 18: '水', 25: '水', 32: '水', 39: '水',
                   5: '木', 12: '木', 19: '木', 26: '木', 33: '木', 6: '金', 13: '金', 20: '金', 27: '金', 34: '金', 7: '土', 14: '土',
                   21: '土', 28: '土', 35: '土'}

    X = apply_group_feats(df, nums, "bagua", bagua_map, X)
    X = apply_group_feats(df, nums, "shengxiao", shengxiao_map, X)
    X = apply_group_feats(df, nums, "mean_group", mean_group_map, X)
    X = apply_group_feats(df, nums, "wuxing", wuxing_map, X)
    X = apply_group_feats(df, nums, "liuchong", liuchong_map, X)
    X = apply_group_feats(df, nums, "qizheng", qizheng_map, X)

    # =========================
    # 型別壓縮
    # =========================
    _prog("型別壓縮：")
    for col in X.select_dtypes(include=["float64"]).columns:
        X[col] = X[col].astype(np.float32)
    for col in X.select_dtypes(include=["int64"]).columns:
        X[col] = X[col].astype(np.int32)

    # ✅ 最後收尾（把最後一段進度行收掉）
    _end_block()

    FEATURE_CACHE[cache_key] = X.copy()
    return X


def build_full_features_once(df, *, control=None):
    nums = ["正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"]
    features = nums + ["落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5"]

    def _fe_progress(msg, i=None, n=None):
        try:
            if control and hasattr(control, "set_status"):
                if i is not None and n is not None:
                    control.set_status(f"{msg}（{i}/{n}）")
                else:
                    control.set_status(str(msg))
        except Exception:
            pass

    X_full = feature_engineering(df, nums, features, progress=_fe_progress)
    base_columns = list(X_full.columns)
    return X_full, base_columns, nums, features


def fix_columns(df, columns):
    return df.reindex(columns=columns, fill_value=0)


# ==============================================
# 彩金盈虧計算
# ==============================================
def calc_prize(hits_list, top_n, payout_mode="casino", lehecai_play_ks=(2, 3, 4), tw539_pick_n=None):
    """
    回測盈虧模擬（支援 3 種模式）：
    1) casino   ：線上娛樂城（2/3/4合，組合注數計算）
    2) lotto539 ：今彩539（簽n顆，通用公式：成本=50*C(n,5)，獎金=Σ Nk*獎金(k)）
    3) lehecai  ：39樂合彩（二合/三合/四合，可複選；每注25元）

    參數:
      - hits_list: 每期命中數列表（命中=你選的 n 顆 與實際5顆交集數 r）
      - top_n:     你選的號碼數（用於 casino / lehecai / tw539）
      - payout_mode: "casino" | "lotto539" | "lehecai"
      - lehecai_play_ks: (2,3,4) 中可複選
      - tw539_pick_n: 今彩539簽號數（若未給，直接用 top_n）
    回傳 dict:
      - detail: 各玩法詳細
      - total_cost / total_prize / total_profit
    """
    payout_mode = (payout_mode or "casino").strip().lower()

    # ---------- mode: casino ----------
    if payout_mode == "casino":
        JACKPOTS = {
            "2星": {"cost": 10, "prize": 72},
            "3星": {"cost": 1, "prize": 883},
            "4星": {"cost": 1, "prize": 15300},
        }
        total = {k: {'win': 0, 'bets': 0, 'cost': 0, 'prize': 0, 'profit': 0} for k in JACKPOTS}

        for hit in hits_list:
            hit = int(hit)
            comb2 = comb(hit, 2) if hit >= 2 else 0
            total['2星']['win'] += comb2
            total['2星']['bets'] += comb(top_n, 2) if top_n >= 2 else 0

            comb3 = comb(hit, 3) if hit >= 3 else 0
            total['3星']['win'] += comb3
            total['3星']['bets'] += comb(top_n, 3) if top_n >= 3 else 0

            comb4 = comb(hit, 4) if hit >= 4 else 0
            total['4星']['win'] += comb4
            total['4星']['bets'] += comb(top_n, 4) if top_n >= 4 else 0

        total_cost = 0
        total_prize = 0
        for k in JACKPOTS:
            total[k]['cost'] = total[k]['bets'] * JACKPOTS[k]['cost']
            total[k]['prize'] = total[k]['win'] * JACKPOTS[k]['cost'] * JACKPOTS[k]['prize']
            total[k]['profit'] = total[k]['prize'] - total[k]['cost']
            total_cost += total[k]['cost']
            total_prize += total[k]['prize']

        total['total_cost'] = int(total_cost)
        total['total_prize'] = int(total_prize)
        total['total_profit'] = int(total_prize - total_cost)
        total['mode'] = 'casino'
        return total

    # ---------- mode: lotto539 (通用公式版) ----------
    if payout_mode in ("lotto539", "539", "tw539"):
        pick_n = int(tw539_pick_n) if tw539_pick_n is not None else int(top_n)

        # 今彩539：至少要簽 5 顆才有拆注意義；若小於 5，視為 5（避免 comb(n,5)=0）
        if pick_n < 5:
            pick_n = 5

        # 單注(5顆)獎金表（官方 539 5顆下注的固定獎金）
        payout_5 = {2: 50, 3: 300, 4: 20000, 5: 8000000}

        # 成本：50 * C(n,5)
        bets_per_draw = comb(pick_n, 5) if pick_n >= 5 else 0
        cost_per_draw = 50 * bets_per_draw
        total_cost = int(cost_per_draw) * int(len(hits_list))

        # 依通用公式累加：Nk = C(r,k) * C(n-r, 5-k)
        # 總獎金 = Σ Nk * payout_5[k]，k=2..min(5,r)
        win_bets_counter = {2: 0, 3: 0, 4: 0, 5: 0}   # 累積「中k顆的注數」
        total_prize = 0

        for r in hits_list:
            r = int(r)
            if r < 2:
                continue
            max_k = 5 if r >= 5 else r
            for k in range(2, max_k + 1):
                # 若 (5-k) > (n-r) 則 comb 會是 0（Python comb 對不合理參數會丟錯，所以先判斷）
                need = 5 - k
                have = pick_n - r
                if need < 0 or have < 0 or have < need:
                    Nk = 0
                else:
                    Nk = comb(r, k) * comb(have, need)
                if Nk:
                    win_bets_counter[k] += int(Nk)
                    total_prize += int(Nk) * int(payout_5[k])

        detail = {}
        for k in (2, 3, 4, 5):
            detail[f"中{k}"] = {
                "bets_win": int(win_bets_counter.get(k, 0)),     # 中獎注數
                "prize_each": int(payout_5[k]),                 # 單注獎金
                "prize": int(win_bets_counter.get(k, 0)) * int(payout_5[k]),
            }

        out = {
            "mode": "lotto539",
            "pick_n": int(pick_n),
            "bets_per_draw": int(bets_per_draw),
            "cost_per_draw": int(cost_per_draw),
            "detail": detail,
            "total_cost": int(total_cost),
            "total_prize": int(total_prize),
            "total_profit": int(total_prize - total_cost),
        }
        return out

    # ---------- mode: lehecai ----------
    if payout_mode in ("lehecai", "39", "39樂合彩", "lehecai39"):
        play_ks = []
        for k in (2, 3, 4):
            if k in set(int(x) for x in (lehecai_play_ks or ())):
                play_ks.append(k)
        if not play_ks:
            play_ks = [2, 3, 4]

        payout_per_bet = {2: 1125, 3: 11250, 4: 212500}
        cost_per_bet = 25

        total_cost = 0
        total_prize = 0
        detail = {}

        for k in play_ks:
            bets_per_draw = comb(top_n, k) if top_n >= k else 0
            cost = bets_per_draw * cost_per_bet * len(hits_list)

            win = 0
            for hit in hits_list:
                hit = int(hit)
                win += comb(hit, k) if hit >= k else 0

            prize = win * payout_per_bet[k]

            detail[f"{k}合"] = {
                "bets_per_draw": int(bets_per_draw),
                "total_bets": int(bets_per_draw) * int(len(hits_list)),
                "win": int(win),
                "cost": int(cost),
                "prize": int(prize),
                "profit": int(prize - cost),
                "payout_each": int(payout_per_bet[k]),
            }

            total_cost += cost
            total_prize += prize

        out = {
            "mode": "lehecai",
            "plays": play_ks,
            "detail": detail,
            "total_cost": int(total_cost),
            "total_prize": int(total_prize),
            "total_profit": int(total_prize - total_cost),
        }
        return out

    return {"mode": payout_mode, "detail": {}, "total_cost": 0, "total_prize": 0, "total_profit": 0}


# ==============================================
# 錯題本：只讀「真實預測對獎」結果（避免回測污染）
# ==============================================
def load_penalty_from_real_results(result_file="latest_predict_result.csv"):
    penalty = np.zeros(39, dtype=np.float32)
    if not os.path.exists(result_file):
        return penalty

    try:
        df = pd.read_csv(result_file, dtype=str)
    except Exception:
        return penalty

    for _, r in df.iterrows():
        pred = str(r.get("預測號碼", "")).strip()
        ans = str(r.get("開獎號碼", "")).strip()
        hit_s = str(r.get("命中數", "")).strip()

        if not pred or not ans:
            continue

        try:
            pred_nums = [int(x) for x in pred.split(",") if x.strip().isdigit()]
            ans_nums = [int(x) for x in ans.split(",") if x.strip().isdigit()]
            hit = int(hit_s) if hit_s.isdigit() else len(set(pred_nums) & set(ans_nums))
        except Exception:
            continue

        if hit >= 2:
            continue

        w = 3.0 if hit == 0 else 2.0
        miss_nums = sorted(set(pred_nums) - set(ans_nums))
        for m in miss_nums:
            if 1 <= m <= 39:
                penalty[m - 1] += w

    return penalty


# ==============================================
# 多模型：XGB / LGBM / CatBoost / Logistic / RF（MultiOutput） + CRF
# ==============================================
def _seed(seed_offset=0):
    if USE_DETERMINISTIC:
        return int((GLOBAL_SEED + seed_offset) % (2**32 - 1))
    raw = int(time.time_ns()) + random.randint(0, 1_000_000)
    return int(raw % (2**32 - 1))


def make_base_estimator(model_name, seed_offset=0):
    n_cpu = max(1, multiprocessing.cpu_count() - 1)

    if model_name == "XGBoost":
        params_fast = dict(n_estimators=60, max_depth=3, learning_rate=0.12, subsample=0.8, colsample_bytree=0.8)
        params_full = dict(n_estimators=160, max_depth=4, learning_rate=0.10, subsample=0.9, colsample_bytree=0.9)
        params = params_fast if FAST_MODE else params_full
        return XGBClassifier(
            tree_method="hist",
            use_label_encoder=False,
            eval_metric="logloss",
            n_jobs=n_cpu,
            verbosity=0,
            random_state=_seed(seed_offset),
            **params
        )

    if model_name == "LightGBM":
        params_fast = dict(n_estimators=120, num_leaves=31, learning_rate=0.08, subsample=0.9, colsample_bytree=0.9)
        params_full = dict(n_estimators=300, num_leaves=63, learning_rate=0.06, subsample=0.9, colsample_bytree=0.9)
        params = params_fast if FAST_MODE else params_full
        return LGBMClassifier(
            **params,
            n_jobs=n_cpu,
            random_state=_seed(seed_offset),
            verbose=-1
        )

    if model_name == "CatBoost":
        params_fast = dict(iterations=120, depth=4, learning_rate=0.12)
        params_full = dict(iterations=500, depth=5, learning_rate=0.10)
        params = params_fast if FAST_MODE else params_full

        run_dir = os.path.join(catboost_train_dir, f"run_{os.getpid()}_{int(time.time() * 1000)}")
        os.makedirs(run_dir, exist_ok=True)

        return CatBoostSklearnCompat(
            task_type="CPU",
            thread_count=n_cpu,
            verbose=0,
            train_dir=run_dir,
            allow_writing_files=True,
            random_seed=_seed(seed_offset),
            **params
        )

    if model_name == "Logistic":
        max_iter = 3000 if FAST_MODE else 8000
        tol = 1e-3 if FAST_MODE else 5e-4
        base_lr = LogisticRegression(
            C=1.0,
            max_iter=max_iter,
            tol=tol,
            solver="saga",
            penalty="l2",
            n_jobs=1
        )
        return Pipeline([
            ("scaler", StandardScaler()),
            ("clf", base_lr)
        ])

    if model_name == "RandomForest":
        params_fast = dict(n_estimators=80, max_depth=7)
        params_full = dict(n_estimators=200, max_depth=None)
        params = params_fast if FAST_MODE else params_full
        return RandomForestClassifier(
            **params,
            n_jobs=n_cpu,
            random_state=_seed(seed_offset)
        )

    raise ValueError("Unknown model")


def make_multi_model(model_name, seed_offset=0):
    base = make_base_estimator(model_name, seed_offset=seed_offset)
    return MultiOutputClassifier(base, n_jobs=1)


def proba_from_multioutput(mo_clf, X_pred_row):
    probas = []
    for est in mo_clf.estimators_:
        p = est.predict_proba(X_pred_row)
        if p.shape[1] == 2:
            probas.append(float(p[0, 1]))
        else:
            probas.append(float(p[0, 0]))
    return np.array(probas, dtype=np.float32)


# ==============================================
# CRF：每期一條序列（1~39）做序列預測
# ==============================================
def crf_token_features_from_row(row, n):
    fmt = f"{n:02d}"
    feat = {
        "n": n,
        "n_mod10": n % 10,
        "n_bin": n // 10,
        "hot_all": float(row.get(f"hot_{fmt}_all", 0.0)),
        "hot_5": float(row.get(f"hot_{fmt}_5", 0.0)),
        "hot_10": float(row.get(f"hot_{fmt}_10", 0.0)),
        "hot_20": float(row.get(f"hot_{fmt}_20", 0.0)),
        "hot_30": float(row.get(f"hot_{fmt}_30", 0.0)),
        "miss": float(row.get(f"miss_{fmt}", 0.0)),
        "odd_cnt": int(row.get("odd_count", 0)),
        "even_cnt": int(row.get("even_count", 0)),
        "serial_cnt": int(row.get("serial_count", 0)),
        "repeat_prev": int(row.get("repeat_prev", 0)),
        "big_small": float(row.get("big_small_score", 0.0)),
    }
    return feat


def build_crf_seq_features(X_bt, idx):
    row = X_bt.iloc[idx]
    return [crf_token_features_from_row(row, n) for n in range(1, 40)]


def build_crf_labels(y_all, idx):
    row = y_all.iloc[idx]
    return ['1' if int(row[f"y_{n:02d}"]) == 1 else '0' for n in range(1, 40)]


def fit_crf(X_bt, y_all, start_idx, end_idx, seed_offset=0):
    X_seqs = [build_crf_seq_features(X_bt, t) for t in range(start_idx, end_idx)]
    y_seqs = [build_crf_labels(y_all, t) for t in range(start_idx, end_idx)]
    max_iter = 60 if FAST_MODE else 150
    crf = sklearn_crfsuite.CRF(
        algorithm='lbfgs',
        c1=0.1, c2=0.1,
        max_iterations=max_iter,
        all_possible_transitions=True
    )
    with suppress_all_output(True):
        crf.fit(X_seqs, y_seqs)
    return crf


def crf_predict_proba(crf, X_bt, idx):
    feats = build_crf_seq_features(X_bt, idx)
    marginals = crf.predict_marginals_single(feats)
    probs = [float(m.get('1', 0.0)) for m in marginals]
    return np.array(probs, dtype=np.float32)


# ==============================================
# 版路拖牌：保留你原本功能（完整）
# ==============================================
def _build_rows_for_mode(df_bt_use, nums, mode):
    if mode == "size":
        seqs = []
        for _, row in df_bt_use.iterrows():
            arr = sorted(int(row[c]) for c in nums)
            seqs.append(arr)
        return seqs
    elif mode == "order":
        cols = [f"落序號碼{i}" for i in range(1, 6)]
        seqs = df_bt_use[cols].astype(int).values.tolist()
        return seqs
    else:
        raise ValueError("mode must be 'size' or 'order'")


def _analyze_pattern_unpos_next(seqs, dates, A, B, lag, last_base_idx):
    N = len(seqs)
    if N <= lag or last_base_idx < 0 or last_base_idx >= N:
        return None
    if A not in set(seqs[last_base_idx]):
        return None

    events = []
    for base_idx in range(0, N - lag):
        if A not in set(seqs[base_idx]):
            continue
        drag_idx = base_idx + lag
        is_success = (B in set(seqs[drag_idx]))
        events.append((base_idx, drag_idx, is_success))

    if not events:
        return None

    success_count = sum(1 for e in events if e[2])
    fail_count = len(events) - success_count
    if success_count < MIN_CHAIN_RUN:
        return None

    valid_events = [e for e in events if e[0] < last_base_idx]
    if not valid_events:
        return None

    valid_events.sort(key=lambda x: x[0], reverse=True)

    chain_run = 0
    tail_events = []
    for base_idx, drag_idx, is_success in valid_events:
        tail_events.append((base_idx, drag_idx, is_success))
        if is_success:
            chain_run += 1
        else:
            break

    if chain_run < MIN_CHAIN_RUN:
        return None

    total_events = success_count + fail_count
    success_rate = success_count / total_events if total_events > 0 else 0.0

    last_success_drag_date = None
    for base_idx, drag_idx, is_success in valid_events:
        if is_success:
            last_success_drag_date = dates[drag_idx]
            break

    return {
        "A": A,
        "B": B,
        "lag": lag,
        "chain_run": chain_run,
        "last_base_date": dates[last_base_idx],
        "last_success_drag_date": last_success_drag_date,
        "success_count": success_count,
        "fail_count": fail_count,
        "success_rate": success_rate,
        "tail_events": tail_events[:50],
        "predict_target": "NEXT"
    }


def _analyze_pattern_pos_next(seqs, dates, A, B, lag, pos_a, pos_b, last_base_idx):
    N = len(seqs)
    if N <= lag or last_base_idx < 0 or last_base_idx >= N:
        return None
    if seqs[last_base_idx][pos_a] != A:
        return None

    events = []
    for base_idx in range(0, N - lag):
        if seqs[base_idx][pos_a] != A:
            continue
        drag_idx = base_idx + lag
        is_success = (seqs[drag_idx][pos_b] == B)
        events.append((base_idx, drag_idx, is_success))

    if not events:
        return None

    success_count = sum(1 for e in events if e[2])
    fail_count = len(events) - success_count
    if success_count < MIN_CHAIN_RUN:
        return None

    valid_events = [e for e in events if e[0] < last_base_idx]
    if not valid_events:
        return None

    valid_events.sort(key=lambda x: x[0], reverse=True)

    chain_run = 0
    tail_events = []
    for base_idx, drag_idx, is_success in valid_events:
        tail_events.append((base_idx, drag_idx, is_success))
        if is_success:
            chain_run += 1
        else:
            break

    if chain_run < MIN_CHAIN_RUN:
        return None

    total_events = success_count + fail_count
    success_rate = success_count / total_events if total_events > 0 else 0.0

    last_success_drag_date = None
    for base_idx, drag_idx, is_success in valid_events:
        if is_success:
            last_success_drag_date = dates[drag_idx]
            break

    return {
        "A": A,
        "B": B,
        "lag": lag,
        "pos_a": pos_a,
        "pos_b": pos_b,
        "chain_run": chain_run,
        "last_base_date": dates[last_base_idx],
        "last_success_drag_date": last_success_drag_date,
        "success_count": success_count,
        "fail_count": fail_count,
        "success_rate": success_rate,
        "tail_events": tail_events[:50],
        "predict_target": "NEXT"
    }


def _format_unpos_block_next(label, res, dates):
    A = res["A"]; B = res["B"]; lag = res["lag"]
    chain_run = res["chain_run"]
    base_date = res["last_base_date"]
    last_success_drag_date = res["last_success_drag_date"]
    sc = res["success_count"]; fc = res["fail_count"]
    total = sc + fc
    rate = sc / total if total > 0 else 0.0

    lines = []
    lines.append(label)
    lines.append(f"【預測目標】以最新開獎日 {base_date} 為起點 → 預測隔 {lag} 期可能拖出")
    lines.append(f"起始牌(A)：{A:02d}")
    lines.append(f"拖牌(B)：{B:02d}")
    lines.append("")
    lines.append("--- 近期連版（由近到遠，最後一次為可驗證歷史）---")

    tail = res["tail_events"]
    for base_idx, drag_idx, is_success in tail:
        base_d = dates[base_idx]
        drag_d = dates[drag_idx]
        mark = "✔" if is_success else "✖"
        extra = "   ← 斷點" if (not is_success) else ""
        lines.append(
            f"{base_d} 出現A {A:02d} → {drag_d} "
            f"{'出現' if is_success else '未出現'}B {B:02d} {mark}{extra}"
        )

    lines.append("")
    lines.append(f"近期連版：{chain_run} 次（最近連續 {chain_run} 次 A 出現後，隔 {lag} 期都有出 B）")
    if last_success_drag_date is not None:
        lines.append(f"最近一次成功拖出日期：{last_success_drag_date}")
    lines.append(f"成功紀錄共：{sc} 次")
    lines.append(f"失敗紀錄共：{fc} 次")
    lines.append(f"成功率：{sc} / {total} = {rate * 100:.1f}%")
    lines.append("--------------------------------")
    return "\n".join(lines)


def _format_pos_block_next(label, res, dates):
    A = res["A"]; B = res["B"]; lag = res["lag"]
    chain_run = res["chain_run"]
    base_date = res["last_base_date"]
    last_success_drag_date = res["last_success_drag_date"]
    sc = res["success_count"]; fc = res["fail_count"]
    total = sc + fc
    rate = sc / total if total > 0 else 0.0
    pos_a = res["pos_a"] + 1
    pos_b = res["pos_b"] + 1

    lines = []
    lines.append(label)
    lines.append(f"【預測目標】以最新開獎日 {base_date} 為起點 → 預測隔 {lag} 期可能拖出")
    lines.append(f"起始牌(A)：{A:02d}")
    lines.append(f"拖牌(B)：{B:02d}")
    lines.append(f"定位：起牌第 {pos_a} 球 → 拖牌第 {pos_b} 球")
    lines.append("")
    lines.append("--- 近期連版（由近到遠）---")

    tail = res["tail_events"]
    for base_idx, drag_idx, is_success in tail:
        base_d = dates[base_idx]
        drag_d = dates[drag_idx]
        mark = "✔" if is_success else "✖"
        extra = "   ← 斷點" if (not is_success) else ""
        lines.append(
            f"{base_d} (第{pos_a}球)=A {A:02d} → {drag_d} "
            f"{'出現' if is_success else '未出現'}(第{pos_b}球)=B {B:02d} {mark}{extra}"
        )

    lines.append("")
    lines.append(f"近期連版：{chain_run} 次")
    if last_success_drag_date is not None:
        lines.append(f"最近一次成功拖出日期：{last_success_drag_date}")
    lines.append(f"成功紀錄共：{sc} 次")
    lines.append(f"失敗紀錄共：{fc} 次")
    lines.append(f"成功率：{sc} / {total} = {rate * 100:.1f}%")
    lines.append("--------------------------------")
    return "\n".join(lines)


# ✅ 保留單一版本（避免重複定義覆蓋）
def analyze_drag_layers(drag_results):
    """
    drag_results: list[dict]，每個 dict 至少包含:
      - "B": 拖牌號碼
      - "chain_run": 近期連版次數（>=2 才有被收錄）
      - "success_count": 成功次數
      - "fail_count": 失敗次數

    回傳:
      - layer2_txt: 連2版號碼字串
      - layer3_txt: 連>=3版號碼字串
      - prob_rank:  [(num, hit, prob), ...] 依機率排序（機率 = 成功 / (成功+失敗)）
      - mark_level: dict[num] = 2 or 3  (用於符號標示)
    """
    if not drag_results:
        return "", "", [], {}

    best_chain = {}   # num -> max(chain_run)
    prob_stats = {}   # num -> (success, total)

    for r in drag_results:
        try:
            b = int(r.get("B", 0))
            chain = int(r.get("chain_run", 0))
            sc = int(r.get("success_count", 0))
            fc = int(r.get("fail_count", 0))
            total = sc + fc
            if b <= 0:
                continue
        except Exception:
            continue

        best_chain[b] = max(best_chain.get(b, 0), chain)

        old_sc, old_total = prob_stats.get(b, (0, 0))
        prob_stats[b] = (old_sc + sc, old_total + total)

    layer2 = sorted([n for n, c in best_chain.items() if c == 2])
    layer3 = sorted([n for n, c in best_chain.items() if c >= 3])

    layer2_txt = "[" + ", ".join(f"{n:02d}" for n in layer2) + "]" if layer2 else ""
    layer3_txt = "[" + ", ".join(f"{n:02d}" for n in layer3) + "]" if layer3 else ""

    prob_rank = []
    for n, (sc, total) in prob_stats.items():
        if total <= 0:
            continue
        prob = sc / total
        prob_rank.append((n, sc, prob))
    prob_rank.sort(key=lambda x: (x[2], x[1], x[0]), reverse=True)

    mark_level = {}
    for n, c in best_chain.items():
        if c >= 3:
            mark_level[n] = 3
        elif c == 2:
            mark_level[n] = 2

    return layer2_txt, layer3_txt, prob_rank, mark_level


# ✅ 修改：compute_drag_notebooks() 回傳拖牌結果清單（提供 analyze_drag_layers 用）
def compute_drag_notebooks(df_bt, nums, predict_lags=1):
    if not DRAG_ENABLE:
        msg = "（未啟用版路拖牌功能 DRAG_ENABLE=False）\n"
        return msg, msg, msg, msg, set(), []

    def _ensure_not_empty(txt, title, lag_list):
        if txt is None or str(txt).strip() == "":
            return (
                f"{title}\n"
                f"搜尋不到拖牌資訊（條件過嚴或樣本不足）。\n"
                f"（目前設定：預測隔 {lag_list} 期、MIN_CHAIN_RUN={MIN_CHAIN_RUN}）\n"
            )
        return txt

    try:
        if DRAG_MAX_ROWS is not None and len(df_bt) > DRAG_MAX_ROWS:
            df_bt_use = df_bt.tail(DRAG_MAX_ROWS).reset_index(drop=True)
        else:
            df_bt_use = df_bt.copy().reset_index(drop=True)

        if len(df_bt_use) < 2:
            msg = "資料不足，無法計算拖牌（至少需要 2 期以上）。\n"
            return msg, msg, msg, msg, set(), []

        dates = df_bt_use["日期"].dt.date.tolist()
        last_base_idx = len(dates) - 1
        last_base_date = dates[last_base_idx]

        if isinstance(predict_lags, (list, tuple, set, np.ndarray)):
            lag_list = sorted({int(x) for x in predict_lags if str(x).strip().isdigit() and int(x) >= 1})
        else:
            lag_list = [int(predict_lags)]
        if not lag_list:
            lag_list = [1]

        print(f"\n==== 開始計算版路拖牌（以最新開獎日為起點：{last_base_date}，預測隔 {lag_list} 期）====")
        t0 = time.time()

        size_seqs = _build_rows_for_mode(df_bt_use, nums, mode="size")
        order_seqs = _build_rows_for_mode(df_bt_use, nums, mode="order")

        drag_nums_size_unpos = set()
        drag_nums_size_pos = set()
        drag_nums_order_unpos = set()
        drag_nums_order_pos = set()

        drag_result_all = []  # ✅ 保留（不刪）
        drag_result = []      # ✅ 最終回傳（給 analyze_drag_layers）

        # ✅ 必須先定義，後面才能呼叫（修正 NameError）
        def _append_drag_results(results_list, src_name):
            for r in results_list:
                try:
                    drag_result.append({
                        "B": int(r.get("B")),
                        "chain_run": int(r.get("chain_run", 0)),
                        "lag": int(r.get("lag", 0)),
                        "src": str(src_name),
                        "success_count": int(r.get("success_count", 0)),
                        "fail_count": int(r.get("fail_count", 0)),
                    })
                except Exception:
                    continue

        def build_unpos_notebook_next(seqs, label_header, collect_set):
            results = []
            base_row = seqs[last_base_idx]
            base_set = set(base_row)

            for lag in lag_list:
                for A in sorted(base_set):
                    for B in range(1, 40):
                        res = _analyze_pattern_unpos_next(seqs, dates, A, B, lag, last_base_idx)
                        if res is not None:
                            results.append(res)
                            collect_set.add(B)

            results.sort(key=lambda r: (r["lag"], -r["chain_run"], -r["success_rate"], r["A"], r["B"]))
            blocks = []
            for r in results:
                blocks.append(_format_unpos_block_next(label_header, r, dates))
            return "\n\n".join(blocks), results

        def build_pos_notebook_next(seqs, label_header, collect_set):
            results = []
            base_row = seqs[last_base_idx]

            for lag in lag_list:
                for pos_a, A in enumerate(base_row):
                    for pos_b in range(5):
                        for B in range(1, 40):
                            res = _analyze_pattern_pos_next(seqs, dates, A, B, lag, pos_a, pos_b, last_base_idx)
                            if res is not None:
                                results.append(res)
                                collect_set.add(B)

            results.sort(key=lambda r: (r["lag"], -r["chain_run"], -r["success_rate"], r["A"], r["B"]))
            blocks = []
            for r in results:
                blocks.append(_format_pos_block_next(label_header, r, dates))
            return "\n\n".join(blocks), results

        # ✅ 修正：build_* 只回 (txt, results) 兩個值
        txt_size_unpos, res_size_unpos = build_unpos_notebook_next(size_seqs, "【大小序 / 不定位】", drag_nums_size_unpos)
        txt_size_pos,   res_size_pos   = build_pos_notebook_next(size_seqs, "【大小序 / 定位】",   drag_nums_size_pos)
        txt_order_unpos, res_order_unpos = build_unpos_notebook_next(order_seqs, "【落球序 / 不定位】", drag_nums_order_unpos)
        txt_order_pos,  res_order_pos  = build_pos_notebook_next(order_seqs, "【落球序 / 定位】",   drag_nums_order_pos)

        # ✅ 收集拖牌結果（提供 analyze_drag_layers）
        _append_drag_results(res_size_unpos,  "size_unpos")
        _append_drag_results(res_size_pos,    "size_pos")
        _append_drag_results(res_order_unpos, "order_unpos")
        _append_drag_results(res_order_pos,   "order_pos")

        # ✅ 保留 drag_result_all（不刪功能）
        drag_result_all.extend(res_size_unpos)
        drag_result_all.extend(res_size_pos)
        drag_result_all.extend(res_order_unpos)
        drag_result_all.extend(res_order_pos)

        txt_size_unpos = _ensure_not_empty(txt_size_unpos, "【大小序 / 不定位】", lag_list)
        txt_size_pos   = _ensure_not_empty(txt_size_pos,   "【大小序 / 定位】",   lag_list)
        txt_order_unpos = _ensure_not_empty(txt_order_unpos, "【落球序 / 不定位】", lag_list)
        txt_order_pos  = _ensure_not_empty(txt_order_pos,  "【落球序 / 定位】",   lag_list)

        drag_hint_nums_all = (drag_nums_size_unpos | drag_nums_size_pos | drag_nums_order_unpos | drag_nums_order_pos)

        t1 = time.time()
        print(f"版路拖牌計算完成，耗時約 {t1 - t0:.2f} 秒。")
        return txt_size_unpos, txt_size_pos, txt_order_unpos, txt_order_pos, drag_hint_nums_all, drag_result

    except Exception as e:
        err = f"版路拖牌計算發生例外：{type(e).__name__}: {e}\n"
        msg = "搜尋不到拖牌資訊（執行時發生例外）。\n" + err
        return msg, msg, msg, msg, set(), []


# ==============================================
# 推估下一次開獎日（週一~週六）+ 公告校正
# ==============================================
def _parse_dates_from_text(text):
    if not text:
        return set()

    found = set()

    for m in re.findall(r"(20\d{2})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})", text):
        y, mo, d = int(m[0]), int(m[1]), int(m[2])
        try:
            found.add(datetime(y, mo, d).date())
        except Exception:
            pass

    for m in re.findall(r"(\d{2,3})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})", text):
        yy, mo, d = int(m[0]), int(m[1]), int(m[2])
        if 1 <= yy <= 199:
            y = yy + 1911
            try:
                found.add(datetime(y, mo, d).date())
            except Exception:
                pass

    return found


def fetch_twlottery_announcement_dates_539(lookahead_days=45, *, status_cb=None, max_total_sec=8.0):
    candidate_urls = [
        "https://www.taiwanlottery.com.tw/",
        "https://www.taiwanlottery.com.tw/Upload/",
        "https://www.taiwanlottery.com.tw/lotto/Lotto539/history.aspx",
        "https://www.taiwanlottery.com.tw/News/News.aspx",
        "https://www.taiwanlottery.com.tw/News/NewsList.aspx",
    ]

    t0 = time.time()
    all_dates = set()
    total = len(candidate_urls)

    for k, url in enumerate(candidate_urls, 1):
        # ✅ 總耗時上限：避免網路差時卡太久
        if (time.time() - t0) >= float(max_total_sec):
            break

        msg = f"查詢台彩公告網址 ({k}/{total})"
        if status_cb:
            try:
                status_cb(msg)
            except Exception:
                pass
        if bool(globals().get("GUI_VERBOSE_STAGE", True)):
            print(msg)

        html = _fetch_text(url, timeout=6)
        if not html:
            continue
        all_dates |= _parse_dates_from_text(html)

    today = datetime.now().date()
    upper = today + timedelta(days=int(lookahead_days))
    all_dates = {d for d in all_dates if today <= d <= upper}
    all_dates = {d for d in all_dates if d.weekday() != 6}  # 排除週日
    return all_dates


def infer_next_draw_date_tw539_with_announcement(past_dates, *, status_cb=None):
    now_date = datetime.now().date()
    base = now_date if (not past_dates) else past_dates[-1]
    s = set(past_dates) if past_dates else set()

    # 先用「不重複且非週日」的 cand 當保底答案
    cand = base + timedelta(days=1)
    for _ in range(60):
        if cand.weekday() != 6 and cand not in s:
            break
        cand += timedelta(days=1)

    t0 = time.time()
    if status_cb:
        try:
            status_cb("查詢台彩公告中（若網路慢會自動跳過）")
        except Exception:
            pass
    if bool(globals().get("GUI_VERBOSE_STAGE", True)):
        print("==== 查詢台彩公告中（若網路慢會自動跳過） ====")

    try:
        announced = fetch_twlottery_announcement_dates_539(
            lookahead_days=60,
            status_cb=status_cb,
            max_total_sec=float(globals().get("ANNOUNCE_FETCH_MAX_SEC", 8.0)),
        )
    except Exception:
        announced = set()

    if bool(globals().get("GUI_VERBOSE_STAGE", True)):
        print(f"==== 公告查詢完成，耗時 {time.time()-t0:.2f} 秒 ====")

    candidates = set([cand]) | set(announced)
    future_candidates = sorted([d for d in candidates if d > now_date])
    return future_candidates[0] if future_candidates else cand


# ==============================================
# Walk-forward：統一訓練/預測封裝
# ==============================================
def fit_model_for_i(model_name, X_bt, y_all, base_columns, start_idx, i, seed_offset=0):
    if model_name == "CRF":
        return fit_crf(X_bt, y_all, start_idx, i, seed_offset=seed_offset)

    y_cols = [f"y_{k:02d}" for k in range(1, 40)]
    X_train = fix_columns(X_bt.iloc[start_idx:i], base_columns)
    y_train = y_all[y_cols].iloc[start_idx:i]

    mo = make_multi_model(model_name, seed_offset=seed_offset)
    with suppress_all_output(True):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            mo.fit(X_train, y_train)
    return mo


def predict_scores_for_i(model_name, model_obj, X_bt, base_columns, i):
    if model_name == "CRF":
        with suppress_all_output(True):
            return crf_predict_proba(model_obj, X_bt, i)

    X_pred = fix_columns(X_bt.iloc[[i]], base_columns)
    with suppress_all_output(True):
        return proba_from_multioutput(model_obj, X_pred)




# ==============================================
# ✅ 人類三大規則(1+2+3) + AB 對照 + 自動參數搜尋
# 1. 奇偶：避免全奇/全偶；偏好 3奇2偶 或 2奇3偶
# 2. 尾數：至少含一組同尾(例如 03/13)
# 3. 連號：避免同時出現兩組連號或三連號（預設最多 1 組連號、且不允許三連號）
# ==============================================

def _odd_even_ok(nums, prefer_set={(2,3),(3,2)}, allow_other=True):
    odd = sum(n % 2 for n in nums)
    even = len(nums) - odd
    if odd == 0 or even == 0:
        return False
    if (odd, even) in prefer_set:
        return True
    return bool(allow_other)


def _has_same_tail_pair(nums):
    tails = [n % 10 for n in nums]
    c = Counter(tails)
    return any(v >= 2 for v in c.values())


def _adjacent_pairs_count(nums):
    s = sorted(set(int(x) for x in nums))
    return sum(1 for i in range(len(s)-1) if s[i+1]-s[i]==1)


def _has_triple_consecutive(nums):
    s = sorted(set(int(x) for x in nums))
    if len(s) < 3:
        return False
    st = set(s)
    for x in s:
        if (x+1) in st and (x+2) in st:
            return True
    return False


def _satisfy_human_rules(nums, prefer_odd_even=True, require_tail_pair=True,
                         max_adj_pairs=1, forbid_triple=True):
    nums = sorted(set(int(x) for x in nums))
    if len(nums) != 5:
        return False

    if prefer_odd_even:
        if not _odd_even_ok(nums, prefer_set={(2,3),(3,2)}, allow_other=False):
            return False
    else:
        # 只禁全奇/全偶
        if not _odd_even_ok(nums, prefer_set={(2,3),(3,2)}, allow_other=True):
            return False

    if require_tail_pair and (not _has_same_tail_pair(nums)):
        return False

    if forbid_triple and _has_triple_consecutive(nums):
        return False

    if _adjacent_pairs_count(nums) > int(max_adj_pairs):
        return False

    return True


def _hot_ranking_from_hist(df_hist, nums_cols, window=30):
    if window is not None and window > 0 and len(df_hist) > window:
        df_use = df_hist.tail(int(window))
    else:
        df_use = df_hist
    cnt = Counter()
    for _, r in df_use.iterrows():
        for c in nums_cols:
            try:
                cnt[int(r[c])] += 1
            except Exception:
                pass
    # 1..39 都補齊
    for n in range(1,40):
        cnt.setdefault(n, 0)
    # 頻率高→低，平手號碼小優先
    rank = sorted(range(1,40), key=lambda n: (-cnt[n], n))
    return rank, cnt


def _sample_best_ticket_from_pool(hot_rank, hot_cnt, pred_n=5, pool_size=18, n_samples=5000,
                                  prefer_odd_even=True, require_tail_pair=True,
                                  max_adj_pairs=1, forbid_triple=True,
                                  rng=None):
    rng = rng or random.Random(42)
    pool = list(hot_rank[:max(pred_n, int(pool_size))])

    best = None
    best_score = -1e18

    # 先做幾個 deterministic 組合（提高穩定性）
    def _score(nums):
        return sum(float(hot_cnt.get(int(x),0)) for x in nums)

    # 1) 直接拿前 pred_n
    base = sorted(pool[:pred_n])
    if _satisfy_human_rules(base, prefer_odd_even, require_tail_pair, max_adj_pairs, forbid_triple):
        best = base
        best_score = _score(base)

    # 2) 隨機抽樣
    for _ in range(int(n_samples)):
        cand = sorted(rng.sample(pool, pred_n))
        if not _satisfy_human_rules(cand, prefer_odd_even, require_tail_pair, max_adj_pairs, forbid_triple):
            continue
        sc = _score(cand)
        # tie-break：同分就選較小字典序
        if (sc > best_score) or (abs(sc-best_score) < 1e-9 and best is not None and cand < best):
            best = cand
            best_score = sc

    # fallback：若規則過嚴，放寬一次
    if best is None:
        for _ in range(int(n_samples)):
            cand = sorted(rng.sample(pool, pred_n))
            if _odd_even_ok(cand) and (_adjacent_pairs_count(cand) <= max(1,int(max_adj_pairs))):
                sc = _score(cand)
                if (sc > best_score) or (abs(sc-best_score) < 1e-9 and best is not None and cand < best):
                    best = cand
                    best_score = sc

    if best is None:
        best = sorted(pool[:pred_n])

    return best, best_score


def human_rules_ab_backtest(df_bt, nums_cols, backtest_N=300, pred_n=5,
                            window=30, pool_size=18, n_samples=4000,
                            prefer_odd_even=True, require_tail_pair=True,
                            max_adj_pairs=1, forbid_triple=True,
                            objective='hit_ge2_rate'):
    """
    AB 對照：
      - A：套用 1+2+3 規則
      - B：只用熱度（不套規則）

    objective:
      - 'hit_ge2_rate'：命中>=2 的比例（較符合玩家直覺）
      - 'mean_hit'：平均命中顆數

    回傳：dict
    """
    n = len(df_bt)
    if n < 3:
        return None

    # 回測用索引：用「預測 i -> 對照 i+1 開獎」
    feature_row_count = n - 1
    btN = int(min(max(10, backtest_N), feature_row_count-1))
    start_i = feature_row_count - btN

    rng = random.Random(123)

    recs = []
    hits_A, hits_B = [], []

    for i in range(start_i, feature_row_count):
        # history <= i（包含 i 期）用來預測 i+1
        df_hist = df_bt.iloc[:i+1]
        hot_rank, hot_cnt = _hot_ranking_from_hist(df_hist, nums_cols, window=window)

        # A：規則組
        ticket_A, _ = _sample_best_ticket_from_pool(
            hot_rank, hot_cnt, pred_n=pred_n, pool_size=pool_size, n_samples=n_samples,
            prefer_odd_even=prefer_odd_even, require_tail_pair=require_tail_pair,
            max_adj_pairs=max_adj_pairs, forbid_triple=forbid_triple, rng=rng
        )

        # B：純熱度（不套規則）
        ticket_B = sorted(hot_rank[:pred_n])

        real = [int(df_bt.iloc[i+1][c]) for c in nums_cols]

        hitA = len(set(ticket_A) & set(real))
        hitB = len(set(ticket_B) & set(real))

        hits_A.append(hitA)
        hits_B.append(hitB)

        recs.append({
            '預測基準期數': int(df_bt.iloc[i]['期數']),
            '被預測開獎期數': int(df_bt.iloc[i+1]['期數']),
            '被預測開獎日期': str(df_bt.iloc[i+1]['日期'].date()),
            'A_規則組': ','.join(f"{x:02d}" for x in ticket_A),
            'B_熱度組': ','.join(f"{x:02d}" for x in ticket_B),
            '開獎號碼': ','.join(f"{x:02d}" for x in sorted(real)),
            'A_命中': hitA,
            'B_命中': hitB,
        })

    hits_A = np.array(hits_A, dtype=np.int32)
    hits_B = np.array(hits_B, dtype=np.int32)

    if objective == 'mean_hit':
        scoreA = float(hits_A.mean())
        scoreB = float(hits_B.mean())
    else:
        scoreA = float((hits_A >= 2).mean())
        scoreB = float((hits_B >= 2).mean())

    return {
        'objective': objective,
        'A_score': scoreA,
        'B_score': scoreB,
        'A_mean': float(hits_A.mean()),
        'B_mean': float(hits_B.mean()),
        'A_ge2': float((hits_A >= 2).mean()),
        'B_ge2': float((hits_B >= 2).mean()),
        'A_ge3': float((hits_A >= 3).mean()),
        'B_ge3': float((hits_B >= 3).mean()),
        'records': recs,
        'best': 'A' if scoreA >= scoreB else 'B'
    }


def auto_search_human_rule_params(df_bt, nums_cols, backtest_N=300, pred_n=5, objective='hit_ge2_rate'):
    """用歷史數據自動找『人類規則』最穩的參數組合（小型網格搜尋，速度可接受）"""
    windows = [20, 30, 40, 60]
    pool_sizes = [15, 18, 21]
    max_adj_list = [1]  # 依你的規則：避免兩組連號，預設最多 1

    best = None
    best_key = None

    for w in windows:
        for pool in pool_sizes:
            for max_adj in max_adj_list:
                res = human_rules_ab_backtest(
                    df_bt, nums_cols,
                    backtest_N=backtest_N,
                    pred_n=pred_n,
                    window=w,
                    pool_size=pool,
                    n_samples=3000 if backtest_N <= 600 else 2000,
                    prefer_odd_even=True,
                    require_tail_pair=True,
                    max_adj_pairs=max_adj,
                    forbid_triple=True,
                    objective=objective
                )
                if res is None:
                    continue

                # 我們只看 A 的表現（因為搜尋的是規則參數）
                score = res['A_score']
                key = (score, res['A_mean'], -w, -pool, -max_adj)

                if (best is None) or (key > best_key):
                    best = {
                        'window': w,
                        'pool_size': pool,
                        'max_adj_pairs': max_adj,
                        'objective': objective,
                        'A_score': res['A_score'],
                        'A_mean': res['A_mean'],
                        'A_ge2': res['A_ge2'],
                        'A_ge3': res['A_ge3'],
                    }
                    best_key = key

    return best

# ==============================================
# 順球（位移差值傳遞）鏈條輸出（只做「最新開獎日」下一期預測）
# 規則（依你手算）：
# 1) 只取最新三期：
#    段1：最新-2 -> 最新-1（真實：A0(pos0)+d1 命中「下一期任一號碼」）
#    段2：最新-1 -> 最新（真實：A1(pos1)+d2 命中「下一期任一號碼」）
#    段3：最新 -> 下一期（預測：A2(pos2)+d3）
#
# 2) 支別規律（不循環、不跨界）：
#    - 固定：p, p, p
#    - 遞增：p, p+1, p+2（p+2 必須 <= 第五支）
#
# 3) 差值規律（整條鏈同正負，不混正負）：
#    - 固定：d, d, d
#    - 遞增：d, d+1, d+2
#    - 遞減：d, d-1, d-2
#    （也就是 d2 相對 d1 只能是 -1/0/+1；d3 由規律推出）
#
# 4) 邊界：
#    1 <= 結果 <= 39（不允許 <1 或 >39）
#    |d| <= 39，d 允許 0（若你不想要 d=0，可在下面關掉）
# ==============================================
def format_shift_chains_text(
    df,
    nums,
    max_chains=50,
    allow_d_zero=False,          # True 才允許 d=0；預設不允許（比較像你手算）
    predict_date=None,           # ✅ 新增：傳入「實際預測日期」（例如 "2026-01-22" 或 date/datetime）
    return_pred_rank=False       # ✅ 新增：是否回傳預測候選排序
):
    import pandas as pd
    from collections import Counter

    if df is None or len(df) < 3:
        txt = "（資料不足：至少需要 3 期，才能做『順球（規律差值）』）\n"
        if return_pred_rank:
            return txt, []
        return txt

    df_use = df.copy()
    if "日期" in df_use.columns:
        df_use["日期"] = pd.to_datetime(df_use["日期"], errors="coerce")

    def _md_str(dt):
        try:
            if isinstance(dt, pd.Timestamp) and pd.notna(dt):
                return f"{int(dt.month)}/{int(dt.day)}"
        except Exception:
            pass
        return ""

    def _md_str_any(x):
        # ✅ 接受 str / date / datetime / Timestamp，轉成 m/d；轉不出就回 ""
        try:
            if x is None:
                return ""
            if isinstance(x, pd.Timestamp):
                return _md_str(x)
            ts = pd.to_datetime(x, errors="coerce")
            if isinstance(ts, pd.Timestamp) and pd.notna(ts):
                return _md_str(ts)
        except Exception:
            pass
        return ""

    def _ball_label(pos0):
        return ["第一支", "第二支", "第三支", "第四支", "第五支"][pos0]

    def _n2(x):
        return f"{int(x):02d}"

    def _fmt_expr(a, d):
        a = int(a); d = int(d)
        if d >= 0:
            return f"{_n2(a)}+{d}"
        return f"{_n2(a)}{d}"  # 例如 18-1

    def _in_bound(x):
        x = int(x)
        return 1 <= x <= 39

    def _ok_d(d):
        d = int(d)
        if not allow_d_zero and d == 0:
            return False
        return abs(d) <= 39

    # ===== 只取最新三期 =====
    t0 = df_use.iloc[-3]  # 最新-2
    t1 = df_use.iloc[-2]  # 最新-1
    t2 = df_use.iloc[-1]  # 最新

    date0 = _md_str(t0["日期"]) if "日期" in df_use.columns else ""
    date1 = _md_str(t1["日期"]) if "日期" in df_use.columns else ""
    date2 = _md_str(t2["日期"]) if "日期" in df_use.columns else ""

    # ✅ 第三段日期：一律優先用外部傳入的「實際預測日期」
    date3 = _md_str_any(predict_date)

    # ✅ 若外部沒傳，才退回用 t2 + 1 天（但仍不會寫「下一期」）
    if not date3:
        try:
            if "日期" in df_use.columns and isinstance(t2["日期"], pd.Timestamp) and pd.notna(t2["日期"]):
                date3 = _md_str(t2["日期"] + pd.Timedelta(days=1))
        except Exception:
            date3 = ""

    # 5 支數字
    A0_list = [int(t0[c]) for c in nums]
    A1_list = [int(t1[c]) for c in nums]
    A2_list = [int(t2[c]) for c in nums]

    # 目標集合（用來驗證命中）
    S1 = set(A1_list)  # t1 的 5 顆
    S2 = set(A2_list)  # t2 的 5 顆

    # ===== 支別規律：固定 / 遞增（不跨界，不循環）=====
    pos_patterns = []
    for p0 in range(5):
        pos_patterns.append((p0, p0, p0))          # 固定：p,p,p
        if p0 + 2 <= 4:
            pos_patterns.append((p0, p0 + 1, p0 + 2))  # 遞增：p,p+1,p+2

    # ===== 差值規律：由 d1, d2 推出 d3（固定/遞增/遞減）=====
    def _d3_from_d1_d2(d1, d2):
        d1 = int(d1); d2 = int(d2)
        if d2 == d1:
            return d2          # 固定
        if d2 == d1 + 1:
            return d2 + 1      # 遞增
        if d2 == d1 - 1:
            return d2 - 1      # 遞減
        return None

    out = []
    chains = 0
    pred_counter = Counter()

    for (p0, p1, p2) in pos_patterns:
        if chains >= max_chains:
            break

        a0 = A0_list[p0]
        a1 = A1_list[p1]
        a2 = A2_list[p2]

        # 段1：a0 + d1 命中 S1 的任一號碼
        for hit1 in sorted(S1):
            d1 = int(hit1 - a0)
            if not _ok_d(d1):
                continue
            if not _in_bound(a0 + d1):
                continue

            # 方向鎖定：d1>0 全加；d1<0 全減；d1==0（若允許）就全0
            direction = 0
            if d1 > 0:
                direction = 1
            elif d1 < 0:
                direction = -1

            # 段2：a1 + d2 命中 S2 任一號碼，且 d2 與 d1 規律（-1/0/+1）
            for hit2 in sorted(S2):
                d2 = int(hit2 - a1)
                if not _ok_d(d2):
                    continue
                if not _in_bound(a1 + d2):
                    continue

                # 不混正負：與第一段同方向（direction=0 時只允許 d2=0）
                if direction == 1 and d2 <= 0:
                    continue
                if direction == -1 and d2 >= 0:
                    continue
                if direction == 0 and d2 != 0:
                    continue

                # 規律限制：d2 相對 d1 只能差 -1/0/+1
                if abs(int(d2 - d1)) > 1:
                    continue

                d3 = _d3_from_d1_d2(d1, d2)
                if d3 is None:
                    continue

                # 預測段方向也要一致
                if direction == 1 and d3 <= 0:
                    continue
                if direction == -1 and d3 >= 0:
                    continue
                if direction == 0 and d3 != 0:
                    continue

                pred = int(a2 + d3)
                if not _ok_d(d3):
                    continue
                if not _in_bound(pred):
                    continue

                # ✅ 記錄候選（用於 return_pred_rank）
                pred_counter[int(pred)] += 1

                # === 輸出格式（日期用 m/d；第三段日期用「實際預測日期」）===
                out.append(f"{date0}{_ball_label(p0)}{_fmt_expr(a0, d1)} 等於 {date1} 號碼{_n2(hit1)}")
                out.append(f"{date1}{_ball_label(p1)}{_fmt_expr(a1, d2)} 等於 {date2} 號碼{_n2(hit2)}")

                # ✅ 這一行保留「預測」字樣，但完全不會出現「下一期」
                # 若 date3 取不到，仍然輸出但日期留空（你也可以改成直接略過）
                out.append(f"{date2}{_ball_label(p2)}{_fmt_expr(a2, d3)} 等於 {date3} 預測號碼{_n2(pred)}")
                out.append("")

                chains += 1
                if chains >= max_chains:
                    break
            if chains >= max_chains:
                break

    if not out:
        txt = "（順球：找不到符合『支別規律＋差值規律＋邊界』的鏈條）\n"
        if return_pred_rank:
            return txt, []
        return txt

    txt = "\n".join(out).rstrip() + "\n"

    if return_pred_rank:
        # 依「被預測到次數」由高到低，次序同分再比號碼小者優先
        pred_rank = [n for n, c in sorted(pred_counter.items(), key=lambda x: (-int(x[1]), int(x[0])))]
        return txt, pred_rank

    return txt

# ==============================================
# 核心流程：可被 GUI 呼叫（含 暫停/停止 檢查點）
# ✅ 進度條：只做「大段節點」更新，避免拖慢速度
# ==============================================
def run_pipeline(backtest_N: int, BACKTEST_TOP_N: int, PRED_TOP_N: int, control: RunControl,
                 use_human_rules: bool=True, auto_learn_human_rules: bool=True, show_human_ab_in_gui: bool=True,
                 payout_mode: str="casino", lehecai_play_ks: tuple=(2,3,4), tw539_pick_n: int=5):
    warnings.simplefilter(action='ignore', category=FutureWarning)
    warnings.simplefilter(action='ignore', category=pd.errors.SettingWithCopyWarning)

    n_cpu_all = multiprocessing.cpu_count()
    print(f"本機核心數：{n_cpu_all} 核心")

    if BACKTEST_TOP_N <= 0 or BACKTEST_TOP_N > 39 or PRED_TOP_N <= 0 or PRED_TOP_N > 39:
        raise ValueError("TOP_N 數量需介於 1 ~ 39 之間。")

    # ✅ 先建一個 summary_lines，避免你後面任何地方 append 時還沒宣告
    summary_lines = []

    # =============================
    # ✅ 顆數統一（放這裡是最早且必要的位置）
    # =============================
    try:
        _v = int(PRED_TOP_N)
    except Exception:
        _v = 5
    _v = max(1, min(39, _v))

    PRED_TOP_N = _v
    var_pred_topn = _v

    try:
        print(f"✅ 顆數同步：var_pred_topn={var_pred_topn}，PRED_TOP_N={PRED_TOP_N}")
    except Exception:
        pass

    # 0~12：下載/對獎
    control.set_status("下載/載入官方資料")
    control.set_progress(2)
    control.check_pause_stop()
    print("下載/載入官方資料...")
    df = load_tw539(force_download=True)
    control.set_progress(10)

    # ✅ 顯示『抓官方日期』：資料抓取時間 + 最新開獎日期（以資料檔最新一期為準）
    try:
        src = str(df.attrs.get("fetch_source", ""))
        ft  = str(df.attrs.get("fetch_time", ""))
        ld  = str(df.attrs.get("latest_draw_date", ""))
        li  = str(df.attrs.get("latest_issue", ""))
        if src or ft or ld or li:
            if src:
                print(f"✅ 資料來源：{src}")
            if ft:
                print(f"✅ 資料抓取時間：{ft}")
            if ld or li:
                print(f"✅ 官方最新開獎日期：{ld}（期數 {li}）")
            print("")
    except Exception:
        pass

    nums = ["正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5"]

    # =============================
    # ✅ 提前定義：格式化工具（避免後面 UnboundLocalError）
    # =============================
    def format_nums(nums_list):
        return "[" + ", ".join(f"{int(n):02d}" for n in sorted([int(x) for x in (nums_list or [])])) + "]"

    def format_nums_with_marks(nums_list, mark_level: dict):
        parts = []
        for n in (nums_list or []):
            try:
                n = int(n)
            except Exception:
                continue
            lvl = int((mark_level or {}).get(int(n), 0))
            if lvl >= 3:
                mark = "🔥"
            elif lvl >= 2:
                mark = "◆"
            else:
                mark = ""
            parts.append(f"{int(n):02d}{mark}")
        return "[" + ", ".join(parts) + "]"

    def pick_topn_stable(scores, top_n, desc=True):
        s = np.asarray(scores, dtype=np.float64)
        n = s.shape[0]
        if desc:
            order = np.lexsort((np.arange(n, dtype=np.int32), -s))
        else:
            order = np.lexsort((np.arange(n, dtype=np.int32), s))
        pick_idx = order[:top_n]
        return sorted([int(i + 1) for i in pick_idx])

    # =========================================================
    # ✅ 共用：篩選/修補規則（讓「回測紀錄」與「預測」都能用同一套規則）
    # 目的：你要的「篩選後的六模型回測紀錄」，就在這裡統一處理
    # =========================================================
    def _safe_int_list(xs):
        out = []
        for x in (xs or []):
            try:
                v = int(x)
                if 1 <= v <= 39:
                    out.append(v)
            except Exception:
                pass
        return out

    def _score_of(n, score_vec):
        try:
            return float(score_vec[int(n) - 1])
        except Exception:
            return -1e18

    def _passes_basic_rules(nums_list, k):
        arr = sorted(_safe_int_list(nums_list))
        if len(arr) != int(k):
            return False

        k = int(k)
        odd = sum(n % 2 for n in arr)
        even = k - odd
        if odd == 0 or even == 0:
            return False

        serial_pairs = sum(1 for i in range(k - 1) if arr[i + 1] - arr[i] == 1)
        max_serial = 1 if k <= 5 else (2 if k <= 7 else 3)
        if serial_pairs > max_serial:
            return False

        z1 = sum(1 for n in arr if 1 <= n <= 13)
        z2 = sum(1 for n in arr if 14 <= n <= 26)
        z3 = sum(1 for n in arr if 27 <= n <= 39)

        max_zone = max(z1, z2, z3)
        if max_zone >= k:
            return False

        zone_cap = (k - 1) if k <= 6 else (k - 2)
        if max_zone > zone_cap:
            return False

        return True

    def _pick_top_from_candidates(cands, score_vec, k=5, *, must=None, avoid=None):
        must = set(_safe_int_list(must))
        avoid = set(_safe_int_list(avoid))

        pool = [n for n in _safe_int_list(cands) if n not in avoid]
        pool = sorted(set(pool), key=lambda n: (-_score_of(n, score_vec), n))

        picked = []
        for n in sorted(must):
            if n not in avoid and n not in picked and len(picked) < k:
                picked.append(n)

        for n in pool:
            if n not in picked and len(picked) < k:
                picked.append(n)

        return sorted(picked)

    def _repair_to_pass_rules(base_pool, score_vec, seed_nums=None, k=5, avoid=None, max_try=2000):
        avoid = set(_safe_int_list(avoid))
        seed_nums = set(_safe_int_list(seed_nums))

        pool = [n for n in _safe_int_list(base_pool) if n not in avoid]
        pool = sorted(set(pool), key=lambda n: (-_score_of(n, score_vec), n))

        first = _pick_top_from_candidates(pool, score_vec, k=int(k), must=seed_nums, avoid=avoid)
        if _passes_basic_rules(first, int(k)):
            return first

        best = first[:]
        top_pool = pool[:max(18, min(39, int(k) * 4))]

        for _ in range(int(max_try)):
            cand = []
            cand.extend(sorted(seed_nums))
            for n in top_pool:
                if n in avoid or n in cand:
                    continue
                cand.append(n)
                if len(cand) >= int(k):
                    break
            cand = sorted(cand[:int(k)])
            if len(cand) == int(k) and _passes_basic_rules(cand, int(k)):
                return cand

        return sorted(best)

    def _filter_ticket_by_rules(score_vec, k):
        k = int(k)
        raw = pick_topn_stable(score_vec, k, desc=True)
        if _passes_basic_rules(raw, k):
            return raw
        rank = sorted(list(range(1, 40)), key=lambda n: (-_score_of(n, score_vec), n))
        base_pool = rank[:max(18, k * 4)]
        return _repair_to_pass_rules(base_pool=base_pool, score_vec=score_vec, seed_nums=None, k=k, avoid=None, max_try=2000)

    def pretty_print_row(row, title=""):
        print(f"{Fore.LIGHTYELLOW_EX}==== {title} ===={Style.RESET_ALL}")
        print(f"{Fore.LIGHTCYAN_EX}日期        {row['日期'].strftime('%Y-%m-%d')}{Style.RESET_ALL}")
        print(f"{Fore.LIGHTCYAN_EX}期數        {int(row['期數'])}{Style.RESET_ALL}")
        print(f"{Fore.LIGHTWHITE_EX}落序號碼1~5  ", end="")
        for i in range(1, 6):
            print(f"{int(row[f'落序號碼{i}']):02d} ", end="")
        print(Style.RESET_ALL)
        print(f"{Fore.LIGHTWHITE_EX}正序號碼1~5  ", end="")
        for i in range(1, 6):
            print(f"{int(row[f'正序號碼{i}']):02d} ", end="")
        print(Style.RESET_ALL)
        print()

    pretty_print_row(df.iloc[0], "第一筆資料")
    pretty_print_row(df.iloc[-1], "最後一筆資料")
    print(f"{Fore.LIGHTGREEN_EX}==== 全部期數：{len(df)} 筆 ===={Style.RESET_ALL}\n")

    control.set_status("自動對獎（若有 latest_predict.csv）")
    control.set_progress(12)
    control.check_pause_stop()
    try_save_latest_prediction_result(df, nums)

    # 12~30：建特徵
    control.set_status("建特徵（一次建滿）")
    control.set_progress(15)
    control.check_pause_stop()
    X_full, base_columns, _, _ = build_full_features_once(df)
    control.set_progress(30)

    X_bt = X_full.reset_index(drop=True)
    df_bt = df.reset_index(drop=True)

    future_open = df[nums].shift(-1)
    y_all = pd.DataFrame({
        f"y_{i:02d}": future_open.apply(lambda x, i=i: int(i in x.values), axis=1).astype(np.int8)
        for i in range(1, 40)
    }).reset_index(drop=True)

    num_rows = X_bt.shape[0]
    feature_row_count = num_rows - 1

    if feature_row_count < backtest_N or backtest_N <= 0:
        raise ValueError(f"【錯誤】可回測期數 ({feature_row_count}) 必須大於回測期數 ({backtest_N})！")

    backtest_indexes = list(range(feature_row_count - backtest_N, feature_row_count))

    backtest_eval_start_date = df_bt.iloc[backtest_indexes[0] + 1]["日期"].date()
    backtest_eval_end_date = df_bt.iloc[backtest_indexes[-1] + 1]["日期"].date()
    print(f"==== 回測評估日期（實際被預測的開獎日）: {backtest_eval_start_date} ~ {backtest_eval_end_date} ====")

    latest_issue = int(df_bt.iloc[-1]["期數"])
    predict_next_issue = latest_issue + 1
    predict_next_date = infer_next_draw_date_tw539_with_announcement(df_bt["日期"].dt.date.tolist())

    print(f"==== 預測日期（期數 {predict_next_issue}）：{predict_next_date} ====")
    print(f"==== Walk-forward 回測：每 {WALK_FORWARD_RETRAIN_INTERVAL} 期重訓一次（K={WALK_FORWARD_RETRAIN_INTERVAL}） ====")

    # 30~40：拖牌
    control.set_status("計算版路拖牌")
    control.set_progress(33)
    control.check_pause_stop()

    drag_result = []
    drag_hint_nums_all = set()
    mark_level = {}  # ✅ 供 format_nums_with_marks 使用

    if DRAG_ENABLE:
        txt_size_unpos, txt_size_pos, txt_order_unpos, txt_order_pos, drag_hint_nums_all, drag_result = compute_drag_notebooks(
            df_bt, nums, predict_lags=DRAG_PREDICT_LAGS
        )
        files_and_txt = [
            ("版路拖牌_順球_未定位.txt", txt_size_unpos),
            ("版路拖牌_順球_定位.txt", txt_size_pos),
            ("版路拖牌_落球_未定位.txt", txt_order_unpos),
            ("版路拖牌_落球_定位.txt", txt_order_pos),
        ]
        for fname, content in files_and_txt:
            with open(fname, "w", encoding="utf-8-sig") as f:
                f.write(content)

        print(
            "版路拖牌筆記本已輸出為："
            "版路拖牌_順球_未定位.txt / "
            "版路拖牌_順球_定位.txt / "
            "版路拖牌_落球_未定位.txt / "
            "版路拖牌_落球_定位.txt"
        )

        if drag_hint_nums_all:
            print(
                "\n📌 版路拖牌總覽（所有有出現拖牌的號碼，僅供參考）： "
                "[" + ", ".join(f"{n:02d}" for n in sorted(drag_hint_nums_all)) + "]"
            )

            layer2, layer3, prob_rank, mark_level = analyze_drag_layers(drag_result)

            print("\n🎯 連 2 版拖牌號碼：")
            print(layer2 if layer2 else "（無）")

            print("\n🔥 連 ≥3 版拖牌號碼（強勢）：")
            print(layer3 if layer3 else "（無）")

            print("\n📊 拖牌版路機率（高 → 低）：")
            if prob_rank:
                for n, c, p in prob_rank[:50]:
                    print(f"號碼 {n:02d}｜命中 {c}｜機率 {p:.0%}")
            else:
                print("（無）")

            # =============================
            # ✅ 順球（位移差值傳遞）輸出（規律差值版）
            # =============================
            try:
                txt, shift_rank = format_shift_chains_text(
                    df=df_bt,
                    nums=nums,
                    max_chains=50,
                    allow_d_zero=False,
                    predict_date=predict_next_date,
                    return_pred_rank=True
                )
                print(f"\n🧭 順球（規律差值｜預測日期 {predict_next_date}）：")
                print(txt, end="")

                k_shift = int(PRED_TOP_N)

                shift_pick = sorted([
                    int(x) for x in (shift_rank[:k_shift] if shift_rank else [])
                    if 1 <= int(x) <= 39
                ])

                all_shift_found = []
                try:
                    all_shift_found = sorted({int(x) for x in (shift_rank or []) if 1 <= int(x) <= 39})
                except Exception:
                    all_shift_found = []

                if all_shift_found:
                    print(
                        f"🔎 順球分析找到的所有號碼（共 {len(all_shift_found)} 顆）："
                        f"{format_nums_with_marks(all_shift_found, mark_level)}"
                    )
                else:
                    print("🔎 順球分析未找到任何可用號碼")

                if shift_pick:
                    out_str = format_nums_with_marks(shift_pick, mark_level)
                    print(f"✅ 方案五（順球候選｜預測日期 {predict_next_date}｜TOP_{k_shift}）：{out_str}")

                    try:
                        summary_lines.append("")
                        summary_lines.append(f"【方案五：順球候選｜TOP_{k_shift}】")
                        summary_lines.append(f"- 推薦號碼：{out_str}")
                    except Exception:
                        pass
                else:
                    print("（方案五：順球候選為空，代表鏈條有輸出但候選彙整失敗/或無pred）")

            except Exception as e:
                print(f"（順球輸出發生例外：{type(e).__name__}: {e}）")

    control.set_progress(40)

    model_names = ["XGBoost", "LightGBM", "CatBoost", "Logistic", "RandomForest", "CRF"]

    error_logs = []
    model_hits = {}
    model_logs = {}
    model_prizes = {}

    # ========= Walk-forward 回測 =========
    def run_backtest_walkforward(model_name):
        hits, logs = [], []

        # ✅ 回測採用的「選號顆數」
        bt_pick_n = int(BACKTEST_TOP_N)
        if str(payout_mode).lower() in ("lotto539", "539", "tw539"):
            bt_pick_n = int(tw539_pick_n) if int(tw539_pick_n) in (5, 6) else 5

        print(f"\n--- 開始模型 [{model_name}] Walk-forward 回測 ---")

        K = max(1, int(WALK_FORWARD_RETRAIN_INTERVAL))
        model_obj = None
        last_fit_i = None
        fit_count = 0

        total_steps = len(backtest_indexes)

        wf_bar = tqdm(
            enumerate(backtest_indexes, 1),
            total=total_steps,
            desc=f"回測WF [{model_name}]",
            leave=True,
            ncols=90
        )

        for step_idx, i in wf_bar:
            control.check_pause_stop()

            start_idx = 0 if (TRAIN_WINDOW is None) else max(0, i - TRAIN_WINDOW)

            need_refit = (
                model_obj is None
                or last_fit_i is None
                or ((i - last_fit_i) >= K)
            )

            if need_refit:
                try:
                    seed_offset = (fit_count * 1000) + (model_names.index(model_name) * 100)
                    model_obj = fit_model_for_i(
                        model_name, X_bt, y_all, base_columns,
                        start_idx, i, seed_offset=seed_offset
                    )
                    last_fit_i = i
                    fit_count += 1
                except Exception as e:
                    error_logs.append(f"{model_name} | fit_i={i} | {e}")
                    model_obj = None

            try:
                if model_obj is None:
                    pred_scores = np.zeros(39, dtype=np.float32)
                else:
                    pred_scores = predict_scores_for_i(
                        model_name, model_obj, X_bt, base_columns, i
                    )
            except Exception as e:
                error_logs.append(f"{model_name} | pred_i={i} | {e}")
                pred_scores = np.zeros(39, dtype=np.float32)

            # =========================================================
            # ✅ 修正：Walk-forward 回測也套用「篩選後(回灌後)」的分數再選號
            #   - mistake_w：使用你現有的錯題本權重（同你下一期預測的做法）
            #   - fe_w：熱度只用「當下 i 以前」的歷史資料，避免未來資訊污染
            #   - ab_w：維持你目前的 AB 權重邏輯（若你要完全無未來資訊，AB 也要做成逐步回測版，較大工程）
            # =========================================================
            try:
                adj = np.asarray(pred_scores, dtype=np.float32)

                # --- (A) 錯題本權重（同你既有寫法） ---
                _use_mistake_penalty = bool(globals().get("use_mistake_penalty", True))
                if _use_mistake_penalty:
                    penalty_counts_bt = load_penalty_from_real_results(result_file="latest_predict_result.csv")
                    auto_alpha_bt = get_auto_mistake_alpha("latest_predict_result.csv")
                    mistake_w_bt = 1.0 / (1.0 + float(auto_alpha_bt) * np.asarray(penalty_counts_bt, dtype=np.float32))
                else:
                    mistake_w_bt = np.ones(39, dtype=np.float32)

                # --- (B) 熱度 overlay：只看當下 i 以前 ---
                FE_WINDOW = int(globals().get("FE_WINDOW", 30))
                FE_BETA   = float(globals().get("FE_BETA", 0.12))

                df_hist_bt = df_bt.iloc[:max(1, i + 1)].copy()
                hot_rank_fe_bt, hot_cnt_fe_bt = _hot_ranking_from_hist(df_hist_bt, nums, window=int(FE_WINDOW))

                hot_map_bt = {int(n): float(c) for n, c in zip(hot_rank_fe_bt, hot_cnt_fe_bt)}
                hc_max_bt = max(hot_map_bt.values()) if hot_map_bt else 1.0
                hot_norm_bt = np.array([(hot_map_bt.get(j, 0.0) / hc_max_bt) for j in range(1, 40)], dtype=np.float32)
                fe_w_bt = (1.0 + float(FE_BETA) * hot_norm_bt).astype(np.float32)

                # --- (C) AB 權重：沿用你已算好的 ab_w（若沒啟用就全 1） ---
                try:
                    ab_w_bt = np.asarray(ab_w, dtype=np.float32) if 'ab_w' in locals() else np.ones(39, dtype=np.float32)
                    if ab_w_bt.shape[0] != 39:
                        ab_w_bt = np.ones(39, dtype=np.float32)
                except Exception:
                    ab_w_bt = np.ones(39, dtype=np.float32)

                adj = adj * mistake_w_bt * fe_w_bt * ab_w_bt
                pred_scores = adj  # ✅ 回測用「篩選後」分數

            except Exception as _e_bt:
                # 若回灌失敗，回測仍可繼續用原始 pred_scores
                error_logs.append(f"{model_name} | postfilter_i={i} | {_e_bt}")

            pred_top_n = pick_topn_stable(pred_scores, BACKTEST_TOP_N, desc=True)


            # =========================================================
            # ✅ 關鍵修正：回測用「篩選後的號碼」來算命中與輸出紀錄
            # =========================================================
            pred_top_n = _filter_ticket_by_rules(pred_scores, bt_pick_n)

            real_idx = i + 1
            real_date = df_bt.iloc[real_idx]["日期"].date()
            real_numbers = df_bt.iloc[real_idx][nums].tolist()

            hit = len(set(pred_top_n) & set(real_numbers))
            hits.append(hit)

            logs.append(
                f"{model_name:<12} | {real_date} | 命中:{hit:<2d} | "
                f"預測號碼:{format_nums_with_marks(pred_top_n, mark_level)} | 開獎號碼:{format_nums(real_numbers)}"
            )

        wf_bar.close()

        bet_top_n = int(BACKTEST_TOP_N)
        if str(payout_mode).lower() in ("lotto539", "539", "tw539"):
            bet_top_n = int(PRED_TOP_N)

        prize_stat = calc_prize(
            hits,
            bet_top_n,
            payout_mode=payout_mode,
            lehecai_play_ks=lehecai_play_ks,
            tw539_pick_n=(bet_top_n if str(payout_mode).lower() in ("lotto539", "539", "tw539") else tw539_pick_n)
        )

        print(f"--- 完成模型 [{model_name}] Walk-forward 回測 ---")
        return model_name, hits, logs, prize_stat

    # 40~80：回測
    total_start = time.time()
    bt_total = len(model_names)
    for idx_m, mn in enumerate(model_names, 1):
        control.set_status(f"回測中：{mn} ({idx_m}/{bt_total})")
        control.check_pause_stop()
        control.set_progress(40 + (idx_m - 1) * (40 / bt_total))

        k, hits, logs, prize_stat = run_backtest_walkforward(mn)
        model_hits[k] = hits
        model_logs[k] = logs
        model_prizes[k] = prize_stat

        control.set_progress(40 + idx_m * (40 / bt_total))

    total_end = time.time()
    print(f"\n回測全部模型總耗時：{total_end - total_start:.2f} 秒")
    if error_logs:
        with open("error_log.txt", "a", encoding="utf-8") as ef:
            for line in error_logs:
                ef.write(line + "\n")
        print(f"【已記錄異常於 error_log.txt】")

    nowtag = datetime.now().strftime('%Y%m%d_%H%M%S')

    backtest_log_file = f"backtest_all_models_WF_{backtest_N}N_K{WALK_FORWARD_RETRAIN_INTERVAL}_{nowtag}.txt"
    with open(backtest_log_file, "w", encoding="utf-8-sig") as f:
        f.write(f"Walk-forward 回測總表\n")
        f.write(f"日期範圍(被預測開獎日)：{backtest_eval_start_date} ~ {backtest_eval_end_date}\n")
        f.write(f"回測期數：{backtest_N}\n")
        f.write(f"K(每幾期重訓)：{WALK_FORWARD_RETRAIN_INTERVAL}\n")
        f.write(f"回測支數：{BACKTEST_TOP_N}\n")
        f.write("=" * 80 + "\n\n")
        for mn in model_names:
            f.write(f"[{mn}] 回測命中紀錄（完整｜已篩選規則）\n")
            for line in model_logs.get(mn, []):
                f.write(line + "\n")
            f.write("\n")

    GUI_BACKTEST_SHOW_LAST_N = 30
    print(f"\n✅ 已輸出「全部模型完整回測紀錄」到檔案：{backtest_log_file}")

    # ✅ GUI Console 顯示各模型最後 N 期（已是篩選後）
    try:
        show_n = int(GUI_BACKTEST_SHOW_LAST_N) if 'GUI_BACKTEST_SHOW_LAST_N' in globals() else 30
        show_n = max(1, show_n)

        print("\n" + "=" * 80)
        print(f"✅ GUI 顯示：各模型回測紀錄（各自最後 {show_n} 期｜已篩選規則）")
        print("=" * 80)

        for mn in model_names:
            logs = model_logs.get(mn, [])
            tail = logs[-show_n:] if len(logs) > show_n else logs

            print(f"\n[{mn}]（顯示 {len(tail)}/{len(logs)} 期）")
            print("-" * 80)
            for line in tail:
                print(line)

        print("\n" + "=" * 80 + "\n")
    except Exception as e:
        print(f"（GUI 顯示最後 {GUI_BACKTEST_SHOW_LAST_N} 期回測紀錄失敗：{e}）")

    history_fname = os.path.join(
        os.getcwd(),
        f"history_WF_{backtest_N}N_K{WALK_FORWARD_RETRAIN_INTERVAL}_bt{BACKTEST_TOP_N}_pred{PRED_TOP_N}_{nowtag}.pkl"
    )
    history_data = {
        "datetime": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "mode": "walk_forward",
        "K": int(WALK_FORWARD_RETRAIN_INTERVAL),
        "backtest_eval_start_date": str(backtest_eval_start_date),
        "backtest_eval_end_date": str(backtest_eval_end_date),
        "backtest_N": int(backtest_N),
        "BACKTEST_TOP_N": int(BACKTEST_TOP_N),
        "PRED_TOP_N": int(PRED_TOP_N),
        "TRAIN_WINDOW": int(TRAIN_WINDOW) if TRAIN_WINDOW is not None else None,
        "FAST_MODE": bool(FAST_MODE),
        "USE_DETERMINISTIC": bool(USE_DETERMINISTIC),
        "GLOBAL_SEED": int(GLOBAL_SEED),
        "model_hits": model_hits,
        "model_prizes": model_prizes,
    }
    with open(history_fname, "wb") as f:
        pickle.dump(history_data, f)
    print(f"已輸出回測統計檔：{history_fname}")

    # 80~92：預測各模型
    control.set_status("預測下一期（各模型）")
    control.set_progress(82)
    control.check_pause_stop()

    all_model_predictions_prob = {}
    all_model_predictions_size = {}
    all_model_pred_scores = {}

    def predict_one_model(model_name):
        control.check_pause_stop()
        i = len(X_bt) - 1
        start_idx = 0 if (TRAIN_WINDOW is None) else max(0, i - TRAIN_WINDOW)
        seed_offset = 999_000 + (model_names.index(model_name) * 100)

        try:
            model_obj = fit_model_for_i(model_name, X_bt, y_all, base_columns, start_idx, i, seed_offset=seed_offset)
            scores = predict_scores_for_i(model_name, model_obj, X_bt, base_columns, i)
        except Exception as e:
            print(f"\n{Fore.LIGHTRED_EX}{model_name} 預測例外: {e}{Style.RESET_ALL}")
            scores = np.zeros(39, dtype=np.float32)

        # ✅ 預測也套同一套篩選規則（避免回測/預測顯示風格不一致）
        pred_size = _filter_ticket_by_rules(scores, int(PRED_TOP_N))
        pred_prob = sorted(pred_size, key=lambda num: (-float(scores[num - 1]), num))
        return pred_prob, pred_size, scores

    pred_total = len(model_names)
    for idx_p, mn in enumerate(model_names, 1):
        control.set_status(f"預測中：{mn} ({idx_p}/{pred_total})")
        control.check_pause_stop()
        control.set_progress(82 + (idx_p - 1) * (10 / pred_total))

        t0m = time.time()
        print(f"\n>>> [PRED] 開始訓練+預測：{mn} ...")
        pred_prob, pred_size, scores = predict_one_model(mn)
        print(f">>> [PRED] 完成：{mn}，耗時 {time.time() - t0m:.2f} 秒")

        all_model_predictions_prob[mn] = pred_prob
        all_model_predictions_size[mn] = pred_size
        all_model_pred_scores[mn] = scores.tolist()

        print(f"\n{mn:<12} | 預測期數 {predict_next_issue} / 日期(估) {predict_next_date}")
        print("  落球序預測（機率大→小）："
              f"{format_nums_with_marks(pred_prob, mark_level)}")
        print("  大小序預測（正序）    ："
              f"{format_nums_with_marks(pred_size, mark_level)}")
        print("-" * 60)

        if SAVE_PROBA_CSV:
            out_csv = f"pred_scores_{mn}.csv"
            pd.DataFrame({
                "number": [f"{i:02d}" for i in range(1, 40)],
                "proba": scores
            }).to_csv(out_csv, index=False, encoding="utf-8-sig")

        control.set_progress(82 + idx_p * (10 / pred_total))

    def save_latest_predict(predict_issue, predict_date, preds_dict):
        filename = "latest_predict.csv"
        with open(filename, mode="w", newline="", encoding="utf-8-sig") as f:
            writer = csv.writer(f)
            writer.writerow(["預測期數", "預測日期", "模型", "預測號碼"])
            for model_name, numbers in preds_dict.items():
                nums_str = ",".join([f"{n:02d}" for n in sorted(numbers)])
                writer.writerow([str(predict_issue), str(predict_date), model_name, nums_str])
        print(f"\n已儲存最新一期各模型預測號碼於 {filename}！（預測 TOP_{PRED_TOP_N}，採大小序；對獎優先用期數）")

    # =========================================================
    # ✅ 回灌：AB + 錯題本 + 特徵工程(熱度 overlay) -> 6 模型 TOP_N/union
    # =========================================================
    A_next, B_next = None, None
    ab_best = None
    ab_objective = None

    try:
        FE_WINDOW = 30
        FE_BETA   = 0.12
        AB_W_A    = 1.18
        AB_W_B    = 1.10

        # --- 1) 錯題本 weight（每個號碼一個權重） ---
        _use_mistake_penalty = bool(globals().get("use_mistake_penalty", True))
        if _use_mistake_penalty:
            penalty_counts = load_penalty_from_real_results(result_file="latest_predict_result.csv")
            auto_alpha = get_auto_mistake_alpha("latest_predict_result.csv")
            mistake_w = 1.0 / (1.0 + float(auto_alpha) * np.asarray(penalty_counts, dtype=np.float32))
        else:
            mistake_w = np.ones(39, dtype=np.float32)

        # --- 2) 特徵工程(熱度) overlay weight（小幅加權） ---
        hot_rank_fe, hot_cnt_fe = _hot_ranking_from_hist(df_bt, nums, window=int(FE_WINDOW))
        hot_map = {int(n): float(c) for n, c in zip(hot_rank_fe, hot_cnt_fe)}
        hc_max = max(hot_map.values()) if hot_map else 1.0
        hot_norm = np.array([(hot_map.get(i, 0.0) / hc_max) for i in range(1, 40)], dtype=np.float32)
        fe_w = (1.0 + float(FE_BETA) * hot_norm).astype(np.float32)

        # --- 3) 人類規則 AB overlay weight（A > B） ---
        ab_w = np.ones(39, dtype=np.float32)

        if bool(use_human_rules) and bool(show_human_ab_in_gui):
            if bool(auto_learn_human_rules):
                params = auto_search_human_rule_params(
                    df_bt, nums,
                    backtest_N=min(int(backtest_N), 600),
                    pred_n=int(PRED_TOP_N),
                    objective='hit_ge2_rate'
                )
            else:
                params = {"window": 30, "pool_size": 18, "max_adj_pairs": 1, "objective": "hit_ge2_rate"}

            pred_n_ab = int(PRED_TOP_N)

            try:
                ab = human_rules_ab_backtest(
                    df_bt, nums,
                    backtest_N=min(int(backtest_N), 600),
                    pred_n=pred_n_ab,
                    window=int(params["window"]),
                    pool_size=int(params["pool_size"]),
                    n_samples=4000,
                    prefer_odd_even=True,
                    require_tail_pair=True,
                    max_adj_pairs=int(params["max_adj_pairs"]),
                    forbid_triple=True,
                    objective=str(params.get("objective", "hit_ge2_rate"))
                )
                ab_best = ab.get("best")
                ab_objective = ab.get("objective")
            except Exception:
                ab_best = None
                ab_objective = None

            hot_rank_ab, hot_cnt_ab = _hot_ranking_from_hist(df_bt, nums, window=int(params["window"]))

            if _use_mistake_penalty:
                try:
                    penalty_arr_real = load_penalty_from_real_results("latest_predict_result.csv", nums=nums)
                    mistake_alpha = float(get_auto_mistake_alpha()) if bool(globals().get("auto_mistake_alpha", True)) else float(globals().get("MISTAKE_ALPHA_BASE", 0.10))
                    hm = {int(n): float(c) for n, c in zip(hot_rank_ab, hot_cnt_ab)}
                    hm_adj = {n: (hm.get(n, 0.0) / (1.0 + mistake_alpha * float(penalty_arr_real[n - 1]))) for n in range(1, 40)}
                    hot_rank_ab = sorted(range(1, 40), key=lambda n: (-hm_adj.get(n, 0.0), n))
                    hot_cnt_ab = [hm_adj[n] for n in hot_rank_ab]
                except Exception:
                    pass

            A_next, _ = _sample_best_ticket_from_pool(
                hot_rank_ab, hot_cnt_ab,
                pred_n=pred_n_ab,
                pool_size=int(params["pool_size"]),
                n_samples=6000,
                prefer_odd_even=True,
                require_tail_pair=True,
                max_adj_pairs=int(params["max_adj_pairs"]),
                forbid_triple=True,
                rng=random.Random(999)
            )
            B_next = sorted(hot_rank_ab[:pred_n_ab])

            if isinstance(A_next, (list, tuple)):
                for n in A_next:
                    n = int(n)
                    if 1 <= n <= 39:
                        ab_w[n - 1] = max(ab_w[n - 1], float(AB_W_A))
            if isinstance(B_next, (list, tuple)):
                for n in B_next:
                    n = int(n)
                    if 1 <= n <= 39:
                        ab_w[n - 1] = max(ab_w[n - 1], float(AB_W_B))

        # --- 4) 覆寫 6 模型 scores / TOP_N ---
        for mn in list(all_model_pred_scores.keys()):
            raw = np.asarray(all_model_pred_scores.get(mn, [0.0] * 39), dtype=np.float32)
            if raw.shape[0] != 39:
                continue

            adj = raw * mistake_w * fe_w * ab_w

            all_model_pred_scores[mn] = adj.tolist()

            # ✅ 回灌後：再做一次「篩選規則」
            pred_size_new = _filter_ticket_by_rules(adj, int(PRED_TOP_N))
            pred_prob_new = sorted(pred_size_new, key=lambda num: (-float(adj[num - 1]), num))

            all_model_predictions_size[mn] = pred_size_new
            all_model_predictions_prob[mn] = pred_prob_new

    except Exception as _e:
        print(f"（AB/錯題本/熱度 回灌到 6 模型失敗：{type(_e).__name__}: {_e}）")

    save_latest_predict(predict_next_issue, str(predict_next_date), all_model_predictions_size)

    # 92~98：綜合票選
    control.set_status("綜合票選（含錯題本）")
    control.set_progress(94)
    control.check_pause_stop()

    score_sum_unweighted = np.zeros(39, dtype=np.float32)
    for _, s in all_model_pred_scores.items():
        score_sum_unweighted += np.array(s, dtype=np.float32)

    penalty_counts = load_penalty_from_real_results(result_file="latest_predict_result.csv")
    auto_alpha = get_auto_mistake_alpha("latest_predict_result.csv")
    penalty = auto_alpha * penalty_counts
    print(f"錯題本自動懲罰係數 MISTAKE_ALPHA = {auto_alpha:.3f}（依真實對獎紀錄量自動調整）")

    combined_A = np.maximum(0.0, score_sum_unweighted - penalty)
    top_common_A = pick_topn_stable(combined_A, PRED_TOP_N, desc=True)

    print(
        f"\n所有模型【未加權+錯題本懲罰(真實對獎)】綜合票選（TOP_{PRED_TOP_N}）："
        f"{format_nums_with_marks(sorted(top_common_A), mark_level)}"
    )

    model_weight = {k: max(1e-6, float(np.mean(v))) for k, v in model_hits.items()}
    score_sum_weighted = np.zeros(39, dtype=np.float32)
    for mn, s in all_model_pred_scores.items():
        score_sum_weighted += model_weight.get(mn, 1.0) * np.array(s, dtype=np.float32)

    combined_B = np.maximum(0.0, score_sum_weighted - penalty)
    top_common_B = pick_topn_stable(combined_B, PRED_TOP_N, desc=True)

    print(
        f"所有模型【表現加權(WF回測)+錯題本懲罰(真實對獎)】綜合票選（TOP_{PRED_TOP_N}）："
        f"{format_nums_with_marks(sorted(top_common_B), mark_level)}"
    )

    # ==============================================
    # ✅ 人類規則 AB 對照：只顯示回灌那次算出的 A_next/B_next
    # ==============================================
    if bool(use_human_rules) and bool(show_human_ab_in_gui):
        try:
            print("\n" + "=" * 80)
            print("【人類規則AB對照】納入 1)奇偶 2)同尾 3)避開兩組連號/三連號")
            print("=" * 80)

            try:
                official_date = fetch_twlottery_latest_draw_date_539()
                if official_date:
                    print(f"✅ 抓到官方最新開獎日期：{official_date}")
            except Exception:
                print("⚠ 未抓到官方最新開獎日期")

            if A_next and B_next:
                print("\n【下一期建議號碼（人類規則AB）】")
                print(f"A 規則組：{format_nums_with_marks(A_next, mark_level)}")
                print(f"B 熱度組：{format_nums_with_marks(B_next, mark_level)}")

                if ab_best in ("A", "B"):
                    chosen = A_next if ab_best == "A" else B_next
                    summary_lines.append("")
                    summary_lines.append("【人類規則 最佳方案】")
                    if ab_objective:
                        summary_lines.append(f"- objective={ab_objective}，勝出方案={ab_best}")
                    else:
                        summary_lines.append(f"- 勝出方案：{ab_best}")
                    summary_lines.append(f"- 推薦號碼：{format_nums_with_marks(chosen, mark_level)}")
            else:
                print("（AB 未產生：請確認已勾選『啟用 人類規則 AB 對照』與『在GUI輸出顯示AB結果』）")

        except Exception as e:
            print(f"（人類規則 AB 顯示發生例外：{type(e).__name__}: {e}）")

    # ========= overlap / union（重算一次，確保吃到「回灌後」的 6 模型 TOP_N）=========
    overlap_min = 2
    overlap_nums = []
    union_nums = []

    ticket_1 = []
    ticket_2 = []
    ticket_3 = []
    ticket_4 = []
    ticket_5 = []

    def _fmt(nums_list):
        return "[" + ", ".join(f"{n:02d}" for n in sorted(_safe_int_list(nums_list))) + "]"

    try:
        all_nums_flat = []
        for _mn, _pred_list in (all_model_predictions_size or {}).items():
            if not _pred_list:
                continue
            all_nums_flat.extend(list(_pred_list))

        if all_nums_flat:
            cnt = Counter(all_nums_flat)
            overlap_nums = [n for n, v in cnt.items() if v >= overlap_min]
            union_nums = sorted(set(all_nums_flat))

        score_mat = []
        for _mn in model_names:
            try:
                s = np.asarray(all_model_pred_scores.get(_mn, [0.0] * 39), dtype=np.float32)
                if s.shape[0] == 39:
                    score_mat.append(s)
            except Exception:
                pass

        if score_mat:
            meta_scores = np.mean(np.stack(score_mat, axis=0), axis=0).astype(np.float32)
        else:
            meta_scores = np.zeros(39, dtype=np.float32)

        try:
            k_pick = int(var_pred_topn)
        except Exception:
            k_pick = 5
        k_pick = max(5, min(12, k_pick))

        base1_pool = list(overlap_nums) + list(union_nums)
        ticket_1 = _repair_to_pass_rules(base_pool=base1_pool, score_vec=meta_scores, seed_nums=overlap_nums, k=k_pick, avoid=None)

        top_meta_rank = sorted(list(range(1, 40)), key=lambda n: (-_score_of(n, meta_scores), n))
        base2_pool = top_meta_rank[:max(12, int(PRED_TOP_N) * 2)]
        ticket_2 = _repair_to_pass_rules(base_pool=base2_pool, score_vec=meta_scores, seed_nums=None, k=k_pick, avoid=None)

        avoid3 = set(ticket_2)
        base3_pool = top_meta_rank[:max(18, int(PRED_TOP_N) * 3)]
        ticket_3 = _repair_to_pass_rules(base_pool=base3_pool, score_vec=meta_scores, seed_nums=None, k=k_pick, avoid=avoid3)

        seed4 = set(overlap_nums)
        try:
            if 'ab_best' in locals() and ab_best in ("A", "B"):
                chosen_ab = A_next if ab_best == "A" else B_next
                for n in _safe_int_list(chosen_ab):
                    seed4.add(n)
        except Exception:
            pass

        try:
            if 'layer3' in locals() and isinstance(layer3, str) and layer3.strip():
                for m in re.findall(r"\b(\d{1,2})\b", layer3):
                    v = int(m)
                    if 1 <= v <= 39:
                        seed4.add(v)
        except Exception:
            pass

        base4_pool = list(seed4) + top_meta_rank[:max(20, int(PRED_TOP_N) * 3)]
        ticket_4 = _repair_to_pass_rules(base_pool=base4_pool, score_vec=meta_scores, seed_nums=seed4, k=k_pick, avoid=None)

        shift_rank = []
        try:
            _, shift_rank = format_shift_chains_text(
                df=df_bt,
                nums=nums,
                max_chains=50,
                allow_d_zero=False,
                predict_date=predict_next_date,
                return_pred_rank=True
            )
        except Exception:
            shift_rank = []

        base5_pool = list(_safe_int_list(shift_rank)) + top_meta_rank[:max(25, int(PRED_TOP_N) * 4)]
        seed_n = max(2, min(5, int(PRED_TOP_N)))
        seed5 = _safe_int_list(shift_rank[:seed_n]) if shift_rank else []
        ticket_5 = _repair_to_pass_rules(base_pool=base5_pool, score_vec=meta_scores, seed_nums=seed5, k=k_pick, avoid=None)

        print("\n🎫 五方案（用於降低 0/1 命中比例）：")
        print(f"方案一｜共識優先(overlap≥{overlap_min})：{_fmt(ticket_1)}")
        print(f"方案二｜綜合分數Top5(meta)          ：{_fmt(ticket_2)}")
        print(f"方案三｜分散化(避開方案二)          ：{_fmt(ticket_3)}")
        print(f"方案四｜共識+AB/拖牌融合            ：{_fmt(ticket_4)}")
        print(f"方案五｜順球(規律差值)              ：{_fmt(ticket_5)}")

        try:
            summary_lines.append("")
            summary_lines.append("🎫【五方案（降低0/1命中比例）】")
            summary_lines.append(f"- 方案一｜共識優先：{_fmt(ticket_1)}")
            summary_lines.append(f"- 方案二｜綜合分數：{_fmt(ticket_2)}")
            summary_lines.append(f"- 方案三｜分散化  ：{_fmt(ticket_3)}")
            summary_lines.append(f"- 方案四｜融合版  ：{_fmt(ticket_4)}")
            summary_lines.append(f"- 方案五｜順球版  ：{_fmt(ticket_5)}")
        except Exception:
            pass

    except Exception:
        overlap_nums = []
        union_nums = []
        ticket_1, ticket_2, ticket_3, ticket_4, ticket_5 = [], [], [], [], []

    # ========= 做「最後執行結果摘要」給新視窗顯示 =========
    profit_rank = []
    model_order = list(model_names)
    for k in model_order:
        try:
            total_profit = int(model_prizes.get(k, {}).get('total_profit', 0))
        except Exception:
            total_profit = 0
        profit_rank.append((k, total_profit))
    profit_rank.sort(key=lambda x: x[1], reverse=True)

    # ✅ 重新整合 summary_lines（前面可能已 append 了 AB 最佳方案 / 方案五等）
    summary_lines.insert(0, "")
    summary_lines.insert(0, f"下一期：期數 {predict_next_issue} / 日期(估) {predict_next_date}")
    summary_lines.insert(0, f"回測：{BACKTEST_TOP_N}；預測：{PRED_TOP_N}；K={WALK_FORWARD_RETRAIN_INTERVAL}")
    summary_lines.insert(0, f"回測期數：{backtest_N}（被預測開獎日：{backtest_eval_start_date} ~ {backtest_eval_end_date}）")

    # =========================================================
    # ✅ 摘要視窗：六模型回測紀錄（已篩選規則）
    # =========================================================
    def _append_model_backtest_logs_to_summary(summary_lines, model_names, model_logs, show_last_n=30):
        show_last_n = int(show_last_n)
        show_last_n = max(1, min(200, show_last_n))

        summary_lines.append("")
        summary_lines.append("=" * 80)
        summary_lines.append(f"✅ 各模型回測紀錄（各自最後 {show_last_n} 期｜已篩選規則）")
        summary_lines.append("=" * 80)

        for k in model_names:
            logs = model_logs.get(k, []) or []
            if not logs:
                summary_lines.append("")
                summary_lines.append(f"[{k}]（無回測紀錄）")
                summary_lines.append("-" * 80)
                continue

            show = logs[-show_last_n:] if len(logs) > show_last_n else logs[:]
            summary_lines.append("")
            summary_lines.append(f"[{k}]（顯示 {len(show)}/{len(logs)} 期）")
            summary_lines.append("-" * 80)
            summary_lines.extend(show)

        summary_lines.append("")
        summary_lines.append("=" * 80)

    _append_model_backtest_logs_to_summary(
        summary_lines=summary_lines,
        model_names=model_names,
        model_logs=model_logs,
        show_last_n=30
    )

    summary_lines.append("")
    summary_lines.append("【各模型平均命中】")
    for k in model_names:
        v = model_hits.get(k, [])
        if v:
            summary_lines.append(f"- {k:<12} 平均命中 {np.mean(v):.2f}（σ={np.std(v):.2f}）")
        else:
            summary_lines.append(f"- {k:<12} （無回測資料）")
    summary_lines.append("")

    summary_lines.append("【彩金模式】")
    mode = str(payout_mode).lower()
    bet_top_n = int(PRED_TOP_N)

    if mode == "casino":
        summary_lines.append(f"- 模式：線上娛樂城 | 選號支數：{bet_top_n}")
    elif mode in ("lotto539", "539", "tw539"):
        summary_lines.append(f"- 模式：今彩539 | 選號支數：{bet_top_n}")
    else:
        plays = []
        for kk in (2, 3, 4):
            if kk in set(int(x) for x in (lehecai_play_ks or ())):
                plays.append(kk)
        if not plays:
            plays = [2, 3, 4]
        summary_lines.append(
            f"- 模式：39樂合彩 | 選號支數：{bet_top_n} | 玩法：{','.join(str(kk)+'合' for kk in plays)}"
        )

    summary_lines.append("")
    summary_lines.append("【各模型總計盈虧排名】")
    for idx, (k, profit) in enumerate(profit_rank, 1):
        info = model_prizes.get(k, {}) or {}
        total_cost = int(info.get("total_cost", 0))
        total_prize = int(info.get("total_prize", 0))
        total_profit = int(info.get("total_profit", profit))
        summary_lines.append(f"{idx}. {k}: 盈虧：{total_profit:,} | 成本：{total_cost:,} | 獎金：{total_prize:,}")

    summary_lines.append("")
    summary_lines.append("【各模型下一期預測（大小序）】")
    for k in model_names:
        pred_size = all_model_predictions_size.get(k, [])
        summary_lines.append(f"- {k:<12} {format_nums_with_marks(pred_size, mark_level)}")

    summary_lines.append("")
    summary_lines.append(f"【未加權+錯題本】{PRED_TOP_N}：{format_nums_with_marks(sorted(top_common_A), mark_level)}")
    summary_lines.append(f"【加權(WF)+錯題本】{PRED_TOP_N}：{format_nums_with_marks(sorted(top_common_B), mark_level)}")
    if overlap_nums:
        summary_lines.append(f"【至少 {overlap_min} 模型重疊】{format_nums_with_marks(sorted(overlap_nums), mark_level)}")
    summary_lines.append(f"【聯合集合 union】{format_nums_with_marks(union_nums, mark_level)}")

    summary_lines.append("")
    summary_lines.append(f"輸出檔案：{backtest_log_file}")
    summary_lines.append(f"統計檔：{history_fname}")
    summary_lines.append("（提醒）對獎以『期數』為準，日期僅為估計。")

    control.set_progress(100)
    control.set_status("完成")
    return "\n".join([line for line in summary_lines if line is not None])


# ==============================================
# GUI 主視窗
# ==============================================
class App(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("今彩539 自動化預測系統（多模型 + 特徵工程 + Walk-forward 回測 ）")
        self.geometry("980x620")
        self.minsize(920, 560)

        self.control = RunControl()
        self.log_queue = queue.Queue()
        self.worker_thread = None

        self.last_summary_text = ""
        self.last_summary_time = ""

        top = ttk.Frame(self)
        top.pack(fill="x", padx=12, pady=10)

        top_params = ttk.Frame(top)
        top_params.pack(fill="x")

        self.var_backtestN = tk.IntVar(value=600)
        self.var_bt_topn = tk.IntVar(value=6)
        self.var_pred_topn = tk.IntVar(value=6)

        self.var_use_human_rules = tk.BooleanVar(value=True)
        self.var_auto_learn_human_rules = tk.BooleanVar(value=True)
        self.var_show_human_ab = tk.BooleanVar(value=True)

        # ✅ 舊變數名相容
        self.var_use_ab = self.var_use_human_rules
        self.var_auto_pick_rules = self.var_auto_learn_human_rules
        self.var_gui_show_ab = self.var_show_human_ab

        self.var_payout_mode = tk.StringVar(value="casino")
        self.var_lehecai_k2 = tk.BooleanVar(value=True)
        self.var_lehecai_k3 = tk.BooleanVar(value=True)
        self.var_lehecai_k4 = tk.BooleanVar(value=True)

        def make_spin(parent, text, var, from_, to_, width=8):
            f = ttk.Frame(parent)
            ttk.Label(f, text=text).pack(side="left")
            sp = ttk.Spinbox(f, from_=from_, to=to_, textvariable=var, width=width, increment=1)
            sp.pack(side="left", padx=(6, 0))
            sp.configure(justify="center")
            return f

        make_spin(top_params, "回測最近期數（建議600）：", self.var_backtestN, 50, 5000, width=10).pack(side="left", padx=(0, 14))
        make_spin(top_params, "回測：", self.var_bt_topn, 1, 39, width=6).pack(side="left", padx=(0, 14))
        make_spin(top_params, "預測：", self.var_pred_topn, 1, 39, width=6).pack(side="left", padx=(0, 14))

        chk = ttk.Frame(top)
        chk.pack(fill="x", pady=(6, 0))
        ttk.Checkbutton(chk, text="啟用 人類規則 AB 對照", variable=self.var_use_human_rules).pack(side="left", padx=(0, 14))
        ttk.Checkbutton(chk, text="自動搜尋規則參數(較穩)", variable=self.var_auto_learn_human_rules).pack(side="left", padx=(0, 14))
        ttk.Checkbutton(chk, text="在GUI輸出顯示AB結果", variable=self.var_show_human_ab).pack(side="left", padx=(0, 14))

        payout_box = ttk.LabelFrame(top, text="彩金模式")
        payout_box.pack(fill="x", pady=(8, 0))

        row1 = ttk.Frame(payout_box)
        row1.pack(fill="x", padx=10, pady=(6, 2))

        ttk.Label(row1, text="模式：").pack(side="left")
        ttk.Radiobutton(row1, text="線上娛樂城", value="casino", variable=self.var_payout_mode, command=self._update_lehecai_checks_state).pack(side="left", padx=10)
        ttk.Radiobutton(row1, text="今彩539", value="lotto539", variable=self.var_payout_mode, command=self._update_lehecai_checks_state).pack(side="left", padx=10)
        ttk.Radiobutton(row1, text="39樂合彩", value="lehecai", variable=self.var_payout_mode, command=self._update_lehecai_checks_state).pack(side="left", padx=10)

        row2 = ttk.Frame(payout_box)
        row2.pack(fill="x", padx=10, pady=(2, 2))

        ttk.Label(row2, text="39樂合彩玩法：").pack(side="left")
        self.cb_lehecai_k2 = ttk.Checkbutton(row2, text="二合(2)", variable=self.var_lehecai_k2)
        self.cb_lehecai_k3 = ttk.Checkbutton(row2, text="三合(3)", variable=self.var_lehecai_k3)
        self.cb_lehecai_k4 = ttk.Checkbutton(row2, text="四合(4)", variable=self.var_lehecai_k4)

        self.cb_lehecai_k2.pack(side="left", padx=6)
        self.cb_lehecai_k3.pack(side="left", padx=6)
        self.cb_lehecai_k4.pack(side="left", padx=6)

        self._update_lehecai_checks_state()

        spacer = ttk.Frame(top_params)
        spacer.pack(side="left", expand=True, fill="x")

        # =========================
        # ✅ 按鈕區：兩排版面
        #   上排：執行 / 暫停 / 停止
        #   下排：查看最後結果
        # =========================
        btns = ttk.Frame(top_params)
        btns.pack(side="right")

        btns_row1 = ttk.Frame(btns)
        btns_row1.pack(side="top", anchor="e")

        btns_row2 = ttk.Frame(btns)
        btns_row2.pack(side="top", anchor="e", pady=(6, 0))

        # --- 上排 ---
        self.btn_run = ttk.Button(btns_row1, text="執行", command=self.on_run)
        self.btn_pause = ttk.Button(btns_row1, text="暫停", command=self.on_pause)
        self.btn_stop = ttk.Button(btns_row1, text="停止", command=self.on_stop)

        self.btn_run.pack(side="left", padx=4)
        self.btn_pause.pack(side="left", padx=4)
        self.btn_stop.pack(side="left", padx=4)

        # --- 下排 ---
        self.btn_show_result = ttk.Button(btns_row2, text="查看最後結果", command=self.on_show_last_result)
        self.btn_show_result.pack(side="left", padx=4)

        # --- 初始狀態 ---
        self.btn_pause.state(["disabled"])
        self.btn_stop.state(["disabled"])
        self.btn_show_result.state(["disabled"])


        mid = ttk.Frame(self)
        mid.pack(fill="x", padx=12, pady=(0, 8))

        self.var_status = tk.StringVar(value="待命")
        ttk.Label(mid, text="狀態：").pack(side="left")
        self.lbl_status = ttk.Label(mid, textvariable=self.var_status)
        self.lbl_status.pack(side="left", padx=(0, 10))

        self.var_progress = tk.StringVar(value="0%")
        self.lbl_progress = ttk.Label(mid, textvariable=self.var_progress)
        self.lbl_progress.pack(side="right", padx=(8, 0))

        self.pbar = ttk.Progressbar(mid, mode="determinate", length=220, maximum=100)
        self.pbar.pack(side="right")
        self.pbar["value"] = 0

        body = ttk.Frame(self)
        body.pack(fill="both", expand=True, padx=12, pady=(0, 12))

        self.txt = tk.Text(
            body,
            wrap="word",
            font=("Cascadia Mono", 11),
            bg="#0B0F14",
            fg="#D7DEE9",
            insertbackground="#FFFFFF",
            relief="flat",
            padx=12,
            pady=10,
            spacing1=2,
            spacing2=1,
            spacing3=4,
            selectbackground="#1E3A8A",
            selectforeground="#FFFFFF"
        )
        self.txt.pack(side="left", fill="both", expand=True)

        scroll = ttk.Scrollbar(body, orient="vertical", command=self.txt.yview)
        scroll.pack(side="right", fill="y")
        self.txt.configure(yscrollcommand=scroll.set)

        self.txt.tag_configure("INFO", foreground="#9CA3AF")
        self.txt.tag_configure("GOOD", foreground="#22C55E")
        self.txt.tag_configure("WARN", foreground="#F59E0B")
        self.txt.tag_configure("BAD",  foreground="#EF4444")
        self.txt.tag_configure("TITLE", foreground="#60A5FA")
        self.txt.tag_configure("MODEL", foreground="#A78BFA")
        self.txt.tag_configure("DIM", foreground="#64748B")

        self._tag_rules = [
            ("BAD",  re.compile(r"(錯誤|例外|Exception|Traceback|ERROR|Fail|失敗)", re.I)),
            ("GOOD", re.compile(r"(完成|成功|✅|已輸出|已儲存)", re.I)),
            ("WARN", re.compile(r"(提醒|注意|警告|⚠)", re.I)),
            ("TITLE", re.compile(r"^=+.*=+$")),
            ("MODEL", re.compile(r"\b(XGBoost|LightGBM|CatBoost|Logistic|RandomForest|CRF)\b", re.I)),
            ("DIM",  re.compile(r"^\s*[-=]{3,}\s*$")),
        ]

        self.after(80, self.pump_logs)
        self.after(250, self.refresh_status)

        self._tqdm_line_start = None
        self.protocol("WM_DELETE_WINDOW", self.on_close)

    def _append_log(self, s: str):
        s = ANSI_ESCAPE_RE.sub("", s)
        if not s:
            return

        def _choose_tag(line: str):
            tag = None
            for tname, cre in self._tag_rules:
                if cre.search(line):
                    tag = tname
                    break
            if tag is None:
                tag = "INFO" if line.strip() == "" else None
            return tag

        def overwrite_tqdm_line(text: str, tag_name="INFO"):
            if self._tqdm_line_start is None:
                self._tqdm_line_start = self.txt.index("end-1c")
            try:
                self.txt.delete(self._tqdm_line_start, "end-1c")
            except Exception:
                self._tqdm_line_start = self.txt.index("end-1c")
            text = text.replace("\n", "")
            self.txt.insert("end", text, tag_name)

        parts = s.split("\r")

        first = parts[0]
        if first:
            for line in first.splitlines(True):
                tag = _choose_tag(line)
                if tag:
                    self.txt.insert("end", line, tag)
                else:
                    self.txt.insert("end", line)

                if "\n" in line:
                    self._tqdm_line_start = None

        for p in parts[1:]:
            if not p:
                continue
            if "\n" in p:
                before, after = p.split("\n", 1)
                if before:
                    overwrite_tqdm_line(before, "INFO")
                self.txt.insert("end", "\n", "INFO")
                self._tqdm_line_start = None
                if after:
                    for line in after.splitlines(True):
                        tag = _choose_tag(line)
                        if tag:
                            self.txt.insert("end", line, tag)
                        else:
                            self.txt.insert("end", line)
            else:
                overwrite_tqdm_line(p, "INFO")

        self.txt.see("end")

    def pump_logs(self):
        try:
            while True:
                s = self.log_queue.get_nowait()
                self._append_log(s)
        except queue.Empty:
            pass
        self.after(80, self.pump_logs)

    def refresh_status(self):
        status = str(self.control.get_status() or "").strip()
        self.var_status.set(status)

        try:
            p = float(self.control.get_progress())
        except Exception:
            p = 0.0
        p = max(0.0, min(100.0, p))

        self.pbar["value"] = p
        self.var_progress.set(f"{int(p)}%")

        running = bool(self.worker_thread and self.worker_thread.is_alive())

        if not running:
            self.btn_run.state(["!disabled"])
            self.btn_pause.state(["disabled"])
            self.btn_stop.state(["disabled"])
            self.btn_pause.configure(text="暫停")
        else:
            self.btn_run.state(["disabled"])
            self.btn_pause.state(["!disabled"])
            self.btn_stop.state(["!disabled"])
            if "已暫停" in status or "暫停" in status:
                self.btn_pause.configure(text="續跑")
            else:
                self.btn_pause.configure(text="暫停")

        self.after(250, self.refresh_status)

    def _update_lehecai_checks_state(self):
        mode = str(self.var_payout_mode.get() or "").strip().lower()
        allow = mode in ("lehecai", "39", "39樂合彩", "lehecai39")

        try:
            widgets = [
                getattr(self, "cb_lehecai_k2", None),
                getattr(self, "cb_lehecai_k3", None),
                getattr(self, "cb_lehecai_k4", None),
            ]
            for w in widgets:
                if not w:
                    continue
                if allow:
                    w.state(["!disabled"])
                else:
                    w.state(["disabled"])
        except Exception:
            pass

    def on_show_last_result(self):
        if not self.last_summary_text.strip():
            messagebox.showinfo("提示", "目前沒有可查看的最後結果（請先執行一次並成功產生摘要）。")
            return
        title = "最後執行結果（摘要）"
        if self.last_summary_time:
            title = f"{title} - {self.last_summary_time}"
        self.open_result_window(self.last_summary_text, title=title)

    def on_show_filtered_backtest(self):
        """
        ✅ 只顯示 run_pipeline 回傳的摘要中的「篩選後六模型回測紀錄」
        目的：避免把主輸出區那種「未篩選」回測直接搬進摘要視窗造成混淆
        """
        if not self.last_summary_text.strip():
            messagebox.showinfo("提示", "目前沒有可查看的篩選後回測（請先執行一次並成功產生摘要）。")
            return

        title = "篩選後回測（摘要）"
        if self.last_summary_time:
            title = f"{title} - {self.last_summary_time}"

        # ✅ 直接顯示摘要全文（摘要內已含：篩選後六模型回測紀錄區塊）
        self.open_result_window(self.last_summary_text, title=title)

    def on_run(self):
        if self.worker_thread and self.worker_thread.is_alive():
            messagebox.showinfo("提示", "程式正在執行中。")
            return

        try:
            backtestN = int(self.var_backtestN.get())
            bt_topn = int(self.var_bt_topn.get())
            pred_topn = int(self.var_pred_topn.get())
        except Exception:
            messagebox.showerror("錯誤", "參數必須是整數。")
            return

        self.control = RunControl()
        self.control.set_status("啟動中")
        self.control.set_progress(0)

        self.btn_run.state(["disabled"])
        self.btn_pause.state(["!disabled"])
        self.btn_stop.state(["!disabled"])
        self.btn_pause.configure(text="暫停")

        self.btn_show_result.state(["disabled"])

        self.txt.delete("1.0", "end")

        self.pbar["value"] = 0
        self.var_progress.set("0%")

        self.worker_thread = threading.Thread(
            target=self._worker_main,
            args=(
                int(self.var_backtestN.get()),
                int(self.var_bt_topn.get()),
                int(self.var_pred_topn.get()),
                bool(self.var_use_human_rules.get()),
                bool(self.var_auto_learn_human_rules.get()),
                bool(self.var_show_human_ab.get()),
                str(self.var_payout_mode.get()),
                bool(self.var_lehecai_k2.get()),
                bool(self.var_lehecai_k3.get()),
                bool(self.var_lehecai_k4.get()),
            ),
            daemon=True
        )
        self.worker_thread.start()

    def on_pause(self):
        if not self.worker_thread or not self.worker_thread.is_alive():
            return

        if self.control.stop_event.is_set():
            self.control.set_status("停止中（正在安全中斷）")
            self.btn_pause.state(["disabled"])
            self.btn_stop.state(["disabled"])
            return

        if self.control.pause_event.is_set():
            self.control.request_pause()
            self.control.set_status("已暫停（等待續跑）")
            self.btn_pause.configure(text="續跑")
        else:
            self.control.request_resume()
            self.control.set_status("續跑中")
            self.btn_pause.configure(text="暫停")

    def on_stop(self):
        if not self.worker_thread or not self.worker_thread.is_alive():
            return

        self.control.request_stop()
        self.control.set_status("停止中（正在安全中斷）")

        self.btn_pause.state(["disabled"])
        self.btn_stop.state(["disabled"])
        self.btn_pause.configure(text="暫停")

    def on_close(self):
        if self.worker_thread and self.worker_thread.is_alive():
            if messagebox.askyesno("確認", "程式仍在執行，確定要停止並關閉？"):
                self.control.request_stop()
                self.after(300, self.destroy)
        else:
            self.destroy()

    def _worker_main(self, backtestN, bt_topn, pred_topn, use_ab, auto_pick_rules, gui_show_ab,
                     payout_mode, lehecai_k2, lehecai_k3, lehecai_k4):

        final_summary = ""
        try:
            with redirect_output_to_queue(self.log_queue):
                print("===== GUI 模式啟動 =====")
                print(f"回測期數={backtestN}，回測支數={bt_topn}，預測支數={pred_topn}")

                plays = []
                if lehecai_k2:
                    plays.append(2)
                if lehecai_k3:
                    plays.append(3)
                if lehecai_k4:
                    plays.append(4)
                lehecai_play_ks = tuple(plays) if plays else (2, 3, 4)

                _mode_map = {"casino": "線上娛樂城", "lotto539": "今彩539", "lehecai": "39樂合彩"}
                _mode_label = _mode_map.get(str(payout_mode), str(payout_mode))

                if str(payout_mode) == "lehecai":
                    print(f"彩金模式：{_mode_label} | 樂合彩玩法：{lehecai_play_ks} | 今彩539簽號：預測支數({pred_topn})")
                else:
                    print(f"彩金模式：{_mode_label} | 今彩539簽號：預測支數({pred_topn})")
                print("")

                final_summary = run_pipeline(
                    backtestN, bt_topn, pred_topn, self.control,
                    use_human_rules=use_ab,
                    auto_learn_human_rules=auto_pick_rules,
                    show_human_ab_in_gui=gui_show_ab,
                    payout_mode=payout_mode,
                    lehecai_play_ks=lehecai_play_ks
                )

        except KeyboardInterrupt:
            with redirect_output_to_queue(self.log_queue):
                print("\n【已停止】使用者停止執行。\n")
        except Exception as e:
            with redirect_output_to_queue(self.log_queue):
                print(f"\n【錯誤】{type(e).__name__}: {e}\n")
        finally:
            self.after(0, lambda: self._finish_ui(final_summary))

    def _finish_ui(self, final_summary: str):
        self.btn_run.state(["!disabled"])
        self.btn_pause.state(["disabled"])
        self.btn_stop.state(["disabled"])
        self.btn_pause.configure(text="暫停")

        if self.control.get_status() == "完成":
            self.pbar["value"] = 100
            self.var_progress.set("100%")

        if final_summary and ("【錯誤】" not in final_summary) and final_summary.strip():
            self.last_summary_text = final_summary
            self.last_summary_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # ✅ 兩個都可用：最後結果摘要 + 篩選後回測
            self.btn_show_result.state(["!disabled"])
            self.btn_show_bt_filtered.state(["!disabled"])

            messagebox.showinfo("完成", "執行完成！已輸出所有結果檔案。")
            self.open_result_window(final_summary, title=f"最後執行結果（摘要） - {self.last_summary_time}")
        else:
            if self.last_summary_text.strip():
                self.btn_show_result.state(["!disabled"])
                self.btn_show_bt_filtered.state(["!disabled"])
            if final_summary.strip():
                self.open_result_window(final_summary, title="最後執行結果（摘要）")


    def open_result_window(self, summary_text: str, title="最後執行結果（摘要）"):
        win = tk.Toplevel(self)
        win.title(title)
        win.geometry("900x560")
        win.minsize(820, 520)

        frm = ttk.Frame(win)
        frm.pack(fill="both", expand=True, padx=10, pady=10)

        txt = tk.Text(
            frm,
            wrap="word",
            font=("Cascadia Mono", 11),
            bg="#0B0F14",
            fg="#D7DEE9",
            insertbackground="#FFFFFF",
            relief="flat",
            padx=12,
            pady=10
        )
        txt.pack(side="left", fill="both", expand=True)

        scr = ttk.Scrollbar(frm, orient="vertical", command=txt.yview)
        scr.pack(side="right", fill="y")
        txt.configure(yscrollcommand=scr.set)

        txt.insert("end", summary_text)
        txt.see("1.0")


def main():
    app = App()
    app.mainloop()


if __name__ == "__main__":
    main()
